"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/basic-ftp";
exports.ids = ["vendor-chunks/basic-ftp"];
exports.modules = {

/***/ "(rsc)/./node_modules/basic-ftp/dist/Client.js":
/*!***********************************************!*\
  !*** ./node_modules/basic-ftp/dist/Client.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Client = void 0;\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst path_1 = __webpack_require__(/*! path */ \"path\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst FtpContext_1 = __webpack_require__(/*! ./FtpContext */ \"(rsc)/./node_modules/basic-ftp/dist/FtpContext.js\");\nconst parseList_1 = __webpack_require__(/*! ./parseList */ \"(rsc)/./node_modules/basic-ftp/dist/parseList.js\");\nconst ProgressTracker_1 = __webpack_require__(/*! ./ProgressTracker */ \"(rsc)/./node_modules/basic-ftp/dist/ProgressTracker.js\");\nconst StringWriter_1 = __webpack_require__(/*! ./StringWriter */ \"(rsc)/./node_modules/basic-ftp/dist/StringWriter.js\");\nconst parseListMLSD_1 = __webpack_require__(/*! ./parseListMLSD */ \"(rsc)/./node_modules/basic-ftp/dist/parseListMLSD.js\");\nconst netUtils_1 = __webpack_require__(/*! ./netUtils */ \"(rsc)/./node_modules/basic-ftp/dist/netUtils.js\");\nconst transfer_1 = __webpack_require__(/*! ./transfer */ \"(rsc)/./node_modules/basic-ftp/dist/transfer.js\");\nconst parseControlResponse_1 = __webpack_require__(/*! ./parseControlResponse */ \"(rsc)/./node_modules/basic-ftp/dist/parseControlResponse.js\");\n// Use promisify to keep the library compatible with Node 8.\nconst fsReadDir = (0, util_1.promisify)(fs_1.readdir);\nconst fsMkDir = (0, util_1.promisify)(fs_1.mkdir);\nconst fsStat = (0, util_1.promisify)(fs_1.stat);\nconst fsOpen = (0, util_1.promisify)(fs_1.open);\nconst fsClose = (0, util_1.promisify)(fs_1.close);\nconst fsUnlink = (0, util_1.promisify)(fs_1.unlink);\nconst LIST_COMMANDS_DEFAULT = () => [\"LIST -a\", \"LIST\"];\nconst LIST_COMMANDS_MLSD = () => [\"MLSD\", \"LIST -a\", \"LIST\"];\n/**\n * High-level API to interact with an FTP server.\n */\nclass Client {\n    /**\n     * Instantiate an FTP client.\n     *\n     * @param timeout  Timeout in milliseconds, use 0 for no timeout. Optional, default is 30 seconds.\n     */\n    constructor(timeout = 30000) {\n        this.availableListCommands = LIST_COMMANDS_DEFAULT();\n        this.ftp = new FtpContext_1.FTPContext(timeout);\n        this.prepareTransfer = this._enterFirstCompatibleMode([transfer_1.enterPassiveModeIPv6, transfer_1.enterPassiveModeIPv4]);\n        this.parseList = parseList_1.parseList;\n        this._progressTracker = new ProgressTracker_1.ProgressTracker();\n    }\n    /**\n     * Close the client and all open socket connections.\n     *\n     * Close the client and all open socket connections. The client canâ€™t be used anymore after calling this method,\n     * you have to either reconnect with `access` or `connect` or instantiate a new instance to continue any work.\n     * A client is also closed automatically if any timeout or connection error occurs.\n     */\n    close() {\n        this.ftp.close();\n        this._progressTracker.stop();\n    }\n    /**\n     * Returns true if the client is closed and can't be used anymore.\n     */\n    get closed() {\n        return this.ftp.closed;\n    }\n    /**\n     * Connect (or reconnect) to an FTP server.\n     *\n     * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`\n     * instance. Whenever you do, the client is reset with a new control connection. This also implies that\n     * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this\n     * method. In fact, reconnecting is the only way to continue using a closed `Client`.\n     *\n     * @param host  Host the client should connect to. Optional, default is \"localhost\".\n     * @param port  Port the client should connect to. Optional, default is 21.\n     */\n    connect(host = \"localhost\", port = 21) {\n        this.ftp.reset();\n        this.ftp.socket.connect({\n            host,\n            port,\n            family: this.ftp.ipFamily\n        }, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));\n        return this._handleConnectResponse();\n    }\n    /**\n     * As `connect` but using implicit TLS. Implicit TLS is not an FTP standard and has been replaced by\n     * explicit TLS. There are still FTP servers that support only implicit TLS, though.\n     */\n    connectImplicitTLS(host = \"localhost\", port = 21, tlsOptions = {}) {\n        this.ftp.reset();\n        this.ftp.socket = (0, tls_1.connect)(port, host, tlsOptions, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));\n        this.ftp.tlsOptions = tlsOptions;\n        return this._handleConnectResponse();\n    }\n    /**\n     * Handles the first reponse by an FTP server after the socket connection has been established.\n     */\n    _handleConnectResponse() {\n        return this.ftp.handle(undefined, (res, task) => {\n            if (res instanceof Error) {\n                // The connection has been destroyed by the FTPContext at this point.\n                task.reject(res);\n            }\n            else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) {\n                task.resolve(res);\n            }\n            // Reject all other codes, including 120 \"Service ready in nnn minutes\".\n            else {\n                // Don't stay connected but don't replace the socket yet by using reset()\n                // so the user can inspect properties of this instance.\n                task.reject(new FtpContext_1.FTPError(res));\n            }\n        });\n    }\n    /**\n     * Send an FTP command and handle the first response.\n     */\n    send(command, ignoreErrorCodesDEPRECATED = false) {\n        if (ignoreErrorCodesDEPRECATED) { // Deprecated starting from 3.9.0\n            this.ftp.log(\"Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command).\");\n            return this.sendIgnoringError(command);\n        }\n        return this.ftp.request(command);\n    }\n    /**\n     * Send an FTP command and ignore an FTP error response. Any other kind of error or timeout will still reject the Promise.\n     *\n     * @param command\n     */\n    sendIgnoringError(command) {\n        return this.ftp.handle(command, (res, task) => {\n            if (res instanceof FtpContext_1.FTPError) {\n                task.resolve({ code: res.code, message: res.message });\n            }\n            else if (res instanceof Error) {\n                task.reject(res);\n            }\n            else {\n                task.resolve(res);\n            }\n        });\n    }\n    /**\n     * Upgrade the current socket connection to TLS.\n     *\n     * @param options  TLS options as in `tls.connect(options)`, optional.\n     * @param command  Set the authentication command. Optional, default is \"AUTH TLS\".\n     */\n    async useTLS(options = {}, command = \"AUTH TLS\") {\n        const ret = await this.send(command);\n        this.ftp.socket = await (0, netUtils_1.upgradeSocket)(this.ftp.socket, options);\n        this.ftp.tlsOptions = options; // Keep the TLS options for later data connections that should use the same options.\n        this.ftp.log(`Control socket is using: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);\n        return ret;\n    }\n    /**\n     * Login a user with a password.\n     *\n     * @param user  Username to use for login. Optional, default is \"anonymous\".\n     * @param password  Password to use for login. Optional, default is \"guest\".\n     */\n    login(user = \"anonymous\", password = \"guest\") {\n        this.ftp.log(`Login security: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);\n        return this.ftp.handle(\"USER \" + user, (res, task) => {\n            if (res instanceof Error) {\n                task.reject(res);\n            }\n            else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) { // User logged in proceed OR Command superfluous\n                task.resolve(res);\n            }\n            else if (res.code === 331) { // User name okay, need password\n                this.ftp.send(\"PASS \" + password);\n            }\n            else { // Also report error on 332 (Need account)\n                task.reject(new FtpContext_1.FTPError(res));\n            }\n        });\n    }\n    /**\n     * Set the usual default settings.\n     *\n     * Settings used:\n     * * Binary mode (TYPE I)\n     * * File structure (STRU F)\n     * * Additional settings for FTPS (PBSZ 0, PROT P)\n     */\n    async useDefaultSettings() {\n        const features = await this.features();\n        // Use MLSD directory listing if possible. See https://tools.ietf.org/html/rfc3659#section-7.8:\n        // \"The presence of the MLST feature indicates that both MLST and MLSD are supported.\"\n        const supportsMLSD = features.has(\"MLST\");\n        this.availableListCommands = supportsMLSD ? LIST_COMMANDS_MLSD() : LIST_COMMANDS_DEFAULT();\n        await this.send(\"TYPE I\"); // Binary mode\n        await this.sendIgnoringError(\"STRU F\"); // Use file structure\n        await this.sendIgnoringError(\"OPTS UTF8 ON\"); // Some servers expect UTF-8 to be enabled explicitly and setting before login might not have worked.\n        if (supportsMLSD) {\n            await this.sendIgnoringError(\"OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;\"); // Make sure MLSD listings include all we can parse\n        }\n        if (this.ftp.hasTLS) {\n            await this.sendIgnoringError(\"PBSZ 0\"); // Set to 0 for TLS\n            await this.sendIgnoringError(\"PROT P\"); // Protect channel (also for data connections)\n        }\n    }\n    /**\n     * Convenience method that calls `connect`, `useTLS`, `login` and `useDefaultSettings`.\n     *\n     * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`\n     * instance. Whenever you do, the client is reset with a new control connection. This also implies that\n     * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this\n     * method. In fact, reconnecting is the only way to continue using a closed `Client`.\n     */\n    async access(options = {}) {\n        var _a, _b;\n        const useExplicitTLS = options.secure === true;\n        const useImplicitTLS = options.secure === \"implicit\";\n        let welcome;\n        if (useImplicitTLS) {\n            welcome = await this.connectImplicitTLS(options.host, options.port, options.secureOptions);\n        }\n        else {\n            welcome = await this.connect(options.host, options.port);\n        }\n        if (useExplicitTLS) {\n            // Fixes https://github.com/patrickjuchli/basic-ftp/issues/166 by making sure\n            // host is set for any future data connection as well.\n            const secureOptions = (_a = options.secureOptions) !== null && _a !== void 0 ? _a : {};\n            secureOptions.host = (_b = secureOptions.host) !== null && _b !== void 0 ? _b : options.host;\n            await this.useTLS(secureOptions);\n        }\n        // Set UTF-8 on before login in case there are non-ascii characters in user or password.\n        // Note that this might not work before login depending on server.\n        await this.sendIgnoringError(\"OPTS UTF8 ON\");\n        await this.login(options.user, options.password);\n        await this.useDefaultSettings();\n        return welcome;\n    }\n    /**\n     * Get the current working directory.\n     */\n    async pwd() {\n        const res = await this.send(\"PWD\");\n        // The directory is part of the return message, for example:\n        // 257 \"/this/that\" is current directory.\n        const parsed = res.message.match(/\"(.+)\"/);\n        if (parsed === null || parsed[1] === undefined) {\n            throw new Error(`Can't parse response to command 'PWD': ${res.message}`);\n        }\n        return parsed[1];\n    }\n    /**\n     * Get a description of supported features.\n     *\n     * This sends the FEAT command and parses the result into a Map where keys correspond to available commands\n     * and values hold further information. Be aware that your FTP servers might not support this\n     * command in which case this method will not throw an exception but just return an empty Map.\n     */\n    async features() {\n        const res = await this.sendIgnoringError(\"FEAT\");\n        const features = new Map();\n        // Not supporting any special features will be reported with a single line.\n        if (res.code < 400 && (0, parseControlResponse_1.isMultiline)(res.message)) {\n            // The first and last line wrap the multiline response, ignore them.\n            res.message.split(\"\\n\").slice(1, -1).forEach(line => {\n                // A typical lines looks like: \" REST STREAM\" or \" MDTM\".\n                // Servers might not use an indentation though.\n                const entry = line.trim().split(\" \");\n                features.set(entry[0], entry[1] || \"\");\n            });\n        }\n        return features;\n    }\n    /**\n     * Set the working directory.\n     */\n    async cd(path) {\n        const validPath = await this.protectWhitespace(path);\n        return this.send(\"CWD \" + validPath);\n    }\n    /**\n     * Switch to the parent directory of the working directory.\n     */\n    async cdup() {\n        return this.send(\"CDUP\");\n    }\n    /**\n     * Get the last modified time of a file. This is not supported by every FTP server, in which case\n     * calling this method will throw an exception.\n     */\n    async lastMod(path) {\n        const validPath = await this.protectWhitespace(path);\n        const res = await this.send(`MDTM ${validPath}`);\n        const date = res.message.slice(4);\n        return (0, parseListMLSD_1.parseMLSxDate)(date);\n    }\n    /**\n     * Get the size of a file.\n     */\n    async size(path) {\n        const validPath = await this.protectWhitespace(path);\n        const command = `SIZE ${validPath}`;\n        const res = await this.send(command);\n        // The size is part of the response message, for example: \"213 555555\". It's\n        // possible that there is a commmentary appended like \"213 5555, some commentary\".\n        const size = parseInt(res.message.slice(4), 10);\n        if (Number.isNaN(size)) {\n            throw new Error(`Can't parse response to command '${command}' as a numerical value: ${res.message}`);\n        }\n        return size;\n    }\n    /**\n     * Rename a file.\n     *\n     * Depending on the FTP server this might also be used to move a file from one\n     * directory to another by providing full paths.\n     */\n    async rename(srcPath, destPath) {\n        const validSrc = await this.protectWhitespace(srcPath);\n        const validDest = await this.protectWhitespace(destPath);\n        await this.send(\"RNFR \" + validSrc);\n        return this.send(\"RNTO \" + validDest);\n    }\n    /**\n     * Remove a file from the current working directory.\n     *\n     * You can ignore FTP error return codes which won't throw an exception if e.g.\n     * the file doesn't exist.\n     */\n    async remove(path, ignoreErrorCodes = false) {\n        const validPath = await this.protectWhitespace(path);\n        if (ignoreErrorCodes) {\n            return this.sendIgnoringError(`DELE ${validPath}`);\n        }\n        return this.send(`DELE ${validPath}`);\n    }\n    /**\n     * Report transfer progress for any upload or download to a given handler.\n     *\n     * This will also reset the overall transfer counter that can be used for multiple transfers. You can\n     * also call the function without a handler to stop reporting to an earlier one.\n     *\n     * @param handler  Handler function to call on transfer progress.\n     */\n    trackProgress(handler) {\n        this._progressTracker.bytesOverall = 0;\n        this._progressTracker.reportTo(handler);\n    }\n    /**\n     * Upload data from a readable stream or a local file to a remote file.\n     *\n     * @param source  Readable stream or path to a local file.\n     * @param toRemotePath  Path to a remote file to write to.\n     */\n    async uploadFrom(source, toRemotePath, options = {}) {\n        return this._uploadWithCommand(source, toRemotePath, \"STOR\", options);\n    }\n    /**\n     * Upload data from a readable stream or a local file by appending it to an existing file. If the file doesn't\n     * exist the FTP server should create it.\n     *\n     * @param source  Readable stream or path to a local file.\n     * @param toRemotePath  Path to a remote file to write to.\n     */\n    async appendFrom(source, toRemotePath, options = {}) {\n        return this._uploadWithCommand(source, toRemotePath, \"APPE\", options);\n    }\n    /**\n     * @protected\n     */\n    async _uploadWithCommand(source, remotePath, command, options) {\n        if (typeof source === \"string\") {\n            return this._uploadLocalFile(source, remotePath, command, options);\n        }\n        return this._uploadFromStream(source, remotePath, command);\n    }\n    /**\n     * @protected\n     */\n    async _uploadLocalFile(localPath, remotePath, command, options) {\n        const fd = await fsOpen(localPath, \"r\");\n        const source = (0, fs_1.createReadStream)(\"\", {\n            fd,\n            start: options.localStart,\n            end: options.localEndInclusive,\n            autoClose: false\n        });\n        try {\n            return await this._uploadFromStream(source, remotePath, command);\n        }\n        finally {\n            await ignoreError(() => fsClose(fd));\n        }\n    }\n    /**\n     * @protected\n     */\n    async _uploadFromStream(source, remotePath, command) {\n        const onError = (err) => this.ftp.closeWithError(err);\n        source.once(\"error\", onError);\n        try {\n            const validPath = await this.protectWhitespace(remotePath);\n            await this.prepareTransfer(this.ftp);\n            // Keep the keyword `await` or the `finally` clause below runs too early\n            // and removes the event listener for the source stream too early.\n            return await (0, transfer_1.uploadFrom)(source, {\n                ftp: this.ftp,\n                tracker: this._progressTracker,\n                command,\n                remotePath: validPath,\n                type: \"upload\"\n            });\n        }\n        finally {\n            source.removeListener(\"error\", onError);\n        }\n    }\n    /**\n     * Download a remote file and pipe its data to a writable stream or to a local file.\n     *\n     * You can optionally define at which position of the remote file you'd like to start\n     * downloading. If the destination you provide is a file, the offset will be applied\n     * to it as well. For example: To resume a failed download, you'd request the size of\n     * the local, partially downloaded file and use that as the offset. Assuming the size\n     * is 23, you'd download the rest using `downloadTo(\"local.txt\", \"remote.txt\", 23)`.\n     *\n     * @param destination  Stream or path for a local file to write to.\n     * @param fromRemotePath  Path of the remote file to read from.\n     * @param startAt  Position within the remote file to start downloading at. If the destination is a file, this offset is also applied to it.\n     */\n    async downloadTo(destination, fromRemotePath, startAt = 0) {\n        if (typeof destination === \"string\") {\n            return this._downloadToFile(destination, fromRemotePath, startAt);\n        }\n        return this._downloadToStream(destination, fromRemotePath, startAt);\n    }\n    /**\n     * @protected\n     */\n    async _downloadToFile(localPath, remotePath, startAt) {\n        const appendingToLocalFile = startAt > 0;\n        const fileSystemFlags = appendingToLocalFile ? \"r+\" : \"w\";\n        const fd = await fsOpen(localPath, fileSystemFlags);\n        const destination = (0, fs_1.createWriteStream)(\"\", {\n            fd,\n            start: startAt,\n            autoClose: false\n        });\n        try {\n            return await this._downloadToStream(destination, remotePath, startAt);\n        }\n        catch (err) {\n            const localFileStats = await ignoreError(() => fsStat(localPath));\n            const hasDownloadedData = localFileStats && localFileStats.size > 0;\n            const shouldRemoveLocalFile = !appendingToLocalFile && !hasDownloadedData;\n            if (shouldRemoveLocalFile) {\n                await ignoreError(() => fsUnlink(localPath));\n            }\n            throw err;\n        }\n        finally {\n            await ignoreError(() => fsClose(fd));\n        }\n    }\n    /**\n     * @protected\n     */\n    async _downloadToStream(destination, remotePath, startAt) {\n        const onError = (err) => this.ftp.closeWithError(err);\n        destination.once(\"error\", onError);\n        try {\n            const validPath = await this.protectWhitespace(remotePath);\n            await this.prepareTransfer(this.ftp);\n            // Keep the keyword `await` or the `finally` clause below runs too early\n            // and removes the event listener for the source stream too early.\n            return await (0, transfer_1.downloadTo)(destination, {\n                ftp: this.ftp,\n                tracker: this._progressTracker,\n                command: startAt > 0 ? `REST ${startAt}` : `RETR ${validPath}`,\n                remotePath: validPath,\n                type: \"download\"\n            });\n        }\n        finally {\n            destination.removeListener(\"error\", onError);\n            destination.end();\n        }\n    }\n    /**\n     * List files and directories in the current working directory, or from `path` if specified.\n     *\n     * @param [path]  Path to remote file or directory.\n     */\n    async list(path = \"\") {\n        const validPath = await this.protectWhitespace(path);\n        let lastError;\n        for (const candidate of this.availableListCommands) {\n            const command = validPath === \"\" ? candidate : `${candidate} ${validPath}`;\n            await this.prepareTransfer(this.ftp);\n            try {\n                const parsedList = await this._requestListWithCommand(command);\n                // Use successful candidate for all subsequent requests.\n                this.availableListCommands = [candidate];\n                return parsedList;\n            }\n            catch (err) {\n                const shouldTryNext = err instanceof FtpContext_1.FTPError;\n                if (!shouldTryNext) {\n                    throw err;\n                }\n                lastError = err;\n            }\n        }\n        throw lastError;\n    }\n    /**\n     * @protected\n     */\n    async _requestListWithCommand(command) {\n        const buffer = new StringWriter_1.StringWriter();\n        await (0, transfer_1.downloadTo)(buffer, {\n            ftp: this.ftp,\n            tracker: this._progressTracker,\n            command,\n            remotePath: \"\",\n            type: \"list\"\n        });\n        const text = buffer.getText(this.ftp.encoding);\n        this.ftp.log(text);\n        return this.parseList(text);\n    }\n    /**\n     * Remove a directory and all of its content.\n     *\n     * @param remoteDirPath  The path of the remote directory to delete.\n     * @example client.removeDir(\"foo\") // Remove directory 'foo' using a relative path.\n     * @example client.removeDir(\"foo/bar\") // Remove directory 'bar' using a relative path.\n     * @example client.removeDir(\"/foo/bar\") // Remove directory 'bar' using an absolute path.\n     * @example client.removeDir(\"/\") // Remove everything.\n     */\n    async removeDir(remoteDirPath) {\n        return this._exitAtCurrentDirectory(async () => {\n            await this.cd(remoteDirPath);\n            // Get the absolute path of the target because remoteDirPath might be a relative path, even `../` is possible.\n            const absoluteDirPath = await this.pwd();\n            await this.clearWorkingDir();\n            const dirIsRoot = absoluteDirPath === \"/\";\n            if (!dirIsRoot) {\n                await this.cdup();\n                await this.removeEmptyDir(absoluteDirPath);\n            }\n        });\n    }\n    /**\n     * Remove all files and directories in the working directory without removing\n     * the working directory itself.\n     */\n    async clearWorkingDir() {\n        for (const file of await this.list()) {\n            if (file.isDirectory) {\n                await this.cd(file.name);\n                await this.clearWorkingDir();\n                await this.cdup();\n                await this.removeEmptyDir(file.name);\n            }\n            else {\n                await this.remove(file.name);\n            }\n        }\n    }\n    /**\n     * Upload the contents of a local directory to the remote working directory.\n     *\n     * This will overwrite existing files with the same names and reuse existing directories.\n     * Unrelated files and directories will remain untouched. You can optionally provide a `remoteDirPath`\n     * to put the contents inside a directory which will be created if necessary including all\n     * intermediate directories. If you did provide a remoteDirPath the working directory will stay\n     * the same as before calling this method.\n     *\n     * @param localDirPath  Local path, e.g. \"foo/bar\" or \"../test\"\n     * @param [remoteDirPath]  Remote path of a directory to upload to. Working directory if undefined.\n     */\n    async uploadFromDir(localDirPath, remoteDirPath) {\n        return this._exitAtCurrentDirectory(async () => {\n            if (remoteDirPath) {\n                await this.ensureDir(remoteDirPath);\n            }\n            return await this._uploadToWorkingDir(localDirPath);\n        });\n    }\n    /**\n     * @protected\n     */\n    async _uploadToWorkingDir(localDirPath) {\n        const files = await fsReadDir(localDirPath);\n        for (const file of files) {\n            const fullPath = (0, path_1.join)(localDirPath, file);\n            const stats = await fsStat(fullPath);\n            if (stats.isFile()) {\n                await this.uploadFrom(fullPath, file);\n            }\n            else if (stats.isDirectory()) {\n                await this._openDir(file);\n                await this._uploadToWorkingDir(fullPath);\n                await this.cdup();\n            }\n        }\n    }\n    /**\n     * Download all files and directories of the working directory to a local directory.\n     *\n     * @param localDirPath  The local directory to download to.\n     * @param remoteDirPath  Remote directory to download. Current working directory if not specified.\n     */\n    async downloadToDir(localDirPath, remoteDirPath) {\n        return this._exitAtCurrentDirectory(async () => {\n            if (remoteDirPath) {\n                await this.cd(remoteDirPath);\n            }\n            return await this._downloadFromWorkingDir(localDirPath);\n        });\n    }\n    /**\n     * @protected\n     */\n    async _downloadFromWorkingDir(localDirPath) {\n        await ensureLocalDirectory(localDirPath);\n        for (const file of await this.list()) {\n            const localPath = (0, path_1.join)(localDirPath, file.name);\n            if (file.isDirectory) {\n                await this.cd(file.name);\n                await this._downloadFromWorkingDir(localPath);\n                await this.cdup();\n            }\n            else if (file.isFile) {\n                await this.downloadTo(localPath, file.name);\n            }\n        }\n    }\n    /**\n     * Make sure a given remote path exists, creating all directories as necessary.\n     * This function also changes the current working directory to the given path.\n     */\n    async ensureDir(remoteDirPath) {\n        // If the remoteDirPath was absolute go to root directory.\n        if (remoteDirPath.startsWith(\"/\")) {\n            await this.cd(\"/\");\n        }\n        const names = remoteDirPath.split(\"/\").filter(name => name !== \"\");\n        for (const name of names) {\n            await this._openDir(name);\n        }\n    }\n    /**\n     * Try to create a directory and enter it. This will not raise an exception if the directory\n     * couldn't be created if for example it already exists.\n     * @protected\n     */\n    async _openDir(dirName) {\n        await this.sendIgnoringError(\"MKD \" + dirName);\n        await this.cd(dirName);\n    }\n    /**\n     * Remove an empty directory, will fail if not empty.\n     */\n    async removeEmptyDir(path) {\n        const validPath = await this.protectWhitespace(path);\n        return this.send(`RMD ${validPath}`);\n    }\n    /**\n     * FTP servers can't handle filenames that have leading whitespace. This method transforms\n     * a given path to fix that issue for most cases.\n     */\n    async protectWhitespace(path) {\n        if (!path.startsWith(\" \")) {\n            return path;\n        }\n        // Handle leading whitespace by prepending the absolute path:\n        // \" test.txt\" while being in the root directory becomes \"/ test.txt\".\n        const pwd = await this.pwd();\n        const absolutePathPrefix = pwd.endsWith(\"/\") ? pwd : pwd + \"/\";\n        return absolutePathPrefix + path;\n    }\n    async _exitAtCurrentDirectory(func) {\n        const userDir = await this.pwd();\n        try {\n            return await func();\n        }\n        finally {\n            if (!this.closed) {\n                await ignoreError(() => this.cd(userDir));\n            }\n        }\n    }\n    /**\n     * Try all available transfer strategies and pick the first one that works. Update `client` to\n     * use the working strategy for all successive transfer requests.\n     *\n     * @returns a function that will try the provided strategies.\n     */\n    _enterFirstCompatibleMode(strategies) {\n        return async (ftp) => {\n            ftp.log(\"Trying to find optimal transfer strategy...\");\n            let lastError = undefined;\n            for (const strategy of strategies) {\n                try {\n                    const res = await strategy(ftp);\n                    ftp.log(\"Optimal transfer strategy found.\");\n                    this.prepareTransfer = strategy; // eslint-disable-line require-atomic-updates\n                    return res;\n                }\n                catch (err) {\n                    // Try the next candidate no matter the exact error. It's possible that a server\n                    // answered incorrectly to a strategy, for example a PASV answer to an EPSV.\n                    lastError = err;\n                }\n            }\n            throw new Error(`None of the available transfer strategies work. Last error response was '${lastError}'.`);\n        };\n    }\n    /**\n     * DEPRECATED, use `uploadFrom`.\n     * @deprecated\n     */\n    async upload(source, toRemotePath, options = {}) {\n        this.ftp.log(\"Warning: upload() has been deprecated, use uploadFrom().\");\n        return this.uploadFrom(source, toRemotePath, options);\n    }\n    /**\n     * DEPRECATED, use `appendFrom`.\n     * @deprecated\n     */\n    async append(source, toRemotePath, options = {}) {\n        this.ftp.log(\"Warning: append() has been deprecated, use appendFrom().\");\n        return this.appendFrom(source, toRemotePath, options);\n    }\n    /**\n     * DEPRECATED, use `downloadTo`.\n     * @deprecated\n     */\n    async download(destination, fromRemotePath, startAt = 0) {\n        this.ftp.log(\"Warning: download() has been deprecated, use downloadTo().\");\n        return this.downloadTo(destination, fromRemotePath, startAt);\n    }\n    /**\n     * DEPRECATED, use `uploadFromDir`.\n     * @deprecated\n     */\n    async uploadDir(localDirPath, remoteDirPath) {\n        this.ftp.log(\"Warning: uploadDir() has been deprecated, use uploadFromDir().\");\n        return this.uploadFromDir(localDirPath, remoteDirPath);\n    }\n    /**\n     * DEPRECATED, use `downloadToDir`.\n     * @deprecated\n     */\n    async downloadDir(localDirPath) {\n        this.ftp.log(\"Warning: downloadDir() has been deprecated, use downloadToDir().\");\n        return this.downloadToDir(localDirPath);\n    }\n}\nexports.Client = Client;\nasync function ensureLocalDirectory(path) {\n    try {\n        await fsStat(path);\n    }\n    catch (err) {\n        await fsMkDir(path, { recursive: true });\n    }\n}\nasync function ignoreError(func) {\n    try {\n        return await func();\n    }\n    catch (err) {\n        // Ignore\n        return undefined;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvQ2xpZW50LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWM7QUFDZCxhQUFhLG1CQUFPLENBQUMsY0FBSTtBQUN6QixlQUFlLG1CQUFPLENBQUMsa0JBQU07QUFDN0IsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLGVBQWUsbUJBQU8sQ0FBQyxrQkFBTTtBQUM3QixxQkFBcUIsbUJBQU8sQ0FBQyx1RUFBYztBQUMzQyxvQkFBb0IsbUJBQU8sQ0FBQyxxRUFBYTtBQUN6QywwQkFBMEIsbUJBQU8sQ0FBQyxpRkFBbUI7QUFDckQsdUJBQXVCLG1CQUFPLENBQUMsMkVBQWdCO0FBQy9DLHdCQUF3QixtQkFBTyxDQUFDLDZFQUFpQjtBQUNqRCxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUN2QyxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUN2QywrQkFBK0IsbUJBQU8sQ0FBQywyRkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMscUNBQXFDLGtEQUFrRCxHQUFHLDZDQUE2QztBQUNoSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQSx3R0FBd0csa0RBQWtELEdBQUcsNkNBQTZDO0FBQzFNO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNDQUFzQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDLGlEQUFpRCw2Q0FBNkM7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZDQUE2QztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlGQUFpRjtBQUNqRjtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkMsZ0RBQWdEO0FBQ2hELHNEQUFzRDtBQUN0RDtBQUNBLHlEQUF5RCxLQUFLLE9BQU8sT0FBTyxVQUFVLFdBQVcsV0FBVyxlQUFlLGVBQWUsSUFBSTtBQUM5STtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELG9EQUFvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0UsWUFBWTtBQUNsRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFVBQVU7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxRQUFRLDBCQUEwQixZQUFZO0FBQzlHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxVQUFVO0FBQzVEO0FBQ0EsaUNBQWlDLFVBQVU7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsUUFBUSxZQUFZLFVBQVU7QUFDN0U7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQsV0FBVyxFQUFFLFVBQVU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxVQUFVO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0csVUFBVTtBQUNsSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixpQkFBaUI7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXFdlYnN0ZXAyXFxzaGlwb3dsLW1lcmdlXFxub2RlX21vZHVsZXNcXGJhc2ljLWZ0cFxcZGlzdFxcQ2xpZW50LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DbGllbnQgPSB2b2lkIDA7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgcGF0aF8xID0gcmVxdWlyZShcInBhdGhcIik7XG5jb25zdCB0bHNfMSA9IHJlcXVpcmUoXCJ0bHNcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwidXRpbFwiKTtcbmNvbnN0IEZ0cENvbnRleHRfMSA9IHJlcXVpcmUoXCIuL0Z0cENvbnRleHRcIik7XG5jb25zdCBwYXJzZUxpc3RfMSA9IHJlcXVpcmUoXCIuL3BhcnNlTGlzdFwiKTtcbmNvbnN0IFByb2dyZXNzVHJhY2tlcl8xID0gcmVxdWlyZShcIi4vUHJvZ3Jlc3NUcmFja2VyXCIpO1xuY29uc3QgU3RyaW5nV3JpdGVyXzEgPSByZXF1aXJlKFwiLi9TdHJpbmdXcml0ZXJcIik7XG5jb25zdCBwYXJzZUxpc3RNTFNEXzEgPSByZXF1aXJlKFwiLi9wYXJzZUxpc3RNTFNEXCIpO1xuY29uc3QgbmV0VXRpbHNfMSA9IHJlcXVpcmUoXCIuL25ldFV0aWxzXCIpO1xuY29uc3QgdHJhbnNmZXJfMSA9IHJlcXVpcmUoXCIuL3RyYW5zZmVyXCIpO1xuY29uc3QgcGFyc2VDb250cm9sUmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL3BhcnNlQ29udHJvbFJlc3BvbnNlXCIpO1xuLy8gVXNlIHByb21pc2lmeSB0byBrZWVwIHRoZSBsaWJyYXJ5IGNvbXBhdGlibGUgd2l0aCBOb2RlIDguXG5jb25zdCBmc1JlYWREaXIgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoZnNfMS5yZWFkZGlyKTtcbmNvbnN0IGZzTWtEaXIgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoZnNfMS5ta2Rpcik7XG5jb25zdCBmc1N0YXQgPSAoMCwgdXRpbF8xLnByb21pc2lmeSkoZnNfMS5zdGF0KTtcbmNvbnN0IGZzT3BlbiA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShmc18xLm9wZW4pO1xuY29uc3QgZnNDbG9zZSA9ICgwLCB1dGlsXzEucHJvbWlzaWZ5KShmc18xLmNsb3NlKTtcbmNvbnN0IGZzVW5saW5rID0gKDAsIHV0aWxfMS5wcm9taXNpZnkpKGZzXzEudW5saW5rKTtcbmNvbnN0IExJU1RfQ09NTUFORFNfREVGQVVMVCA9ICgpID0+IFtcIkxJU1QgLWFcIiwgXCJMSVNUXCJdO1xuY29uc3QgTElTVF9DT01NQU5EU19NTFNEID0gKCkgPT4gW1wiTUxTRFwiLCBcIkxJU1QgLWFcIiwgXCJMSVNUXCJdO1xuLyoqXG4gKiBIaWdoLWxldmVsIEFQSSB0byBpbnRlcmFjdCB3aXRoIGFuIEZUUCBzZXJ2ZXIuXG4gKi9cbmNsYXNzIENsaWVudCB7XG4gICAgLyoqXG4gICAgICogSW5zdGFudGlhdGUgYW4gRlRQIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB0aW1lb3V0ICBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcywgdXNlIDAgZm9yIG5vIHRpbWVvdXQuIE9wdGlvbmFsLCBkZWZhdWx0IGlzIDMwIHNlY29uZHMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGltZW91dCA9IDMwMDAwKSB7XG4gICAgICAgIHRoaXMuYXZhaWxhYmxlTGlzdENvbW1hbmRzID0gTElTVF9DT01NQU5EU19ERUZBVUxUKCk7XG4gICAgICAgIHRoaXMuZnRwID0gbmV3IEZ0cENvbnRleHRfMS5GVFBDb250ZXh0KHRpbWVvdXQpO1xuICAgICAgICB0aGlzLnByZXBhcmVUcmFuc2ZlciA9IHRoaXMuX2VudGVyRmlyc3RDb21wYXRpYmxlTW9kZShbdHJhbnNmZXJfMS5lbnRlclBhc3NpdmVNb2RlSVB2NiwgdHJhbnNmZXJfMS5lbnRlclBhc3NpdmVNb2RlSVB2NF0pO1xuICAgICAgICB0aGlzLnBhcnNlTGlzdCA9IHBhcnNlTGlzdF8xLnBhcnNlTGlzdDtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NUcmFja2VyID0gbmV3IFByb2dyZXNzVHJhY2tlcl8xLlByb2dyZXNzVHJhY2tlcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgY2xpZW50IGFuZCBhbGwgb3BlbiBzb2NrZXQgY29ubmVjdGlvbnMuXG4gICAgICpcbiAgICAgKiBDbG9zZSB0aGUgY2xpZW50IGFuZCBhbGwgb3BlbiBzb2NrZXQgY29ubmVjdGlvbnMuIFRoZSBjbGllbnQgY2Fu4oCZdCBiZSB1c2VkIGFueW1vcmUgYWZ0ZXIgY2FsbGluZyB0aGlzIG1ldGhvZCxcbiAgICAgKiB5b3UgaGF2ZSB0byBlaXRoZXIgcmVjb25uZWN0IHdpdGggYGFjY2Vzc2Agb3IgYGNvbm5lY3RgIG9yIGluc3RhbnRpYXRlIGEgbmV3IGluc3RhbmNlIHRvIGNvbnRpbnVlIGFueSB3b3JrLlxuICAgICAqIEEgY2xpZW50IGlzIGFsc28gY2xvc2VkIGF1dG9tYXRpY2FsbHkgaWYgYW55IHRpbWVvdXQgb3IgY29ubmVjdGlvbiBlcnJvciBvY2N1cnMuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIHRoaXMuZnRwLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzVHJhY2tlci5zdG9wKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdHJ1ZSBpZiB0aGUgY2xpZW50IGlzIGNsb3NlZCBhbmQgY2FuJ3QgYmUgdXNlZCBhbnltb3JlLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ0cC5jbG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3QgKG9yIHJlY29ubmVjdCkgdG8gYW4gRlRQIHNlcnZlci5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB0aHVzIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIHRoZSBsaWZlY3ljbGUgb2YgYSBgQ2xpZW50YFxuICAgICAqIGluc3RhbmNlLiBXaGVuZXZlciB5b3UgZG8sIHRoZSBjbGllbnQgaXMgcmVzZXQgd2l0aCBhIG5ldyBjb250cm9sIGNvbm5lY3Rpb24uIFRoaXMgYWxzbyBpbXBsaWVzIHRoYXRcbiAgICAgKiB5b3UgY2FuIHJlb3BlbiBhIGBDbGllbnRgIGluc3RhbmNlIHRoYXQgaGFzIGJlZW4gY2xvc2VkIGR1ZSB0byBhbiBlcnJvciB3aGVuIHJlY29ubmVjdGluZyB3aXRoIHRoaXNcbiAgICAgKiBtZXRob2QuIEluIGZhY3QsIHJlY29ubmVjdGluZyBpcyB0aGUgb25seSB3YXkgdG8gY29udGludWUgdXNpbmcgYSBjbG9zZWQgYENsaWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gaG9zdCAgSG9zdCB0aGUgY2xpZW50IHNob3VsZCBjb25uZWN0IHRvLiBPcHRpb25hbCwgZGVmYXVsdCBpcyBcImxvY2FsaG9zdFwiLlxuICAgICAqIEBwYXJhbSBwb3J0ICBQb3J0IHRoZSBjbGllbnQgc2hvdWxkIGNvbm5lY3QgdG8uIE9wdGlvbmFsLCBkZWZhdWx0IGlzIDIxLlxuICAgICAqL1xuICAgIGNvbm5lY3QoaG9zdCA9IFwibG9jYWxob3N0XCIsIHBvcnQgPSAyMSkge1xuICAgICAgICB0aGlzLmZ0cC5yZXNldCgpO1xuICAgICAgICB0aGlzLmZ0cC5zb2NrZXQuY29ubmVjdCh7XG4gICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgcG9ydCxcbiAgICAgICAgICAgIGZhbWlseTogdGhpcy5mdHAuaXBGYW1pbHlcbiAgICAgICAgfSwgKCkgPT4gdGhpcy5mdHAubG9nKGBDb25uZWN0ZWQgdG8gJHsoMCwgbmV0VXRpbHNfMS5kZXNjcmliZUFkZHJlc3MpKHRoaXMuZnRwLnNvY2tldCl9ICgkeygwLCBuZXRVdGlsc18xLmRlc2NyaWJlVExTKSh0aGlzLmZ0cC5zb2NrZXQpfSlgKSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDb25uZWN0UmVzcG9uc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXMgYGNvbm5lY3RgIGJ1dCB1c2luZyBpbXBsaWNpdCBUTFMuIEltcGxpY2l0IFRMUyBpcyBub3QgYW4gRlRQIHN0YW5kYXJkIGFuZCBoYXMgYmVlbiByZXBsYWNlZCBieVxuICAgICAqIGV4cGxpY2l0IFRMUy4gVGhlcmUgYXJlIHN0aWxsIEZUUCBzZXJ2ZXJzIHRoYXQgc3VwcG9ydCBvbmx5IGltcGxpY2l0IFRMUywgdGhvdWdoLlxuICAgICAqL1xuICAgIGNvbm5lY3RJbXBsaWNpdFRMUyhob3N0ID0gXCJsb2NhbGhvc3RcIiwgcG9ydCA9IDIxLCB0bHNPcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5mdHAucmVzZXQoKTtcbiAgICAgICAgdGhpcy5mdHAuc29ja2V0ID0gKDAsIHRsc18xLmNvbm5lY3QpKHBvcnQsIGhvc3QsIHRsc09wdGlvbnMsICgpID0+IHRoaXMuZnRwLmxvZyhgQ29ubmVjdGVkIHRvICR7KDAsIG5ldFV0aWxzXzEuZGVzY3JpYmVBZGRyZXNzKSh0aGlzLmZ0cC5zb2NrZXQpfSAoJHsoMCwgbmV0VXRpbHNfMS5kZXNjcmliZVRMUykodGhpcy5mdHAuc29ja2V0KX0pYCkpO1xuICAgICAgICB0aGlzLmZ0cC50bHNPcHRpb25zID0gdGxzT3B0aW9ucztcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZUNvbm5lY3RSZXNwb25zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIHRoZSBmaXJzdCByZXBvbnNlIGJ5IGFuIEZUUCBzZXJ2ZXIgYWZ0ZXIgdGhlIHNvY2tldCBjb25uZWN0aW9uIGhhcyBiZWVuIGVzdGFibGlzaGVkLlxuICAgICAqL1xuICAgIF9oYW5kbGVDb25uZWN0UmVzcG9uc2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZ0cC5oYW5kbGUodW5kZWZpbmVkLCAocmVzLCB0YXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGUgY29ubmVjdGlvbiBoYXMgYmVlbiBkZXN0cm95ZWQgYnkgdGhlIEZUUENvbnRleHQgYXQgdGhpcyBwb2ludC5cbiAgICAgICAgICAgICAgICB0YXNrLnJlamVjdChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoKDAsIHBhcnNlQ29udHJvbFJlc3BvbnNlXzEucG9zaXRpdmVDb21wbGV0aW9uKShyZXMuY29kZSkpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlamVjdCBhbGwgb3RoZXIgY29kZXMsIGluY2x1ZGluZyAxMjAgXCJTZXJ2aWNlIHJlYWR5IGluIG5ubiBtaW51dGVzXCIuXG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBEb24ndCBzdGF5IGNvbm5lY3RlZCBidXQgZG9uJ3QgcmVwbGFjZSB0aGUgc29ja2V0IHlldCBieSB1c2luZyByZXNldCgpXG4gICAgICAgICAgICAgICAgLy8gc28gdGhlIHVzZXIgY2FuIGluc3BlY3QgcHJvcGVydGllcyBvZiB0aGlzIGluc3RhbmNlLlxuICAgICAgICAgICAgICAgIHRhc2sucmVqZWN0KG5ldyBGdHBDb250ZXh0XzEuRlRQRXJyb3IocmVzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGFuIEZUUCBjb21tYW5kIGFuZCBoYW5kbGUgdGhlIGZpcnN0IHJlc3BvbnNlLlxuICAgICAqL1xuICAgIHNlbmQoY29tbWFuZCwgaWdub3JlRXJyb3JDb2Rlc0RFUFJFQ0FURUQgPSBmYWxzZSkge1xuICAgICAgICBpZiAoaWdub3JlRXJyb3JDb2Rlc0RFUFJFQ0FURUQpIHsgLy8gRGVwcmVjYXRlZCBzdGFydGluZyBmcm9tIDMuOS4wXG4gICAgICAgICAgICB0aGlzLmZ0cC5sb2coXCJEZXByZWNhdGVkIGNhbGwgdXNpbmcgc2VuZChjb21tYW5kLCBmbGFnKSB3aXRoIGJvb2xlYW4gZmxhZyB0byBpZ25vcmUgZXJyb3JzLiBVc2Ugc2VuZElnbm9yaW5nRXJyb3IoY29tbWFuZCkuXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoY29tbWFuZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZnRwLnJlcXVlc3QoY29tbWFuZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYW4gRlRQIGNvbW1hbmQgYW5kIGlnbm9yZSBhbiBGVFAgZXJyb3IgcmVzcG9uc2UuIEFueSBvdGhlciBraW5kIG9mIGVycm9yIG9yIHRpbWVvdXQgd2lsbCBzdGlsbCByZWplY3QgdGhlIFByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tbWFuZFxuICAgICAqL1xuICAgIHNlbmRJZ25vcmluZ0Vycm9yKGNvbW1hbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZnRwLmhhbmRsZShjb21tYW5kLCAocmVzLCB0YXNrKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgRnRwQ29udGV4dF8xLkZUUEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGFzay5yZXNvbHZlKHsgY29kZTogcmVzLmNvZGUsIG1lc3NhZ2U6IHJlcy5tZXNzYWdlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0YXNrLnJlamVjdChyZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGFzay5yZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGdyYWRlIHRoZSBjdXJyZW50IHNvY2tldCBjb25uZWN0aW9uIHRvIFRMUy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRpb25zICBUTFMgb3B0aW9ucyBhcyBpbiBgdGxzLmNvbm5lY3Qob3B0aW9ucylgLCBvcHRpb25hbC5cbiAgICAgKiBAcGFyYW0gY29tbWFuZCAgU2V0IHRoZSBhdXRoZW50aWNhdGlvbiBjb21tYW5kLiBPcHRpb25hbCwgZGVmYXVsdCBpcyBcIkFVVEggVExTXCIuXG4gICAgICovXG4gICAgYXN5bmMgdXNlVExTKG9wdGlvbnMgPSB7fSwgY29tbWFuZCA9IFwiQVVUSCBUTFNcIikge1xuICAgICAgICBjb25zdCByZXQgPSBhd2FpdCB0aGlzLnNlbmQoY29tbWFuZCk7XG4gICAgICAgIHRoaXMuZnRwLnNvY2tldCA9IGF3YWl0ICgwLCBuZXRVdGlsc18xLnVwZ3JhZGVTb2NrZXQpKHRoaXMuZnRwLnNvY2tldCwgb3B0aW9ucyk7XG4gICAgICAgIHRoaXMuZnRwLnRsc09wdGlvbnMgPSBvcHRpb25zOyAvLyBLZWVwIHRoZSBUTFMgb3B0aW9ucyBmb3IgbGF0ZXIgZGF0YSBjb25uZWN0aW9ucyB0aGF0IHNob3VsZCB1c2UgdGhlIHNhbWUgb3B0aW9ucy5cbiAgICAgICAgdGhpcy5mdHAubG9nKGBDb250cm9sIHNvY2tldCBpcyB1c2luZzogJHsoMCwgbmV0VXRpbHNfMS5kZXNjcmliZVRMUykodGhpcy5mdHAuc29ja2V0KX1gKTtcbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9naW4gYSB1c2VyIHdpdGggYSBwYXNzd29yZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB1c2VyICBVc2VybmFtZSB0byB1c2UgZm9yIGxvZ2luLiBPcHRpb25hbCwgZGVmYXVsdCBpcyBcImFub255bW91c1wiLlxuICAgICAqIEBwYXJhbSBwYXNzd29yZCAgUGFzc3dvcmQgdG8gdXNlIGZvciBsb2dpbi4gT3B0aW9uYWwsIGRlZmF1bHQgaXMgXCJndWVzdFwiLlxuICAgICAqL1xuICAgIGxvZ2luKHVzZXIgPSBcImFub255bW91c1wiLCBwYXNzd29yZCA9IFwiZ3Vlc3RcIikge1xuICAgICAgICB0aGlzLmZ0cC5sb2coYExvZ2luIHNlY3VyaXR5OiAkeygwLCBuZXRVdGlsc18xLmRlc2NyaWJlVExTKSh0aGlzLmZ0cC5zb2NrZXQpfWApO1xuICAgICAgICByZXR1cm4gdGhpcy5mdHAuaGFuZGxlKFwiVVNFUiBcIiArIHVzZXIsIChyZXMsIHRhc2spID0+IHtcbiAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRhc2sucmVqZWN0KHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgoMCwgcGFyc2VDb250cm9sUmVzcG9uc2VfMS5wb3NpdGl2ZUNvbXBsZXRpb24pKHJlcy5jb2RlKSkgeyAvLyBVc2VyIGxvZ2dlZCBpbiBwcm9jZWVkIE9SIENvbW1hbmQgc3VwZXJmbHVvdXNcbiAgICAgICAgICAgICAgICB0YXNrLnJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlcy5jb2RlID09PSAzMzEpIHsgLy8gVXNlciBuYW1lIG9rYXksIG5lZWQgcGFzc3dvcmRcbiAgICAgICAgICAgICAgICB0aGlzLmZ0cC5zZW5kKFwiUEFTUyBcIiArIHBhc3N3b3JkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgeyAvLyBBbHNvIHJlcG9ydCBlcnJvciBvbiAzMzIgKE5lZWQgYWNjb3VudClcbiAgICAgICAgICAgICAgICB0YXNrLnJlamVjdChuZXcgRnRwQ29udGV4dF8xLkZUUEVycm9yKHJlcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB1c3VhbCBkZWZhdWx0IHNldHRpbmdzLlxuICAgICAqXG4gICAgICogU2V0dGluZ3MgdXNlZDpcbiAgICAgKiAqIEJpbmFyeSBtb2RlIChUWVBFIEkpXG4gICAgICogKiBGaWxlIHN0cnVjdHVyZSAoU1RSVSBGKVxuICAgICAqICogQWRkaXRpb25hbCBzZXR0aW5ncyBmb3IgRlRQUyAoUEJTWiAwLCBQUk9UIFApXG4gICAgICovXG4gICAgYXN5bmMgdXNlRGVmYXVsdFNldHRpbmdzKCkge1xuICAgICAgICBjb25zdCBmZWF0dXJlcyA9IGF3YWl0IHRoaXMuZmVhdHVyZXMoKTtcbiAgICAgICAgLy8gVXNlIE1MU0QgZGlyZWN0b3J5IGxpc3RpbmcgaWYgcG9zc2libGUuIFNlZSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzY1OSNzZWN0aW9uLTcuODpcbiAgICAgICAgLy8gXCJUaGUgcHJlc2VuY2Ugb2YgdGhlIE1MU1QgZmVhdHVyZSBpbmRpY2F0ZXMgdGhhdCBib3RoIE1MU1QgYW5kIE1MU0QgYXJlIHN1cHBvcnRlZC5cIlxuICAgICAgICBjb25zdCBzdXBwb3J0c01MU0QgPSBmZWF0dXJlcy5oYXMoXCJNTFNUXCIpO1xuICAgICAgICB0aGlzLmF2YWlsYWJsZUxpc3RDb21tYW5kcyA9IHN1cHBvcnRzTUxTRCA/IExJU1RfQ09NTUFORFNfTUxTRCgpIDogTElTVF9DT01NQU5EU19ERUZBVUxUKCk7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZChcIlRZUEUgSVwiKTsgLy8gQmluYXJ5IG1vZGVcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kSWdub3JpbmdFcnJvcihcIlNUUlUgRlwiKTsgLy8gVXNlIGZpbGUgc3RydWN0dXJlXG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJPUFRTIFVURjggT05cIik7IC8vIFNvbWUgc2VydmVycyBleHBlY3QgVVRGLTggdG8gYmUgZW5hYmxlZCBleHBsaWNpdGx5IGFuZCBzZXR0aW5nIGJlZm9yZSBsb2dpbiBtaWdodCBub3QgaGF2ZSB3b3JrZWQuXG4gICAgICAgIGlmIChzdXBwb3J0c01MU0QpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJPUFRTIE1MU1QgdHlwZTtzaXplO21vZGlmeTt1bmlxdWU7dW5peC5tb2RlO3VuaXgub3duZXI7dW5peC5ncm91cDt1bml4Lm93bmVybmFtZTt1bml4Lmdyb3VwbmFtZTtcIik7IC8vIE1ha2Ugc3VyZSBNTFNEIGxpc3RpbmdzIGluY2x1ZGUgYWxsIHdlIGNhbiBwYXJzZVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZ0cC5oYXNUTFMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJQQlNaIDBcIik7IC8vIFNldCB0byAwIGZvciBUTFNcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJQUk9UIFBcIik7IC8vIFByb3RlY3QgY2hhbm5lbCAoYWxzbyBmb3IgZGF0YSBjb25uZWN0aW9ucylcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBtZXRob2QgdGhhdCBjYWxscyBgY29ubmVjdGAsIGB1c2VUTFNgLCBgbG9naW5gIGFuZCBgdXNlRGVmYXVsdFNldHRpbmdzYC5cbiAgICAgKlxuICAgICAqIFRoaXMgaXMgYW4gaW5zdGFuY2UgbWV0aG9kIGFuZCB0aHVzIGNhbiBiZSBjYWxsZWQgbXVsdGlwbGUgdGltZXMgZHVyaW5nIHRoZSBsaWZlY3ljbGUgb2YgYSBgQ2xpZW50YFxuICAgICAqIGluc3RhbmNlLiBXaGVuZXZlciB5b3UgZG8sIHRoZSBjbGllbnQgaXMgcmVzZXQgd2l0aCBhIG5ldyBjb250cm9sIGNvbm5lY3Rpb24uIFRoaXMgYWxzbyBpbXBsaWVzIHRoYXRcbiAgICAgKiB5b3UgY2FuIHJlb3BlbiBhIGBDbGllbnRgIGluc3RhbmNlIHRoYXQgaGFzIGJlZW4gY2xvc2VkIGR1ZSB0byBhbiBlcnJvciB3aGVuIHJlY29ubmVjdGluZyB3aXRoIHRoaXNcbiAgICAgKiBtZXRob2QuIEluIGZhY3QsIHJlY29ubmVjdGluZyBpcyB0aGUgb25seSB3YXkgdG8gY29udGludWUgdXNpbmcgYSBjbG9zZWQgYENsaWVudGAuXG4gICAgICovXG4gICAgYXN5bmMgYWNjZXNzKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCB1c2VFeHBsaWNpdFRMUyA9IG9wdGlvbnMuc2VjdXJlID09PSB0cnVlO1xuICAgICAgICBjb25zdCB1c2VJbXBsaWNpdFRMUyA9IG9wdGlvbnMuc2VjdXJlID09PSBcImltcGxpY2l0XCI7XG4gICAgICAgIGxldCB3ZWxjb21lO1xuICAgICAgICBpZiAodXNlSW1wbGljaXRUTFMpIHtcbiAgICAgICAgICAgIHdlbGNvbWUgPSBhd2FpdCB0aGlzLmNvbm5lY3RJbXBsaWNpdFRMUyhvcHRpb25zLmhvc3QsIG9wdGlvbnMucG9ydCwgb3B0aW9ucy5zZWN1cmVPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdlbGNvbWUgPSBhd2FpdCB0aGlzLmNvbm5lY3Qob3B0aW9ucy5ob3N0LCBvcHRpb25zLnBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1c2VFeHBsaWNpdFRMUykge1xuICAgICAgICAgICAgLy8gRml4ZXMgaHR0cHM6Ly9naXRodWIuY29tL3BhdHJpY2tqdWNobGkvYmFzaWMtZnRwL2lzc3Vlcy8xNjYgYnkgbWFraW5nIHN1cmVcbiAgICAgICAgICAgIC8vIGhvc3QgaXMgc2V0IGZvciBhbnkgZnV0dXJlIGRhdGEgY29ubmVjdGlvbiBhcyB3ZWxsLlxuICAgICAgICAgICAgY29uc3Qgc2VjdXJlT3B0aW9ucyA9IChfYSA9IG9wdGlvbnMuc2VjdXJlT3B0aW9ucykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgICAgICAgICBzZWN1cmVPcHRpb25zLmhvc3QgPSAoX2IgPSBzZWN1cmVPcHRpb25zLmhvc3QpICE9PSBudWxsICYmIF9iICE9PSB2b2lkIDAgPyBfYiA6IG9wdGlvbnMuaG9zdDtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMudXNlVExTKHNlY3VyZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNldCBVVEYtOCBvbiBiZWZvcmUgbG9naW4gaW4gY2FzZSB0aGVyZSBhcmUgbm9uLWFzY2lpIGNoYXJhY3RlcnMgaW4gdXNlciBvciBwYXNzd29yZC5cbiAgICAgICAgLy8gTm90ZSB0aGF0IHRoaXMgbWlnaHQgbm90IHdvcmsgYmVmb3JlIGxvZ2luIGRlcGVuZGluZyBvbiBzZXJ2ZXIuXG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJPUFRTIFVURjggT05cIik7XG4gICAgICAgIGF3YWl0IHRoaXMubG9naW4ob3B0aW9ucy51c2VyLCBvcHRpb25zLnBhc3N3b3JkKTtcbiAgICAgICAgYXdhaXQgdGhpcy51c2VEZWZhdWx0U2V0dGluZ3MoKTtcbiAgICAgICAgcmV0dXJuIHdlbGNvbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeS5cbiAgICAgKi9cbiAgICBhc3luYyBwd2QoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IGF3YWl0IHRoaXMuc2VuZChcIlBXRFwiKTtcbiAgICAgICAgLy8gVGhlIGRpcmVjdG9yeSBpcyBwYXJ0IG9mIHRoZSByZXR1cm4gbWVzc2FnZSwgZm9yIGV4YW1wbGU6XG4gICAgICAgIC8vIDI1NyBcIi90aGlzL3RoYXRcIiBpcyBjdXJyZW50IGRpcmVjdG9yeS5cbiAgICAgICAgY29uc3QgcGFyc2VkID0gcmVzLm1lc3NhZ2UubWF0Y2goL1wiKC4rKVwiLyk7XG4gICAgICAgIGlmIChwYXJzZWQgPT09IG51bGwgfHwgcGFyc2VkWzFdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcGFyc2UgcmVzcG9uc2UgdG8gY29tbWFuZCAnUFdEJzogJHtyZXMubWVzc2FnZX1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyc2VkWzFdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYSBkZXNjcmlwdGlvbiBvZiBzdXBwb3J0ZWQgZmVhdHVyZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIHNlbmRzIHRoZSBGRUFUIGNvbW1hbmQgYW5kIHBhcnNlcyB0aGUgcmVzdWx0IGludG8gYSBNYXAgd2hlcmUga2V5cyBjb3JyZXNwb25kIHRvIGF2YWlsYWJsZSBjb21tYW5kc1xuICAgICAqIGFuZCB2YWx1ZXMgaG9sZCBmdXJ0aGVyIGluZm9ybWF0aW9uLiBCZSBhd2FyZSB0aGF0IHlvdXIgRlRQIHNlcnZlcnMgbWlnaHQgbm90IHN1cHBvcnQgdGhpc1xuICAgICAqIGNvbW1hbmQgaW4gd2hpY2ggY2FzZSB0aGlzIG1ldGhvZCB3aWxsIG5vdCB0aHJvdyBhbiBleGNlcHRpb24gYnV0IGp1c3QgcmV0dXJuIGFuIGVtcHR5IE1hcC5cbiAgICAgKi9cbiAgICBhc3luYyBmZWF0dXJlcygpIHtcbiAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgdGhpcy5zZW5kSWdub3JpbmdFcnJvcihcIkZFQVRcIik7XG4gICAgICAgIGNvbnN0IGZlYXR1cmVzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBOb3Qgc3VwcG9ydGluZyBhbnkgc3BlY2lhbCBmZWF0dXJlcyB3aWxsIGJlIHJlcG9ydGVkIHdpdGggYSBzaW5nbGUgbGluZS5cbiAgICAgICAgaWYgKHJlcy5jb2RlIDwgNDAwICYmICgwLCBwYXJzZUNvbnRyb2xSZXNwb25zZV8xLmlzTXVsdGlsaW5lKShyZXMubWVzc2FnZSkpIHtcbiAgICAgICAgICAgIC8vIFRoZSBmaXJzdCBhbmQgbGFzdCBsaW5lIHdyYXAgdGhlIG11bHRpbGluZSByZXNwb25zZSwgaWdub3JlIHRoZW0uXG4gICAgICAgICAgICByZXMubWVzc2FnZS5zcGxpdChcIlxcblwiKS5zbGljZSgxLCAtMSkuZm9yRWFjaChsaW5lID0+IHtcbiAgICAgICAgICAgICAgICAvLyBBIHR5cGljYWwgbGluZXMgbG9va3MgbGlrZTogXCIgUkVTVCBTVFJFQU1cIiBvciBcIiBNRFRNXCIuXG4gICAgICAgICAgICAgICAgLy8gU2VydmVycyBtaWdodCBub3QgdXNlIGFuIGluZGVudGF0aW9uIHRob3VnaC5cbiAgICAgICAgICAgICAgICBjb25zdCBlbnRyeSA9IGxpbmUudHJpbSgpLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgICBmZWF0dXJlcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdIHx8IFwiXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZlYXR1cmVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHdvcmtpbmcgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIGFzeW5jIGNkKHBhdGgpIHtcbiAgICAgICAgY29uc3QgdmFsaWRQYXRoID0gYXdhaXQgdGhpcy5wcm90ZWN0V2hpdGVzcGFjZShwYXRoKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChcIkNXRCBcIiArIHZhbGlkUGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFN3aXRjaCB0byB0aGUgcGFyZW50IGRpcmVjdG9yeSBvZiB0aGUgd29ya2luZyBkaXJlY3RvcnkuXG4gICAgICovXG4gICAgYXN5bmMgY2R1cCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChcIkNEVVBcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgbGFzdCBtb2RpZmllZCB0aW1lIG9mIGEgZmlsZS4gVGhpcyBpcyBub3Qgc3VwcG9ydGVkIGJ5IGV2ZXJ5IEZUUCBzZXJ2ZXIsIGluIHdoaWNoIGNhc2VcbiAgICAgKiBjYWxsaW5nIHRoaXMgbWV0aG9kIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uLlxuICAgICAqL1xuICAgIGFzeW5jIGxhc3RNb2QocGF0aCkge1xuICAgICAgICBjb25zdCB2YWxpZFBhdGggPSBhd2FpdCB0aGlzLnByb3RlY3RXaGl0ZXNwYWNlKHBhdGgpO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnNlbmQoYE1EVE0gJHt2YWxpZFBhdGh9YCk7XG4gICAgICAgIGNvbnN0IGRhdGUgPSByZXMubWVzc2FnZS5zbGljZSg0KTtcbiAgICAgICAgcmV0dXJuICgwLCBwYXJzZUxpc3RNTFNEXzEucGFyc2VNTFN4RGF0ZSkoZGF0ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgc2l6ZSBvZiBhIGZpbGUuXG4gICAgICovXG4gICAgYXN5bmMgc2l6ZShwYXRoKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkUGF0aCA9IGF3YWl0IHRoaXMucHJvdGVjdFdoaXRlc3BhY2UocGF0aCk7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSBgU0laRSAke3ZhbGlkUGF0aH1gO1xuICAgICAgICBjb25zdCByZXMgPSBhd2FpdCB0aGlzLnNlbmQoY29tbWFuZCk7XG4gICAgICAgIC8vIFRoZSBzaXplIGlzIHBhcnQgb2YgdGhlIHJlc3BvbnNlIG1lc3NhZ2UsIGZvciBleGFtcGxlOiBcIjIxMyA1NTU1NTVcIi4gSXQnc1xuICAgICAgICAvLyBwb3NzaWJsZSB0aGF0IHRoZXJlIGlzIGEgY29tbW1lbnRhcnkgYXBwZW5kZWQgbGlrZSBcIjIxMyA1NTU1LCBzb21lIGNvbW1lbnRhcnlcIi5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KHJlcy5tZXNzYWdlLnNsaWNlKDQpLCAxMCk7XG4gICAgICAgIGlmIChOdW1iZXIuaXNOYU4oc2l6ZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcGFyc2UgcmVzcG9uc2UgdG8gY29tbWFuZCAnJHtjb21tYW5kfScgYXMgYSBudW1lcmljYWwgdmFsdWU6ICR7cmVzLm1lc3NhZ2V9YCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbmFtZSBhIGZpbGUuXG4gICAgICpcbiAgICAgKiBEZXBlbmRpbmcgb24gdGhlIEZUUCBzZXJ2ZXIgdGhpcyBtaWdodCBhbHNvIGJlIHVzZWQgdG8gbW92ZSBhIGZpbGUgZnJvbSBvbmVcbiAgICAgKiBkaXJlY3RvcnkgdG8gYW5vdGhlciBieSBwcm92aWRpbmcgZnVsbCBwYXRocy5cbiAgICAgKi9cbiAgICBhc3luYyByZW5hbWUoc3JjUGF0aCwgZGVzdFBhdGgpIHtcbiAgICAgICAgY29uc3QgdmFsaWRTcmMgPSBhd2FpdCB0aGlzLnByb3RlY3RXaGl0ZXNwYWNlKHNyY1BhdGgpO1xuICAgICAgICBjb25zdCB2YWxpZERlc3QgPSBhd2FpdCB0aGlzLnByb3RlY3RXaGl0ZXNwYWNlKGRlc3RQYXRoKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zZW5kKFwiUk5GUiBcIiArIHZhbGlkU3JjKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZChcIlJOVE8gXCIgKyB2YWxpZERlc3QpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBmaWxlIGZyb20gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIGlnbm9yZSBGVFAgZXJyb3IgcmV0dXJuIGNvZGVzIHdoaWNoIHdvbid0IHRocm93IGFuIGV4Y2VwdGlvbiBpZiBlLmcuXG4gICAgICogdGhlIGZpbGUgZG9lc24ndCBleGlzdC5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmUocGF0aCwgaWdub3JlRXJyb3JDb2RlcyA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkUGF0aCA9IGF3YWl0IHRoaXMucHJvdGVjdFdoaXRlc3BhY2UocGF0aCk7XG4gICAgICAgIGlmIChpZ25vcmVFcnJvckNvZGVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kSWdub3JpbmdFcnJvcihgREVMRSAke3ZhbGlkUGF0aH1gKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKGBERUxFICR7dmFsaWRQYXRofWApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBvcnQgdHJhbnNmZXIgcHJvZ3Jlc3MgZm9yIGFueSB1cGxvYWQgb3IgZG93bmxvYWQgdG8gYSBnaXZlbiBoYW5kbGVyLlxuICAgICAqXG4gICAgICogVGhpcyB3aWxsIGFsc28gcmVzZXQgdGhlIG92ZXJhbGwgdHJhbnNmZXIgY291bnRlciB0aGF0IGNhbiBiZSB1c2VkIGZvciBtdWx0aXBsZSB0cmFuc2ZlcnMuIFlvdSBjYW5cbiAgICAgKiBhbHNvIGNhbGwgdGhlIGZ1bmN0aW9uIHdpdGhvdXQgYSBoYW5kbGVyIHRvIHN0b3AgcmVwb3J0aW5nIHRvIGFuIGVhcmxpZXIgb25lLlxuICAgICAqXG4gICAgICogQHBhcmFtIGhhbmRsZXIgIEhhbmRsZXIgZnVuY3Rpb24gdG8gY2FsbCBvbiB0cmFuc2ZlciBwcm9ncmVzcy5cbiAgICAgKi9cbiAgICB0cmFja1Byb2dyZXNzKGhhbmRsZXIpIHtcbiAgICAgICAgdGhpcy5fcHJvZ3Jlc3NUcmFja2VyLmJ5dGVzT3ZlcmFsbCA9IDA7XG4gICAgICAgIHRoaXMuX3Byb2dyZXNzVHJhY2tlci5yZXBvcnRUbyhoYW5kbGVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBsb2FkIGRhdGEgZnJvbSBhIHJlYWRhYmxlIHN0cmVhbSBvciBhIGxvY2FsIGZpbGUgdG8gYSByZW1vdGUgZmlsZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb3VyY2UgIFJlYWRhYmxlIHN0cmVhbSBvciBwYXRoIHRvIGEgbG9jYWwgZmlsZS5cbiAgICAgKiBAcGFyYW0gdG9SZW1vdGVQYXRoICBQYXRoIHRvIGEgcmVtb3RlIGZpbGUgdG8gd3JpdGUgdG8uXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkRnJvbShzb3VyY2UsIHRvUmVtb3RlUGF0aCwgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLl91cGxvYWRXaXRoQ29tbWFuZChzb3VyY2UsIHRvUmVtb3RlUGF0aCwgXCJTVE9SXCIsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGxvYWQgZGF0YSBmcm9tIGEgcmVhZGFibGUgc3RyZWFtIG9yIGEgbG9jYWwgZmlsZSBieSBhcHBlbmRpbmcgaXQgdG8gYW4gZXhpc3RpbmcgZmlsZS4gSWYgdGhlIGZpbGUgZG9lc24ndFxuICAgICAqIGV4aXN0IHRoZSBGVFAgc2VydmVyIHNob3VsZCBjcmVhdGUgaXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc291cmNlICBSZWFkYWJsZSBzdHJlYW0gb3IgcGF0aCB0byBhIGxvY2FsIGZpbGUuXG4gICAgICogQHBhcmFtIHRvUmVtb3RlUGF0aCAgUGF0aCB0byBhIHJlbW90ZSBmaWxlIHRvIHdyaXRlIHRvLlxuICAgICAqL1xuICAgIGFzeW5jIGFwcGVuZEZyb20oc291cmNlLCB0b1JlbW90ZVBhdGgsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdXBsb2FkV2l0aENvbW1hbmQoc291cmNlLCB0b1JlbW90ZVBhdGgsIFwiQVBQRVwiLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIF91cGxvYWRXaXRoQ29tbWFuZChzb3VyY2UsIHJlbW90ZVBhdGgsIGNvbW1hbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBzb3VyY2UgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl91cGxvYWRMb2NhbEZpbGUoc291cmNlLCByZW1vdGVQYXRoLCBjb21tYW5kLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fdXBsb2FkRnJvbVN0cmVhbShzb3VyY2UsIHJlbW90ZVBhdGgsIGNvbW1hbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgX3VwbG9hZExvY2FsRmlsZShsb2NhbFBhdGgsIHJlbW90ZVBhdGgsIGNvbW1hbmQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgZmQgPSBhd2FpdCBmc09wZW4obG9jYWxQYXRoLCBcInJcIik7XG4gICAgICAgIGNvbnN0IHNvdXJjZSA9ICgwLCBmc18xLmNyZWF0ZVJlYWRTdHJlYW0pKFwiXCIsIHtcbiAgICAgICAgICAgIGZkLFxuICAgICAgICAgICAgc3RhcnQ6IG9wdGlvbnMubG9jYWxTdGFydCxcbiAgICAgICAgICAgIGVuZDogb3B0aW9ucy5sb2NhbEVuZEluY2x1c2l2ZSxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fdXBsb2FkRnJvbVN0cmVhbShzb3VyY2UsIHJlbW90ZVBhdGgsIGNvbW1hbmQpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgYXdhaXQgaWdub3JlRXJyb3IoKCkgPT4gZnNDbG9zZShmZCkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBfdXBsb2FkRnJvbVN0cmVhbShzb3VyY2UsIHJlbW90ZVBhdGgsIGNvbW1hbmQpIHtcbiAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHRoaXMuZnRwLmNsb3NlV2l0aEVycm9yKGVycik7XG4gICAgICAgIHNvdXJjZS5vbmNlKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCB2YWxpZFBhdGggPSBhd2FpdCB0aGlzLnByb3RlY3RXaGl0ZXNwYWNlKHJlbW90ZVBhdGgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wcmVwYXJlVHJhbnNmZXIodGhpcy5mdHApO1xuICAgICAgICAgICAgLy8gS2VlcCB0aGUga2V5d29yZCBgYXdhaXRgIG9yIHRoZSBgZmluYWxseWAgY2xhdXNlIGJlbG93IHJ1bnMgdG9vIGVhcmx5XG4gICAgICAgICAgICAvLyBhbmQgcmVtb3ZlcyB0aGUgZXZlbnQgbGlzdGVuZXIgZm9yIHRoZSBzb3VyY2Ugc3RyZWFtIHRvbyBlYXJseS5cbiAgICAgICAgICAgIHJldHVybiBhd2FpdCAoMCwgdHJhbnNmZXJfMS51cGxvYWRGcm9tKShzb3VyY2UsIHtcbiAgICAgICAgICAgICAgICBmdHA6IHRoaXMuZnRwLFxuICAgICAgICAgICAgICAgIHRyYWNrZXI6IHRoaXMuX3Byb2dyZXNzVHJhY2tlcixcbiAgICAgICAgICAgICAgICBjb21tYW5kLFxuICAgICAgICAgICAgICAgIHJlbW90ZVBhdGg6IHZhbGlkUGF0aCxcbiAgICAgICAgICAgICAgICB0eXBlOiBcInVwbG9hZFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERvd25sb2FkIGEgcmVtb3RlIGZpbGUgYW5kIHBpcGUgaXRzIGRhdGEgdG8gYSB3cml0YWJsZSBzdHJlYW0gb3IgdG8gYSBsb2NhbCBmaWxlLlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcHRpb25hbGx5IGRlZmluZSBhdCB3aGljaCBwb3NpdGlvbiBvZiB0aGUgcmVtb3RlIGZpbGUgeW91J2QgbGlrZSB0byBzdGFydFxuICAgICAqIGRvd25sb2FkaW5nLiBJZiB0aGUgZGVzdGluYXRpb24geW91IHByb3ZpZGUgaXMgYSBmaWxlLCB0aGUgb2Zmc2V0IHdpbGwgYmUgYXBwbGllZFxuICAgICAqIHRvIGl0IGFzIHdlbGwuIEZvciBleGFtcGxlOiBUbyByZXN1bWUgYSBmYWlsZWQgZG93bmxvYWQsIHlvdSdkIHJlcXVlc3QgdGhlIHNpemUgb2ZcbiAgICAgKiB0aGUgbG9jYWwsIHBhcnRpYWxseSBkb3dubG9hZGVkIGZpbGUgYW5kIHVzZSB0aGF0IGFzIHRoZSBvZmZzZXQuIEFzc3VtaW5nIHRoZSBzaXplXG4gICAgICogaXMgMjMsIHlvdSdkIGRvd25sb2FkIHRoZSByZXN0IHVzaW5nIGBkb3dubG9hZFRvKFwibG9jYWwudHh0XCIsIFwicmVtb3RlLnR4dFwiLCAyMylgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGRlc3RpbmF0aW9uICBTdHJlYW0gb3IgcGF0aCBmb3IgYSBsb2NhbCBmaWxlIHRvIHdyaXRlIHRvLlxuICAgICAqIEBwYXJhbSBmcm9tUmVtb3RlUGF0aCAgUGF0aCBvZiB0aGUgcmVtb3RlIGZpbGUgdG8gcmVhZCBmcm9tLlxuICAgICAqIEBwYXJhbSBzdGFydEF0ICBQb3NpdGlvbiB3aXRoaW4gdGhlIHJlbW90ZSBmaWxlIHRvIHN0YXJ0IGRvd25sb2FkaW5nIGF0LiBJZiB0aGUgZGVzdGluYXRpb24gaXMgYSBmaWxlLCB0aGlzIG9mZnNldCBpcyBhbHNvIGFwcGxpZWQgdG8gaXQuXG4gICAgICovXG4gICAgYXN5bmMgZG93bmxvYWRUbyhkZXN0aW5hdGlvbiwgZnJvbVJlbW90ZVBhdGgsIHN0YXJ0QXQgPSAwKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZGVzdGluYXRpb24gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9kb3dubG9hZFRvRmlsZShkZXN0aW5hdGlvbiwgZnJvbVJlbW90ZVBhdGgsIHN0YXJ0QXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9kb3dubG9hZFRvU3RyZWFtKGRlc3RpbmF0aW9uLCBmcm9tUmVtb3RlUGF0aCwgc3RhcnRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBfZG93bmxvYWRUb0ZpbGUobG9jYWxQYXRoLCByZW1vdGVQYXRoLCBzdGFydEF0KSB7XG4gICAgICAgIGNvbnN0IGFwcGVuZGluZ1RvTG9jYWxGaWxlID0gc3RhcnRBdCA+IDA7XG4gICAgICAgIGNvbnN0IGZpbGVTeXN0ZW1GbGFncyA9IGFwcGVuZGluZ1RvTG9jYWxGaWxlID8gXCJyK1wiIDogXCJ3XCI7XG4gICAgICAgIGNvbnN0IGZkID0gYXdhaXQgZnNPcGVuKGxvY2FsUGF0aCwgZmlsZVN5c3RlbUZsYWdzKTtcbiAgICAgICAgY29uc3QgZGVzdGluYXRpb24gPSAoMCwgZnNfMS5jcmVhdGVXcml0ZVN0cmVhbSkoXCJcIiwge1xuICAgICAgICAgICAgZmQsXG4gICAgICAgICAgICBzdGFydDogc3RhcnRBdCxcbiAgICAgICAgICAgIGF1dG9DbG9zZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZG93bmxvYWRUb1N0cmVhbShkZXN0aW5hdGlvbiwgcmVtb3RlUGF0aCwgc3RhcnRBdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgY29uc3QgbG9jYWxGaWxlU3RhdHMgPSBhd2FpdCBpZ25vcmVFcnJvcigoKSA9PiBmc1N0YXQobG9jYWxQYXRoKSk7XG4gICAgICAgICAgICBjb25zdCBoYXNEb3dubG9hZGVkRGF0YSA9IGxvY2FsRmlsZVN0YXRzICYmIGxvY2FsRmlsZVN0YXRzLnNpemUgPiAwO1xuICAgICAgICAgICAgY29uc3Qgc2hvdWxkUmVtb3ZlTG9jYWxGaWxlID0gIWFwcGVuZGluZ1RvTG9jYWxGaWxlICYmICFoYXNEb3dubG9hZGVkRGF0YTtcbiAgICAgICAgICAgIGlmIChzaG91bGRSZW1vdmVMb2NhbEZpbGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBpZ25vcmVFcnJvcigoKSA9PiBmc1VubGluayhsb2NhbFBhdGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGF3YWl0IGlnbm9yZUVycm9yKCgpID0+IGZzQ2xvc2UoZmQpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgX2Rvd25sb2FkVG9TdHJlYW0oZGVzdGluYXRpb24sIHJlbW90ZVBhdGgsIHN0YXJ0QXQpIHtcbiAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHRoaXMuZnRwLmNsb3NlV2l0aEVycm9yKGVycik7XG4gICAgICAgIGRlc3RpbmF0aW9uLm9uY2UoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkUGF0aCA9IGF3YWl0IHRoaXMucHJvdGVjdFdoaXRlc3BhY2UocmVtb3RlUGF0aCk7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByZXBhcmVUcmFuc2Zlcih0aGlzLmZ0cCk7XG4gICAgICAgICAgICAvLyBLZWVwIHRoZSBrZXl3b3JkIGBhd2FpdGAgb3IgdGhlIGBmaW5hbGx5YCBjbGF1c2UgYmVsb3cgcnVucyB0b28gZWFybHlcbiAgICAgICAgICAgIC8vIGFuZCByZW1vdmVzIHRoZSBldmVudCBsaXN0ZW5lciBmb3IgdGhlIHNvdXJjZSBzdHJlYW0gdG9vIGVhcmx5LlxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0ICgwLCB0cmFuc2Zlcl8xLmRvd25sb2FkVG8pKGRlc3RpbmF0aW9uLCB7XG4gICAgICAgICAgICAgICAgZnRwOiB0aGlzLmZ0cCxcbiAgICAgICAgICAgICAgICB0cmFja2VyOiB0aGlzLl9wcm9ncmVzc1RyYWNrZXIsXG4gICAgICAgICAgICAgICAgY29tbWFuZDogc3RhcnRBdCA+IDAgPyBgUkVTVCAke3N0YXJ0QXR9YCA6IGBSRVRSICR7dmFsaWRQYXRofWAsXG4gICAgICAgICAgICAgICAgcmVtb3RlUGF0aDogdmFsaWRQYXRoLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiZG93bmxvYWRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICBkZXN0aW5hdGlvbi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICAgICAgZGVzdGluYXRpb24uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBmaWxlcyBhbmQgZGlyZWN0b3JpZXMgaW4gdGhlIGN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnksIG9yIGZyb20gYHBhdGhgIGlmIHNwZWNpZmllZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbcGF0aF0gIFBhdGggdG8gcmVtb3RlIGZpbGUgb3IgZGlyZWN0b3J5LlxuICAgICAqL1xuICAgIGFzeW5jIGxpc3QocGF0aCA9IFwiXCIpIHtcbiAgICAgICAgY29uc3QgdmFsaWRQYXRoID0gYXdhaXQgdGhpcy5wcm90ZWN0V2hpdGVzcGFjZShwYXRoKTtcbiAgICAgICAgbGV0IGxhc3RFcnJvcjtcbiAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgdGhpcy5hdmFpbGFibGVMaXN0Q29tbWFuZHMpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbW1hbmQgPSB2YWxpZFBhdGggPT09IFwiXCIgPyBjYW5kaWRhdGUgOiBgJHtjYW5kaWRhdGV9ICR7dmFsaWRQYXRofWA7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnByZXBhcmVUcmFuc2Zlcih0aGlzLmZ0cCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZExpc3QgPSBhd2FpdCB0aGlzLl9yZXF1ZXN0TGlzdFdpdGhDb21tYW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgICAgIC8vIFVzZSBzdWNjZXNzZnVsIGNhbmRpZGF0ZSBmb3IgYWxsIHN1YnNlcXVlbnQgcmVxdWVzdHMuXG4gICAgICAgICAgICAgICAgdGhpcy5hdmFpbGFibGVMaXN0Q29tbWFuZHMgPSBbY2FuZGlkYXRlXTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyc2VkTGlzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRUcnlOZXh0ID0gZXJyIGluc3RhbmNlb2YgRnRwQ29udGV4dF8xLkZUUEVycm9yO1xuICAgICAgICAgICAgICAgIGlmICghc2hvdWxkVHJ5TmV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBsYXN0RXJyb3I7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBfcmVxdWVzdExpc3RXaXRoQ29tbWFuZChjb21tYW5kKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBTdHJpbmdXcml0ZXJfMS5TdHJpbmdXcml0ZXIoKTtcbiAgICAgICAgYXdhaXQgKDAsIHRyYW5zZmVyXzEuZG93bmxvYWRUbykoYnVmZmVyLCB7XG4gICAgICAgICAgICBmdHA6IHRoaXMuZnRwLFxuICAgICAgICAgICAgdHJhY2tlcjogdGhpcy5fcHJvZ3Jlc3NUcmFja2VyLFxuICAgICAgICAgICAgY29tbWFuZCxcbiAgICAgICAgICAgIHJlbW90ZVBhdGg6IFwiXCIsXG4gICAgICAgICAgICB0eXBlOiBcImxpc3RcIlxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdGV4dCA9IGJ1ZmZlci5nZXRUZXh0KHRoaXMuZnRwLmVuY29kaW5nKTtcbiAgICAgICAgdGhpcy5mdHAubG9nKHRleHQpO1xuICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUxpc3QodGV4dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhIGRpcmVjdG9yeSBhbmQgYWxsIG9mIGl0cyBjb250ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlbW90ZURpclBhdGggIFRoZSBwYXRoIG9mIHRoZSByZW1vdGUgZGlyZWN0b3J5IHRvIGRlbGV0ZS5cbiAgICAgKiBAZXhhbXBsZSBjbGllbnQucmVtb3ZlRGlyKFwiZm9vXCIpIC8vIFJlbW92ZSBkaXJlY3RvcnkgJ2ZvbycgdXNpbmcgYSByZWxhdGl2ZSBwYXRoLlxuICAgICAqIEBleGFtcGxlIGNsaWVudC5yZW1vdmVEaXIoXCJmb28vYmFyXCIpIC8vIFJlbW92ZSBkaXJlY3RvcnkgJ2JhcicgdXNpbmcgYSByZWxhdGl2ZSBwYXRoLlxuICAgICAqIEBleGFtcGxlIGNsaWVudC5yZW1vdmVEaXIoXCIvZm9vL2JhclwiKSAvLyBSZW1vdmUgZGlyZWN0b3J5ICdiYXInIHVzaW5nIGFuIGFic29sdXRlIHBhdGguXG4gICAgICogQGV4YW1wbGUgY2xpZW50LnJlbW92ZURpcihcIi9cIikgLy8gUmVtb3ZlIGV2ZXJ5dGhpbmcuXG4gICAgICovXG4gICAgYXN5bmMgcmVtb3ZlRGlyKHJlbW90ZURpclBhdGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2V4aXRBdEN1cnJlbnREaXJlY3RvcnkoYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jZChyZW1vdGVEaXJQYXRoKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgYWJzb2x1dGUgcGF0aCBvZiB0aGUgdGFyZ2V0IGJlY2F1c2UgcmVtb3RlRGlyUGF0aCBtaWdodCBiZSBhIHJlbGF0aXZlIHBhdGgsIGV2ZW4gYC4uL2AgaXMgcG9zc2libGUuXG4gICAgICAgICAgICBjb25zdCBhYnNvbHV0ZURpclBhdGggPSBhd2FpdCB0aGlzLnB3ZCgpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhcldvcmtpbmdEaXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGRpcklzUm9vdCA9IGFic29sdXRlRGlyUGF0aCA9PT0gXCIvXCI7XG4gICAgICAgICAgICBpZiAoIWRpcklzUm9vdCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2R1cCgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucmVtb3ZlRW1wdHlEaXIoYWJzb2x1dGVEaXJQYXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBhbGwgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIGluIHRoZSB3b3JraW5nIGRpcmVjdG9yeSB3aXRob3V0IHJlbW92aW5nXG4gICAgICogdGhlIHdvcmtpbmcgZGlyZWN0b3J5IGl0c2VsZi5cbiAgICAgKi9cbiAgICBhc3luYyBjbGVhcldvcmtpbmdEaXIoKSB7XG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBhd2FpdCB0aGlzLmxpc3QoKSkge1xuICAgICAgICAgICAgaWYgKGZpbGUuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNkKGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5jbGVhcldvcmtpbmdEaXIoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNkdXAoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZUVtcHR5RGlyKGZpbGUubmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnJlbW92ZShmaWxlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwbG9hZCB0aGUgY29udGVudHMgb2YgYSBsb2NhbCBkaXJlY3RvcnkgdG8gdGhlIHJlbW90ZSB3b3JraW5nIGRpcmVjdG9yeS5cbiAgICAgKlxuICAgICAqIFRoaXMgd2lsbCBvdmVyd3JpdGUgZXhpc3RpbmcgZmlsZXMgd2l0aCB0aGUgc2FtZSBuYW1lcyBhbmQgcmV1c2UgZXhpc3RpbmcgZGlyZWN0b3JpZXMuXG4gICAgICogVW5yZWxhdGVkIGZpbGVzIGFuZCBkaXJlY3RvcmllcyB3aWxsIHJlbWFpbiB1bnRvdWNoZWQuIFlvdSBjYW4gb3B0aW9uYWxseSBwcm92aWRlIGEgYHJlbW90ZURpclBhdGhgXG4gICAgICogdG8gcHV0IHRoZSBjb250ZW50cyBpbnNpZGUgYSBkaXJlY3Rvcnkgd2hpY2ggd2lsbCBiZSBjcmVhdGVkIGlmIG5lY2Vzc2FyeSBpbmNsdWRpbmcgYWxsXG4gICAgICogaW50ZXJtZWRpYXRlIGRpcmVjdG9yaWVzLiBJZiB5b3UgZGlkIHByb3ZpZGUgYSByZW1vdGVEaXJQYXRoIHRoZSB3b3JraW5nIGRpcmVjdG9yeSB3aWxsIHN0YXlcbiAgICAgKiB0aGUgc2FtZSBhcyBiZWZvcmUgY2FsbGluZyB0aGlzIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbERpclBhdGggIExvY2FsIHBhdGgsIGUuZy4gXCJmb28vYmFyXCIgb3IgXCIuLi90ZXN0XCJcbiAgICAgKiBAcGFyYW0gW3JlbW90ZURpclBhdGhdICBSZW1vdGUgcGF0aCBvZiBhIGRpcmVjdG9yeSB0byB1cGxvYWQgdG8uIFdvcmtpbmcgZGlyZWN0b3J5IGlmIHVuZGVmaW5lZC5cbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWRGcm9tRGlyKGxvY2FsRGlyUGF0aCwgcmVtb3RlRGlyUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhpdEF0Q3VycmVudERpcmVjdG9yeShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVtb3RlRGlyUGF0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuZW5zdXJlRGlyKHJlbW90ZURpclBhdGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF3YWl0IHRoaXMuX3VwbG9hZFRvV29ya2luZ0Rpcihsb2NhbERpclBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIF91cGxvYWRUb1dvcmtpbmdEaXIobG9jYWxEaXJQYXRoKSB7XG4gICAgICAgIGNvbnN0IGZpbGVzID0gYXdhaXQgZnNSZWFkRGlyKGxvY2FsRGlyUGF0aCk7XG4gICAgICAgIGZvciAoY29uc3QgZmlsZSBvZiBmaWxlcykge1xuICAgICAgICAgICAgY29uc3QgZnVsbFBhdGggPSAoMCwgcGF0aF8xLmpvaW4pKGxvY2FsRGlyUGF0aCwgZmlsZSk7XG4gICAgICAgICAgICBjb25zdCBzdGF0cyA9IGF3YWl0IGZzU3RhdChmdWxsUGF0aCk7XG4gICAgICAgICAgICBpZiAoc3RhdHMuaXNGaWxlKCkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnVwbG9hZEZyb20oZnVsbFBhdGgsIGZpbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoc3RhdHMuaXNEaXJlY3RvcnkoKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX29wZW5EaXIoZmlsZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fdXBsb2FkVG9Xb3JraW5nRGlyKGZ1bGxQYXRoKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNkdXAoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEb3dubG9hZCBhbGwgZmlsZXMgYW5kIGRpcmVjdG9yaWVzIG9mIHRoZSB3b3JraW5nIGRpcmVjdG9yeSB0byBhIGxvY2FsIGRpcmVjdG9yeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsb2NhbERpclBhdGggIFRoZSBsb2NhbCBkaXJlY3RvcnkgdG8gZG93bmxvYWQgdG8uXG4gICAgICogQHBhcmFtIHJlbW90ZURpclBhdGggIFJlbW90ZSBkaXJlY3RvcnkgdG8gZG93bmxvYWQuIEN1cnJlbnQgd29ya2luZyBkaXJlY3RvcnkgaWYgbm90IHNwZWNpZmllZC5cbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZFRvRGlyKGxvY2FsRGlyUGF0aCwgcmVtb3RlRGlyUGF0aCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZXhpdEF0Q3VycmVudERpcmVjdG9yeShhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBpZiAocmVtb3RlRGlyUGF0aCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2QocmVtb3RlRGlyUGF0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5fZG93bmxvYWRGcm9tV29ya2luZ0Rpcihsb2NhbERpclBhdGgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIF9kb3dubG9hZEZyb21Xb3JraW5nRGlyKGxvY2FsRGlyUGF0aCkge1xuICAgICAgICBhd2FpdCBlbnN1cmVMb2NhbERpcmVjdG9yeShsb2NhbERpclBhdGgpO1xuICAgICAgICBmb3IgKGNvbnN0IGZpbGUgb2YgYXdhaXQgdGhpcy5saXN0KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsUGF0aCA9ICgwLCBwYXRoXzEuam9pbikobG9jYWxEaXJQYXRoLCBmaWxlLm5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpbGUuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmNkKGZpbGUubmFtZSk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fZG93bmxvYWRGcm9tV29ya2luZ0Rpcihsb2NhbFBhdGgpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuY2R1cCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoZmlsZS5pc0ZpbGUpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmRvd25sb2FkVG8obG9jYWxQYXRoLCBmaWxlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2Ugc3VyZSBhIGdpdmVuIHJlbW90ZSBwYXRoIGV4aXN0cywgY3JlYXRpbmcgYWxsIGRpcmVjdG9yaWVzIGFzIG5lY2Vzc2FyeS5cbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGFsc28gY2hhbmdlcyB0aGUgY3VycmVudCB3b3JraW5nIGRpcmVjdG9yeSB0byB0aGUgZ2l2ZW4gcGF0aC5cbiAgICAgKi9cbiAgICBhc3luYyBlbnN1cmVEaXIocmVtb3RlRGlyUGF0aCkge1xuICAgICAgICAvLyBJZiB0aGUgcmVtb3RlRGlyUGF0aCB3YXMgYWJzb2x1dGUgZ28gdG8gcm9vdCBkaXJlY3RvcnkuXG4gICAgICAgIGlmIChyZW1vdGVEaXJQYXRoLnN0YXJ0c1dpdGgoXCIvXCIpKSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLmNkKFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuYW1lcyA9IHJlbW90ZURpclBhdGguc3BsaXQoXCIvXCIpLmZpbHRlcihuYW1lID0+IG5hbWUgIT09IFwiXCIpO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX29wZW5EaXIobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJ5IHRvIGNyZWF0ZSBhIGRpcmVjdG9yeSBhbmQgZW50ZXIgaXQuIFRoaXMgd2lsbCBub3QgcmFpc2UgYW4gZXhjZXB0aW9uIGlmIHRoZSBkaXJlY3RvcnlcbiAgICAgKiBjb3VsZG4ndCBiZSBjcmVhdGVkIGlmIGZvciBleGFtcGxlIGl0IGFscmVhZHkgZXhpc3RzLlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBfb3BlbkRpcihkaXJOYW1lKSB7XG4gICAgICAgIGF3YWl0IHRoaXMuc2VuZElnbm9yaW5nRXJyb3IoXCJNS0QgXCIgKyBkaXJOYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy5jZChkaXJOYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlIGFuIGVtcHR5IGRpcmVjdG9yeSwgd2lsbCBmYWlsIGlmIG5vdCBlbXB0eS5cbiAgICAgKi9cbiAgICBhc3luYyByZW1vdmVFbXB0eURpcihwYXRoKSB7XG4gICAgICAgIGNvbnN0IHZhbGlkUGF0aCA9IGF3YWl0IHRoaXMucHJvdGVjdFdoaXRlc3BhY2UocGF0aCk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbmQoYFJNRCAke3ZhbGlkUGF0aH1gKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRlRQIHNlcnZlcnMgY2FuJ3QgaGFuZGxlIGZpbGVuYW1lcyB0aGF0IGhhdmUgbGVhZGluZyB3aGl0ZXNwYWNlLiBUaGlzIG1ldGhvZCB0cmFuc2Zvcm1zXG4gICAgICogYSBnaXZlbiBwYXRoIHRvIGZpeCB0aGF0IGlzc3VlIGZvciBtb3N0IGNhc2VzLlxuICAgICAqL1xuICAgIGFzeW5jIHByb3RlY3RXaGl0ZXNwYWNlKHBhdGgpIHtcbiAgICAgICAgaWYgKCFwYXRoLnN0YXJ0c1dpdGgoXCIgXCIpKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aDtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgbGVhZGluZyB3aGl0ZXNwYWNlIGJ5IHByZXBlbmRpbmcgdGhlIGFic29sdXRlIHBhdGg6XG4gICAgICAgIC8vIFwiIHRlc3QudHh0XCIgd2hpbGUgYmVpbmcgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IGJlY29tZXMgXCIvIHRlc3QudHh0XCIuXG4gICAgICAgIGNvbnN0IHB3ZCA9IGF3YWl0IHRoaXMucHdkKCk7XG4gICAgICAgIGNvbnN0IGFic29sdXRlUGF0aFByZWZpeCA9IHB3ZC5lbmRzV2l0aChcIi9cIikgPyBwd2QgOiBwd2QgKyBcIi9cIjtcbiAgICAgICAgcmV0dXJuIGFic29sdXRlUGF0aFByZWZpeCArIHBhdGg7XG4gICAgfVxuICAgIGFzeW5jIF9leGl0QXRDdXJyZW50RGlyZWN0b3J5KGZ1bmMpIHtcbiAgICAgICAgY29uc3QgdXNlckRpciA9IGF3YWl0IHRoaXMucHdkKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gYXdhaXQgZnVuYygpO1xuICAgICAgICB9XG4gICAgICAgIGZpbmFsbHkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNsb3NlZCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IGlnbm9yZUVycm9yKCgpID0+IHRoaXMuY2QodXNlckRpcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyeSBhbGwgYXZhaWxhYmxlIHRyYW5zZmVyIHN0cmF0ZWdpZXMgYW5kIHBpY2sgdGhlIGZpcnN0IG9uZSB0aGF0IHdvcmtzLiBVcGRhdGUgYGNsaWVudGAgdG9cbiAgICAgKiB1c2UgdGhlIHdvcmtpbmcgc3RyYXRlZ3kgZm9yIGFsbCBzdWNjZXNzaXZlIHRyYW5zZmVyIHJlcXVlc3RzLlxuICAgICAqXG4gICAgICogQHJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgdHJ5IHRoZSBwcm92aWRlZCBzdHJhdGVnaWVzLlxuICAgICAqL1xuICAgIF9lbnRlckZpcnN0Q29tcGF0aWJsZU1vZGUoc3RyYXRlZ2llcykge1xuICAgICAgICByZXR1cm4gYXN5bmMgKGZ0cCkgPT4ge1xuICAgICAgICAgICAgZnRwLmxvZyhcIlRyeWluZyB0byBmaW5kIG9wdGltYWwgdHJhbnNmZXIgc3RyYXRlZ3kuLi5cIik7XG4gICAgICAgICAgICBsZXQgbGFzdEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzdHJhdGVneSBvZiBzdHJhdGVnaWVzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgc3RyYXRlZ3koZnRwKTtcbiAgICAgICAgICAgICAgICAgICAgZnRwLmxvZyhcIk9wdGltYWwgdHJhbnNmZXIgc3RyYXRlZ3kgZm91bmQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnByZXBhcmVUcmFuc2ZlciA9IHN0cmF0ZWd5OyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtYXRvbWljLXVwZGF0ZXNcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgdGhlIG5leHQgY2FuZGlkYXRlIG5vIG1hdHRlciB0aGUgZXhhY3QgZXJyb3IuIEl0J3MgcG9zc2libGUgdGhhdCBhIHNlcnZlclxuICAgICAgICAgICAgICAgICAgICAvLyBhbnN3ZXJlZCBpbmNvcnJlY3RseSB0byBhIHN0cmF0ZWd5LCBmb3IgZXhhbXBsZSBhIFBBU1YgYW5zd2VyIHRvIGFuIEVQU1YuXG4gICAgICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vbmUgb2YgdGhlIGF2YWlsYWJsZSB0cmFuc2ZlciBzdHJhdGVnaWVzIHdvcmsuIExhc3QgZXJyb3IgcmVzcG9uc2Ugd2FzICcke2xhc3RFcnJvcn0nLmApO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBERVBSRUNBVEVELCB1c2UgYHVwbG9hZEZyb21gLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgYXN5bmMgdXBsb2FkKHNvdXJjZSwgdG9SZW1vdGVQYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5mdHAubG9nKFwiV2FybmluZzogdXBsb2FkKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIHVwbG9hZEZyb20oKS5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLnVwbG9hZEZyb20oc291cmNlLCB0b1JlbW90ZVBhdGgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBERVBSRUNBVEVELCB1c2UgYGFwcGVuZEZyb21gLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgYXN5bmMgYXBwZW5kKHNvdXJjZSwgdG9SZW1vdGVQYXRoLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgdGhpcy5mdHAubG9nKFwiV2FybmluZzogYXBwZW5kKCkgaGFzIGJlZW4gZGVwcmVjYXRlZCwgdXNlIGFwcGVuZEZyb20oKS5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLmFwcGVuZEZyb20oc291cmNlLCB0b1JlbW90ZVBhdGgsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBERVBSRUNBVEVELCB1c2UgYGRvd25sb2FkVG9gLlxuICAgICAqIEBkZXByZWNhdGVkXG4gICAgICovXG4gICAgYXN5bmMgZG93bmxvYWQoZGVzdGluYXRpb24sIGZyb21SZW1vdGVQYXRoLCBzdGFydEF0ID0gMCkge1xuICAgICAgICB0aGlzLmZ0cC5sb2coXCJXYXJuaW5nOiBkb3dubG9hZCgpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSBkb3dubG9hZFRvKCkuXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy5kb3dubG9hZFRvKGRlc3RpbmF0aW9uLCBmcm9tUmVtb3RlUGF0aCwgc3RhcnRBdCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQsIHVzZSBgdXBsb2FkRnJvbURpcmAuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBhc3luYyB1cGxvYWREaXIobG9jYWxEaXJQYXRoLCByZW1vdGVEaXJQYXRoKSB7XG4gICAgICAgIHRoaXMuZnRwLmxvZyhcIldhcm5pbmc6IHVwbG9hZERpcigpIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIHVzZSB1cGxvYWRGcm9tRGlyKCkuXCIpO1xuICAgICAgICByZXR1cm4gdGhpcy51cGxvYWRGcm9tRGlyKGxvY2FsRGlyUGF0aCwgcmVtb3RlRGlyUGF0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERFUFJFQ0FURUQsIHVzZSBgZG93bmxvYWRUb0RpcmAuXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBhc3luYyBkb3dubG9hZERpcihsb2NhbERpclBhdGgpIHtcbiAgICAgICAgdGhpcy5mdHAubG9nKFwiV2FybmluZzogZG93bmxvYWREaXIoKSBoYXMgYmVlbiBkZXByZWNhdGVkLCB1c2UgZG93bmxvYWRUb0RpcigpLlwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZG93bmxvYWRUb0Rpcihsb2NhbERpclBhdGgpO1xuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuYXN5bmMgZnVuY3Rpb24gZW5zdXJlTG9jYWxEaXJlY3RvcnkocGF0aCkge1xuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZzU3RhdChwYXRoKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBhd2FpdCBmc01rRGlyKHBhdGgsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xuICAgIH1cbn1cbmFzeW5jIGZ1bmN0aW9uIGlnbm9yZUVycm9yKGZ1bmMpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gYXdhaXQgZnVuYygpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIC8vIElnbm9yZVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/Client.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/FileInfo.js":
/*!*************************************************!*\
  !*** ./node_modules/basic-ftp/dist/FileInfo.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FileInfo = exports.FileType = void 0;\nvar FileType;\n(function (FileType) {\n    FileType[FileType[\"Unknown\"] = 0] = \"Unknown\";\n    FileType[FileType[\"File\"] = 1] = \"File\";\n    FileType[FileType[\"Directory\"] = 2] = \"Directory\";\n    FileType[FileType[\"SymbolicLink\"] = 3] = \"SymbolicLink\";\n})(FileType || (exports.FileType = FileType = {}));\n/**\n * Describes a file, directory or symbolic link.\n */\nclass FileInfo {\n    constructor(name) {\n        this.name = name;\n        this.type = FileType.Unknown;\n        this.size = 0;\n        /**\n         * Unparsed, raw modification date as a string.\n         *\n         * If `modifiedAt` is undefined, the FTP server you're connected to doesn't support the more modern\n         * MLSD command for machine-readable directory listings. The older command LIST is then used returning\n         * results that vary a lot between servers as the format hasn't been standardized. Here, directory listings\n         * and especially modification dates were meant to be human-readable first.\n         *\n         * Be careful when still trying to parse this by yourself. Parsing dates from listings using LIST is\n         * unreliable. This library decides to offer parsed dates only when they're absolutely reliable and safe to\n         * use e.g. for comparisons.\n         */\n        this.rawModifiedAt = \"\";\n        /**\n         * Parsed modification date.\n         *\n         * Available if the FTP server supports the MLSD command. Only MLSD guarantees dates than can be reliably\n         * parsed with the correct timezone and a resolution down to seconds. See `rawModifiedAt` property for the unparsed\n         * date that is always available.\n         */\n        this.modifiedAt = undefined;\n        /**\n         * Unix permissions if present. If the underlying FTP server is not running on Unix this will be undefined.\n         * If set, you might be able to edit permissions with the FTP command `SITE CHMOD`.\n         */\n        this.permissions = undefined;\n        /**\n         * Hard link count if available.\n         */\n        this.hardLinkCount = undefined;\n        /**\n         * Link name for symbolic links if available.\n         */\n        this.link = undefined;\n        /**\n         * Unix group if available.\n         */\n        this.group = undefined;\n        /**\n         * Unix user if available.\n         */\n        this.user = undefined;\n        /**\n         * Unique ID if available.\n         */\n        this.uniqueID = undefined;\n        this.name = name;\n    }\n    get isDirectory() {\n        return this.type === FileType.Directory;\n    }\n    get isSymbolicLink() {\n        return this.type === FileType.SymbolicLink;\n    }\n    get isFile() {\n        return this.type === FileType.File;\n    }\n    /**\n     * Deprecated, legacy API. Use `rawModifiedAt` instead.\n     * @deprecated\n     */\n    get date() {\n        return this.rawModifiedAt;\n    }\n    set date(rawModifiedAt) {\n        this.rawModifiedAt = rawModifiedAt;\n    }\n}\nexports.FileInfo = FileInfo;\nFileInfo.UnixPermission = {\n    Read: 4,\n    Write: 2,\n    Execute: 1\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvRmlsZUluZm8uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsZ0JBQWdCLEdBQUcsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsZUFBZSxnQkFBZ0IsZ0JBQWdCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxXZWJzdGVwMlxcc2hpcG93bC1tZXJnZVxcbm9kZV9tb2R1bGVzXFxiYXNpYy1mdHBcXGRpc3RcXEZpbGVJbmZvLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaWxlSW5mbyA9IGV4cG9ydHMuRmlsZVR5cGUgPSB2b2lkIDA7XG52YXIgRmlsZVR5cGU7XG4oZnVuY3Rpb24gKEZpbGVUeXBlKSB7XG4gICAgRmlsZVR5cGVbRmlsZVR5cGVbXCJVbmtub3duXCJdID0gMF0gPSBcIlVua25vd25cIjtcbiAgICBGaWxlVHlwZVtGaWxlVHlwZVtcIkZpbGVcIl0gPSAxXSA9IFwiRmlsZVwiO1xuICAgIEZpbGVUeXBlW0ZpbGVUeXBlW1wiRGlyZWN0b3J5XCJdID0gMl0gPSBcIkRpcmVjdG9yeVwiO1xuICAgIEZpbGVUeXBlW0ZpbGVUeXBlW1wiU3ltYm9saWNMaW5rXCJdID0gM10gPSBcIlN5bWJvbGljTGlua1wiO1xufSkoRmlsZVR5cGUgfHwgKGV4cG9ydHMuRmlsZVR5cGUgPSBGaWxlVHlwZSA9IHt9KSk7XG4vKipcbiAqIERlc2NyaWJlcyBhIGZpbGUsIGRpcmVjdG9yeSBvciBzeW1ib2xpYyBsaW5rLlxuICovXG5jbGFzcyBGaWxlSW5mbyB7XG4gICAgY29uc3RydWN0b3IobmFtZSkge1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgICAgICB0aGlzLnR5cGUgPSBGaWxlVHlwZS5Vbmtub3duO1xuICAgICAgICB0aGlzLnNpemUgPSAwO1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5wYXJzZWQsIHJhdyBtb2RpZmljYXRpb24gZGF0ZSBhcyBhIHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYG1vZGlmaWVkQXRgIGlzIHVuZGVmaW5lZCwgdGhlIEZUUCBzZXJ2ZXIgeW91J3JlIGNvbm5lY3RlZCB0byBkb2Vzbid0IHN1cHBvcnQgdGhlIG1vcmUgbW9kZXJuXG4gICAgICAgICAqIE1MU0QgY29tbWFuZCBmb3IgbWFjaGluZS1yZWFkYWJsZSBkaXJlY3RvcnkgbGlzdGluZ3MuIFRoZSBvbGRlciBjb21tYW5kIExJU1QgaXMgdGhlbiB1c2VkIHJldHVybmluZ1xuICAgICAgICAgKiByZXN1bHRzIHRoYXQgdmFyeSBhIGxvdCBiZXR3ZWVuIHNlcnZlcnMgYXMgdGhlIGZvcm1hdCBoYXNuJ3QgYmVlbiBzdGFuZGFyZGl6ZWQuIEhlcmUsIGRpcmVjdG9yeSBsaXN0aW5nc1xuICAgICAgICAgKiBhbmQgZXNwZWNpYWxseSBtb2RpZmljYXRpb24gZGF0ZXMgd2VyZSBtZWFudCB0byBiZSBodW1hbi1yZWFkYWJsZSBmaXJzdC5cbiAgICAgICAgICpcbiAgICAgICAgICogQmUgY2FyZWZ1bCB3aGVuIHN0aWxsIHRyeWluZyB0byBwYXJzZSB0aGlzIGJ5IHlvdXJzZWxmLiBQYXJzaW5nIGRhdGVzIGZyb20gbGlzdGluZ3MgdXNpbmcgTElTVCBpc1xuICAgICAgICAgKiB1bnJlbGlhYmxlLiBUaGlzIGxpYnJhcnkgZGVjaWRlcyB0byBvZmZlciBwYXJzZWQgZGF0ZXMgb25seSB3aGVuIHRoZXkncmUgYWJzb2x1dGVseSByZWxpYWJsZSBhbmQgc2FmZSB0b1xuICAgICAgICAgKiB1c2UgZS5nLiBmb3IgY29tcGFyaXNvbnMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJhd01vZGlmaWVkQXQgPSBcIlwiO1xuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2VkIG1vZGlmaWNhdGlvbiBkYXRlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBBdmFpbGFibGUgaWYgdGhlIEZUUCBzZXJ2ZXIgc3VwcG9ydHMgdGhlIE1MU0QgY29tbWFuZC4gT25seSBNTFNEIGd1YXJhbnRlZXMgZGF0ZXMgdGhhbiBjYW4gYmUgcmVsaWFibHlcbiAgICAgICAgICogcGFyc2VkIHdpdGggdGhlIGNvcnJlY3QgdGltZXpvbmUgYW5kIGEgcmVzb2x1dGlvbiBkb3duIHRvIHNlY29uZHMuIFNlZSBgcmF3TW9kaWZpZWRBdGAgcHJvcGVydHkgZm9yIHRoZSB1bnBhcnNlZFxuICAgICAgICAgKiBkYXRlIHRoYXQgaXMgYWx3YXlzIGF2YWlsYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubW9kaWZpZWRBdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuaXggcGVybWlzc2lvbnMgaWYgcHJlc2VudC4gSWYgdGhlIHVuZGVybHlpbmcgRlRQIHNlcnZlciBpcyBub3QgcnVubmluZyBvbiBVbml4IHRoaXMgd2lsbCBiZSB1bmRlZmluZWQuXG4gICAgICAgICAqIElmIHNldCwgeW91IG1pZ2h0IGJlIGFibGUgdG8gZWRpdCBwZXJtaXNzaW9ucyB3aXRoIHRoZSBGVFAgY29tbWFuZCBgU0lURSBDSE1PRGAuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25zID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogSGFyZCBsaW5rIGNvdW50IGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaGFyZExpbmtDb3VudCA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExpbmsgbmFtZSBmb3Igc3ltYm9saWMgbGlua3MgaWYgYXZhaWxhYmxlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5saW5rID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5peCBncm91cCBpZiBhdmFpbGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmdyb3VwID0gdW5kZWZpbmVkO1xuICAgICAgICAvKipcbiAgICAgICAgICogVW5peCB1c2VyIGlmIGF2YWlsYWJsZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudXNlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVuaXF1ZSBJRCBpZiBhdmFpbGFibGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnVuaXF1ZUlEID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuICAgIH1cbiAgICBnZXQgaXNEaXJlY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IEZpbGVUeXBlLkRpcmVjdG9yeTtcbiAgICB9XG4gICAgZ2V0IGlzU3ltYm9saWNMaW5rKCkge1xuICAgICAgICByZXR1cm4gdGhpcy50eXBlID09PSBGaWxlVHlwZS5TeW1ib2xpY0xpbms7XG4gICAgfVxuICAgIGdldCBpc0ZpbGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGUgPT09IEZpbGVUeXBlLkZpbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlcHJlY2F0ZWQsIGxlZ2FjeSBBUEkuIFVzZSBgcmF3TW9kaWZpZWRBdGAgaW5zdGVhZC5cbiAgICAgKiBAZGVwcmVjYXRlZFxuICAgICAqL1xuICAgIGdldCBkYXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yYXdNb2RpZmllZEF0O1xuICAgIH1cbiAgICBzZXQgZGF0ZShyYXdNb2RpZmllZEF0KSB7XG4gICAgICAgIHRoaXMucmF3TW9kaWZpZWRBdCA9IHJhd01vZGlmaWVkQXQ7XG4gICAgfVxufVxuZXhwb3J0cy5GaWxlSW5mbyA9IEZpbGVJbmZvO1xuRmlsZUluZm8uVW5peFBlcm1pc3Npb24gPSB7XG4gICAgUmVhZDogNCxcbiAgICBXcml0ZTogMixcbiAgICBFeGVjdXRlOiAxXG59O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/FileInfo.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/FtpContext.js":
/*!***************************************************!*\
  !*** ./node_modules/basic-ftp/dist/FtpContext.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FTPContext = exports.FTPError = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst parseControlResponse_1 = __webpack_require__(/*! ./parseControlResponse */ \"(rsc)/./node_modules/basic-ftp/dist/parseControlResponse.js\");\n/**\n * Describes an FTP server error response including the FTP response code.\n */\nclass FTPError extends Error {\n    constructor(res) {\n        super(res.message);\n        this.name = this.constructor.name;\n        this.code = res.code;\n    }\n}\nexports.FTPError = FTPError;\nfunction doNothing() {\n    /** Do nothing */\n}\n/**\n * FTPContext holds the control and data sockets of an FTP connection and provides a\n * simplified way to interact with an FTP server, handle responses, errors and timeouts.\n *\n * It doesn't implement or use any FTP commands. It's only a foundation to make writing an FTP\n * client as easy as possible. You won't usually instantiate this, but use `Client`.\n */\nclass FTPContext {\n    /**\n     * Instantiate an FTP context.\n     *\n     * @param timeout - Timeout in milliseconds to apply to control and data connections. Use 0 for no timeout.\n     * @param encoding - Encoding to use for control connection. UTF-8 by default. Use \"latin1\" for older servers.\n     */\n    constructor(timeout = 0, encoding = \"utf8\") {\n        this.timeout = timeout;\n        /** Debug-level logging of all socket communication. */\n        this.verbose = false;\n        /** IP version to prefer (4: IPv4, 6: IPv6, undefined: automatic). */\n        this.ipFamily = undefined;\n        /** Options for TLS connections. */\n        this.tlsOptions = {};\n        /** A multiline response might be received as multiple chunks. */\n        this._partialResponse = \"\";\n        this._encoding = encoding;\n        // Help Typescript understand that we do indeed set _socket in the constructor but use the setter method to do so.\n        this._socket = this.socket = this._newSocket();\n        this._dataSocket = undefined;\n    }\n    /**\n     * Close the context.\n     */\n    close() {\n        // Internally, closing a context is always described with an error. If there is still a task running, it will\n        // abort with an exception that the user closed the client during a task. If no task is running, no exception is\n        // thrown but all newly submitted tasks after that will abort the exception that the client has been closed.\n        // In addition the user will get a stack trace pointing to where exactly the client has been closed. So in any\n        // case use _closingError to determine whether a context is closed. This also allows us to have a single code-path\n        // for closing a context making the implementation easier.\n        const message = this._task ? \"User closed client during task\" : \"User closed client\";\n        const err = new Error(message);\n        this.closeWithError(err);\n    }\n    /**\n     * Close the context with an error.\n     */\n    closeWithError(err) {\n        // If this context already has been closed, don't overwrite the reason.\n        if (this._closingError) {\n            return;\n        }\n        this._closingError = err;\n        // Close the sockets but don't fully reset this context to preserve `this._closingError`.\n        this._closeControlSocket();\n        this._closeSocket(this._dataSocket);\n        // Give the user's task a chance to react, maybe cleanup resources.\n        this._passToHandler(err);\n        // The task might not have been rejected by the user after receiving the error.\n        this._stopTrackingTask();\n    }\n    /**\n     * Returns true if this context has been closed or hasn't been connected yet. You can reopen it with `access`.\n     */\n    get closed() {\n        return this.socket.remoteAddress === undefined || this._closingError !== undefined;\n    }\n    /**\n     * Reset this contex and all of its state.\n     */\n    reset() {\n        this.socket = this._newSocket();\n    }\n    /**\n     * Get the FTP control socket.\n     */\n    get socket() {\n        return this._socket;\n    }\n    /**\n     * Set the socket for the control connection. This will only close the current control socket\n     * if the new one is not an upgrade to the current one.\n     */\n    set socket(socket) {\n        // No data socket should be open in any case where the control socket is set or upgraded.\n        this.dataSocket = undefined;\n        // This being a reset, reset any other state apart from the socket.\n        this.tlsOptions = {};\n        this._partialResponse = \"\";\n        if (this._socket) {\n            const newSocketUpgradesExisting = socket.localPort === this._socket.localPort;\n            if (newSocketUpgradesExisting) {\n                this._removeSocketListeners(this.socket);\n            }\n            else {\n                this._closeControlSocket();\n            }\n        }\n        if (socket) {\n            // Setting a completely new control socket is in essence something like a reset. That's\n            // why we also close any open data connection above. We can go one step further and reset\n            // a possible closing error. That means that a closed FTPContext can be \"reopened\" by\n            // setting a new control socket.\n            this._closingError = undefined;\n            // Don't set a timeout yet. Timeout for control sockets is only active during a task, see handle() below.\n            socket.setTimeout(0);\n            socket.setEncoding(this._encoding);\n            socket.setKeepAlive(true);\n            socket.on(\"data\", data => this._onControlSocketData(data));\n            // Server sending a FIN packet is treated as an error.\n            socket.on(\"end\", () => this.closeWithError(new Error(\"Server sent FIN packet unexpectedly, closing connection.\")));\n            // Control being closed without error by server is treated as an error.\n            socket.on(\"close\", hadError => { if (!hadError)\n                this.closeWithError(new Error(\"Server closed connection unexpectedly.\")); });\n            this._setupDefaultErrorHandlers(socket, \"control socket\");\n        }\n        this._socket = socket;\n    }\n    /**\n     * Get the current FTP data connection if present.\n     */\n    get dataSocket() {\n        return this._dataSocket;\n    }\n    /**\n     * Set the socket for the data connection. This will automatically close the former data socket.\n     */\n    set dataSocket(socket) {\n        this._closeSocket(this._dataSocket);\n        if (socket) {\n            // Don't set a timeout yet. Timeout data socket should be activated when data transmission starts\n            // and timeout on control socket is deactivated.\n            socket.setTimeout(0);\n            this._setupDefaultErrorHandlers(socket, \"data socket\");\n        }\n        this._dataSocket = socket;\n    }\n    /**\n     * Get the currently used encoding.\n     */\n    get encoding() {\n        return this._encoding;\n    }\n    /**\n     * Set the encoding used for the control socket.\n     *\n     * See https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings for what encodings\n     * are supported by Node.\n     */\n    set encoding(encoding) {\n        this._encoding = encoding;\n        if (this.socket) {\n            this.socket.setEncoding(encoding);\n        }\n    }\n    /**\n     * Send an FTP command without waiting for or handling the result.\n     */\n    send(command) {\n        const containsPassword = command.startsWith(\"PASS\");\n        const message = containsPassword ? \"> PASS ###\" : `> ${command}`;\n        this.log(message);\n        this._socket.write(command + \"\\r\\n\", this.encoding);\n    }\n    /**\n     * Send an FTP command and handle the first response. Use this if you have a simple\n     * request-response situation.\n     */\n    request(command) {\n        return this.handle(command, (res, task) => {\n            if (res instanceof Error) {\n                task.reject(res);\n            }\n            else {\n                task.resolve(res);\n            }\n        });\n    }\n    /**\n     * Send an FTP command and handle any response until you resolve/reject. Use this if you expect multiple responses\n     * to a request. This returns a Promise that will hold whatever the response handler passed on when resolving/rejecting its task.\n     */\n    handle(command, responseHandler) {\n        if (this._task) {\n            const err = new Error(\"User launched a task while another one is still running. Forgot to use 'await' or '.then()'?\");\n            err.stack += `\\nRunning task launched at: ${this._task.stack}`;\n            this.closeWithError(err);\n            // Don't return here, continue with returning the Promise that will then be rejected\n            // because the context closed already. That way, users will receive an exception where\n            // they called this method by mistake.\n        }\n        return new Promise((resolveTask, rejectTask) => {\n            this._task = {\n                stack: new Error().stack || \"Unknown call stack\",\n                responseHandler,\n                resolver: {\n                    resolve: arg => {\n                        this._stopTrackingTask();\n                        resolveTask(arg);\n                    },\n                    reject: err => {\n                        this._stopTrackingTask();\n                        rejectTask(err);\n                    }\n                }\n            };\n            if (this._closingError) {\n                // This client has been closed. Provide an error that describes this one as being caused\n                // by `_closingError`, include stack traces for both.\n                const err = new Error(`Client is closed because ${this._closingError.message}`); // Type 'Error' is not correctly defined, doesn't have 'code'.\n                err.stack += `\\nClosing reason: ${this._closingError.stack}`;\n                err.code = this._closingError.code !== undefined ? this._closingError.code : \"0\";\n                this._passToHandler(err);\n                return;\n            }\n            // Only track control socket timeout during the lifecycle of a task. This avoids timeouts on idle sockets,\n            // the default socket behaviour which is not expected by most users.\n            this.socket.setTimeout(this.timeout);\n            if (command) {\n                this.send(command);\n            }\n        });\n    }\n    /**\n     * Log message if set to be verbose.\n     */\n    log(message) {\n        if (this.verbose) {\n            // tslint:disable-next-line no-console\n            console.log(message);\n        }\n    }\n    /**\n     * Return true if the control socket is using TLS. This does not mean that a session\n     * has already been negotiated.\n     */\n    get hasTLS() {\n        return \"encrypted\" in this._socket;\n    }\n    /**\n     * Removes reference to current task and handler. This won't resolve or reject the task.\n     * @protected\n     */\n    _stopTrackingTask() {\n        // Disable timeout on control socket if there is no task active.\n        this.socket.setTimeout(0);\n        this._task = undefined;\n    }\n    /**\n     * Handle incoming data on the control socket. The chunk is going to be of type `string`\n     * because we let `socket` handle encoding with `setEncoding`.\n     * @protected\n     */\n    _onControlSocketData(chunk) {\n        this.log(`< ${chunk}`);\n        // This chunk might complete an earlier partial response.\n        const completeResponse = this._partialResponse + chunk;\n        const parsed = (0, parseControlResponse_1.parseControlResponse)(completeResponse);\n        // Remember any incomplete remainder.\n        this._partialResponse = parsed.rest;\n        // Each response group is passed along individually.\n        for (const message of parsed.messages) {\n            const code = parseInt(message.substr(0, 3), 10);\n            const response = { code, message };\n            const err = code >= 400 ? new FTPError(response) : undefined;\n            this._passToHandler(err ? err : response);\n        }\n    }\n    /**\n     * Send the current handler a response. This is usually a control socket response\n     * or a socket event, like an error or timeout.\n     * @protected\n     */\n    _passToHandler(response) {\n        if (this._task) {\n            this._task.responseHandler(response, this._task.resolver);\n        }\n        // Errors other than FTPError always close the client. If there isn't an active task to handle the error,\n        // the next one submitted will receive it using `_closingError`.\n        // There is only one edge-case: If there is an FTPError while no task is active, the error will be dropped.\n        // But that means that the user sent an FTP command with no intention of handling the result. So why should the\n        // error be handled? Maybe log it at least? Debug logging will already do that and the client stays useable after\n        // FTPError. So maybe no need to do anything here.\n    }\n    /**\n     * Setup all error handlers for a socket.\n     * @protected\n     */\n    _setupDefaultErrorHandlers(socket, identifier) {\n        socket.once(\"error\", error => {\n            error.message += ` (${identifier})`;\n            this.closeWithError(error);\n        });\n        socket.once(\"close\", hadError => {\n            if (hadError) {\n                this.closeWithError(new Error(`Socket closed due to transmission error (${identifier})`));\n            }\n        });\n        socket.once(\"timeout\", () => {\n            socket.destroy();\n            this.closeWithError(new Error(`Timeout (${identifier})`));\n        });\n    }\n    /**\n     * Close the control socket. Sends QUIT, then FIN, and ignores any response or error.\n     */\n    _closeControlSocket() {\n        this._removeSocketListeners(this._socket);\n        this._socket.on(\"error\", doNothing);\n        this.send(\"QUIT\");\n        this._closeSocket(this._socket);\n    }\n    /**\n     * Close a socket, ignores any error.\n     * @protected\n     */\n    _closeSocket(socket) {\n        if (socket) {\n            this._removeSocketListeners(socket);\n            socket.on(\"error\", doNothing);\n            socket.destroy();\n        }\n    }\n    /**\n     * Remove all default listeners for socket.\n     * @protected\n     */\n    _removeSocketListeners(socket) {\n        socket.removeAllListeners();\n        // Before Node.js 10.3.0, using `socket.removeAllListeners()` without any name did not work: https://github.com/nodejs/node/issues/20923.\n        socket.removeAllListeners(\"timeout\");\n        socket.removeAllListeners(\"data\");\n        socket.removeAllListeners(\"end\");\n        socket.removeAllListeners(\"error\");\n        socket.removeAllListeners(\"close\");\n        socket.removeAllListeners(\"connect\");\n    }\n    /**\n     * Provide a new socket instance.\n     *\n     * Internal use only, replaced for unit tests.\n     */\n    _newSocket() {\n        return new net_1.Socket();\n    }\n}\nexports.FTPContext = FTPContext;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvRnRwQ29udGV4dC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxrQkFBa0IsR0FBRyxnQkFBZ0I7QUFDckMsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLCtCQUErQixtQkFBTyxDQUFDLDJGQUF3QjtBQUMvRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0MsMkZBQTJGO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFFBQVE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsaUJBQWlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSwyQkFBMkIsSUFBSTtBQUNqRyxrREFBa0QseUJBQXlCO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsTUFBTTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsV0FBVztBQUM3QztBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsMEZBQTBGLFdBQVc7QUFDckc7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHNEQUFzRCxXQUFXO0FBQ2pFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCIiwic291cmNlcyI6WyJEOlxcV2Vic3RlcDJcXHNoaXBvd2wtbWVyZ2VcXG5vZGVfbW9kdWxlc1xcYmFzaWMtZnRwXFxkaXN0XFxGdHBDb250ZXh0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GVFBDb250ZXh0ID0gZXhwb3J0cy5GVFBFcnJvciA9IHZvaWQgMDtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IHBhcnNlQ29udHJvbFJlc3BvbnNlXzEgPSByZXF1aXJlKFwiLi9wYXJzZUNvbnRyb2xSZXNwb25zZVwiKTtcbi8qKlxuICogRGVzY3JpYmVzIGFuIEZUUCBzZXJ2ZXIgZXJyb3IgcmVzcG9uc2UgaW5jbHVkaW5nIHRoZSBGVFAgcmVzcG9uc2UgY29kZS5cbiAqL1xuY2xhc3MgRlRQRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IocmVzKSB7XG4gICAgICAgIHN1cGVyKHJlcy5tZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gdGhpcy5jb25zdHJ1Y3Rvci5uYW1lO1xuICAgICAgICB0aGlzLmNvZGUgPSByZXMuY29kZTtcbiAgICB9XG59XG5leHBvcnRzLkZUUEVycm9yID0gRlRQRXJyb3I7XG5mdW5jdGlvbiBkb05vdGhpbmcoKSB7XG4gICAgLyoqIERvIG5vdGhpbmcgKi9cbn1cbi8qKlxuICogRlRQQ29udGV4dCBob2xkcyB0aGUgY29udHJvbCBhbmQgZGF0YSBzb2NrZXRzIG9mIGFuIEZUUCBjb25uZWN0aW9uIGFuZCBwcm92aWRlcyBhXG4gKiBzaW1wbGlmaWVkIHdheSB0byBpbnRlcmFjdCB3aXRoIGFuIEZUUCBzZXJ2ZXIsIGhhbmRsZSByZXNwb25zZXMsIGVycm9ycyBhbmQgdGltZW91dHMuXG4gKlxuICogSXQgZG9lc24ndCBpbXBsZW1lbnQgb3IgdXNlIGFueSBGVFAgY29tbWFuZHMuIEl0J3Mgb25seSBhIGZvdW5kYXRpb24gdG8gbWFrZSB3cml0aW5nIGFuIEZUUFxuICogY2xpZW50IGFzIGVhc3kgYXMgcG9zc2libGUuIFlvdSB3b24ndCB1c3VhbGx5IGluc3RhbnRpYXRlIHRoaXMsIGJ1dCB1c2UgYENsaWVudGAuXG4gKi9cbmNsYXNzIEZUUENvbnRleHQge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGFuIEZUUCBjb250ZXh0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHRpbWVvdXQgLSBUaW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhcHBseSB0byBjb250cm9sIGFuZCBkYXRhIGNvbm5lY3Rpb25zLiBVc2UgMCBmb3Igbm8gdGltZW91dC5cbiAgICAgKiBAcGFyYW0gZW5jb2RpbmcgLSBFbmNvZGluZyB0byB1c2UgZm9yIGNvbnRyb2wgY29ubmVjdGlvbi4gVVRGLTggYnkgZGVmYXVsdC4gVXNlIFwibGF0aW4xXCIgZm9yIG9sZGVyIHNlcnZlcnMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IodGltZW91dCA9IDAsIGVuY29kaW5nID0gXCJ1dGY4XCIpIHtcbiAgICAgICAgdGhpcy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgLyoqIERlYnVnLWxldmVsIGxvZ2dpbmcgb2YgYWxsIHNvY2tldCBjb21tdW5pY2F0aW9uLiAqL1xuICAgICAgICB0aGlzLnZlcmJvc2UgPSBmYWxzZTtcbiAgICAgICAgLyoqIElQIHZlcnNpb24gdG8gcHJlZmVyICg0OiBJUHY0LCA2OiBJUHY2LCB1bmRlZmluZWQ6IGF1dG9tYXRpYykuICovXG4gICAgICAgIHRoaXMuaXBGYW1pbHkgPSB1bmRlZmluZWQ7XG4gICAgICAgIC8qKiBPcHRpb25zIGZvciBUTFMgY29ubmVjdGlvbnMuICovXG4gICAgICAgIHRoaXMudGxzT3B0aW9ucyA9IHt9O1xuICAgICAgICAvKiogQSBtdWx0aWxpbmUgcmVzcG9uc2UgbWlnaHQgYmUgcmVjZWl2ZWQgYXMgbXVsdGlwbGUgY2h1bmtzLiAqL1xuICAgICAgICB0aGlzLl9wYXJ0aWFsUmVzcG9uc2UgPSBcIlwiO1xuICAgICAgICB0aGlzLl9lbmNvZGluZyA9IGVuY29kaW5nO1xuICAgICAgICAvLyBIZWxwIFR5cGVzY3JpcHQgdW5kZXJzdGFuZCB0aGF0IHdlIGRvIGluZGVlZCBzZXQgX3NvY2tldCBpbiB0aGUgY29uc3RydWN0b3IgYnV0IHVzZSB0aGUgc2V0dGVyIG1ldGhvZCB0byBkbyBzby5cbiAgICAgICAgdGhpcy5fc29ja2V0ID0gdGhpcy5zb2NrZXQgPSB0aGlzLl9uZXdTb2NrZXQoKTtcbiAgICAgICAgdGhpcy5fZGF0YVNvY2tldCA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGNvbnRleHQuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIC8vIEludGVybmFsbHksIGNsb3NpbmcgYSBjb250ZXh0IGlzIGFsd2F5cyBkZXNjcmliZWQgd2l0aCBhbiBlcnJvci4gSWYgdGhlcmUgaXMgc3RpbGwgYSB0YXNrIHJ1bm5pbmcsIGl0IHdpbGxcbiAgICAgICAgLy8gYWJvcnQgd2l0aCBhbiBleGNlcHRpb24gdGhhdCB0aGUgdXNlciBjbG9zZWQgdGhlIGNsaWVudCBkdXJpbmcgYSB0YXNrLiBJZiBubyB0YXNrIGlzIHJ1bm5pbmcsIG5vIGV4Y2VwdGlvbiBpc1xuICAgICAgICAvLyB0aHJvd24gYnV0IGFsbCBuZXdseSBzdWJtaXR0ZWQgdGFza3MgYWZ0ZXIgdGhhdCB3aWxsIGFib3J0IHRoZSBleGNlcHRpb24gdGhhdCB0aGUgY2xpZW50IGhhcyBiZWVuIGNsb3NlZC5cbiAgICAgICAgLy8gSW4gYWRkaXRpb24gdGhlIHVzZXIgd2lsbCBnZXQgYSBzdGFjayB0cmFjZSBwb2ludGluZyB0byB3aGVyZSBleGFjdGx5IHRoZSBjbGllbnQgaGFzIGJlZW4gY2xvc2VkLiBTbyBpbiBhbnlcbiAgICAgICAgLy8gY2FzZSB1c2UgX2Nsb3NpbmdFcnJvciB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbnRleHQgaXMgY2xvc2VkLiBUaGlzIGFsc28gYWxsb3dzIHVzIHRvIGhhdmUgYSBzaW5nbGUgY29kZS1wYXRoXG4gICAgICAgIC8vIGZvciBjbG9zaW5nIGEgY29udGV4dCBtYWtpbmcgdGhlIGltcGxlbWVudGF0aW9uIGVhc2llci5cbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IHRoaXMuX3Rhc2sgPyBcIlVzZXIgY2xvc2VkIGNsaWVudCBkdXJpbmcgdGFza1wiIDogXCJVc2VyIGNsb3NlZCBjbGllbnRcIjtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlIHRoZSBjb250ZXh0IHdpdGggYW4gZXJyb3IuXG4gICAgICovXG4gICAgY2xvc2VXaXRoRXJyb3IoZXJyKSB7XG4gICAgICAgIC8vIElmIHRoaXMgY29udGV4dCBhbHJlYWR5IGhhcyBiZWVuIGNsb3NlZCwgZG9uJ3Qgb3ZlcndyaXRlIHRoZSByZWFzb24uXG4gICAgICAgIGlmICh0aGlzLl9jbG9zaW5nRXJyb3IpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9jbG9zaW5nRXJyb3IgPSBlcnI7XG4gICAgICAgIC8vIENsb3NlIHRoZSBzb2NrZXRzIGJ1dCBkb24ndCBmdWxseSByZXNldCB0aGlzIGNvbnRleHQgdG8gcHJlc2VydmUgYHRoaXMuX2Nsb3NpbmdFcnJvcmAuXG4gICAgICAgIHRoaXMuX2Nsb3NlQ29udHJvbFNvY2tldCgpO1xuICAgICAgICB0aGlzLl9jbG9zZVNvY2tldCh0aGlzLl9kYXRhU29ja2V0KTtcbiAgICAgICAgLy8gR2l2ZSB0aGUgdXNlcidzIHRhc2sgYSBjaGFuY2UgdG8gcmVhY3QsIG1heWJlIGNsZWFudXAgcmVzb3VyY2VzLlxuICAgICAgICB0aGlzLl9wYXNzVG9IYW5kbGVyKGVycik7XG4gICAgICAgIC8vIFRoZSB0YXNrIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVqZWN0ZWQgYnkgdGhlIHVzZXIgYWZ0ZXIgcmVjZWl2aW5nIHRoZSBlcnJvci5cbiAgICAgICAgdGhpcy5fc3RvcFRyYWNraW5nVGFzaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRydWUgaWYgdGhpcyBjb250ZXh0IGhhcyBiZWVuIGNsb3NlZCBvciBoYXNuJ3QgYmVlbiBjb25uZWN0ZWQgeWV0LiBZb3UgY2FuIHJlb3BlbiBpdCB3aXRoIGBhY2Nlc3NgLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldC5yZW1vdGVBZGRyZXNzID09PSB1bmRlZmluZWQgfHwgdGhpcy5fY2xvc2luZ0Vycm9yICE9PSB1bmRlZmluZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0IHRoaXMgY29udGV4IGFuZCBhbGwgb2YgaXRzIHN0YXRlLlxuICAgICAqL1xuICAgIHJlc2V0KCkge1xuICAgICAgICB0aGlzLnNvY2tldCA9IHRoaXMuX25ld1NvY2tldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIEZUUCBjb250cm9sIHNvY2tldC5cbiAgICAgKi9cbiAgICBnZXQgc29ja2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc29ja2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHNvY2tldCBmb3IgdGhlIGNvbnRyb2wgY29ubmVjdGlvbi4gVGhpcyB3aWxsIG9ubHkgY2xvc2UgdGhlIGN1cnJlbnQgY29udHJvbCBzb2NrZXRcbiAgICAgKiBpZiB0aGUgbmV3IG9uZSBpcyBub3QgYW4gdXBncmFkZSB0byB0aGUgY3VycmVudCBvbmUuXG4gICAgICovXG4gICAgc2V0IHNvY2tldChzb2NrZXQpIHtcbiAgICAgICAgLy8gTm8gZGF0YSBzb2NrZXQgc2hvdWxkIGJlIG9wZW4gaW4gYW55IGNhc2Ugd2hlcmUgdGhlIGNvbnRyb2wgc29ja2V0IGlzIHNldCBvciB1cGdyYWRlZC5cbiAgICAgICAgdGhpcy5kYXRhU29ja2V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAvLyBUaGlzIGJlaW5nIGEgcmVzZXQsIHJlc2V0IGFueSBvdGhlciBzdGF0ZSBhcGFydCBmcm9tIHRoZSBzb2NrZXQuXG4gICAgICAgIHRoaXMudGxzT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLl9wYXJ0aWFsUmVzcG9uc2UgPSBcIlwiO1xuICAgICAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICAgICAgICBjb25zdCBuZXdTb2NrZXRVcGdyYWRlc0V4aXN0aW5nID0gc29ja2V0LmxvY2FsUG9ydCA9PT0gdGhpcy5fc29ja2V0LmxvY2FsUG9ydDtcbiAgICAgICAgICAgIGlmIChuZXdTb2NrZXRVcGdyYWRlc0V4aXN0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKHRoaXMuc29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Nsb3NlQ29udHJvbFNvY2tldCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgIC8vIFNldHRpbmcgYSBjb21wbGV0ZWx5IG5ldyBjb250cm9sIHNvY2tldCBpcyBpbiBlc3NlbmNlIHNvbWV0aGluZyBsaWtlIGEgcmVzZXQuIFRoYXQnc1xuICAgICAgICAgICAgLy8gd2h5IHdlIGFsc28gY2xvc2UgYW55IG9wZW4gZGF0YSBjb25uZWN0aW9uIGFib3ZlLiBXZSBjYW4gZ28gb25lIHN0ZXAgZnVydGhlciBhbmQgcmVzZXRcbiAgICAgICAgICAgIC8vIGEgcG9zc2libGUgY2xvc2luZyBlcnJvci4gVGhhdCBtZWFucyB0aGF0IGEgY2xvc2VkIEZUUENvbnRleHQgY2FuIGJlIFwicmVvcGVuZWRcIiBieVxuICAgICAgICAgICAgLy8gc2V0dGluZyBhIG5ldyBjb250cm9sIHNvY2tldC5cbiAgICAgICAgICAgIHRoaXMuX2Nsb3NpbmdFcnJvciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIC8vIERvbid0IHNldCBhIHRpbWVvdXQgeWV0LiBUaW1lb3V0IGZvciBjb250cm9sIHNvY2tldHMgaXMgb25seSBhY3RpdmUgZHVyaW5nIGEgdGFzaywgc2VlIGhhbmRsZSgpIGJlbG93LlxuICAgICAgICAgICAgc29ja2V0LnNldFRpbWVvdXQoMCk7XG4gICAgICAgICAgICBzb2NrZXQuc2V0RW5jb2RpbmcodGhpcy5fZW5jb2RpbmcpO1xuICAgICAgICAgICAgc29ja2V0LnNldEtlZXBBbGl2ZSh0cnVlKTtcbiAgICAgICAgICAgIHNvY2tldC5vbihcImRhdGFcIiwgZGF0YSA9PiB0aGlzLl9vbkNvbnRyb2xTb2NrZXREYXRhKGRhdGEpKTtcbiAgICAgICAgICAgIC8vIFNlcnZlciBzZW5kaW5nIGEgRklOIHBhY2tldCBpcyB0cmVhdGVkIGFzIGFuIGVycm9yLlxuICAgICAgICAgICAgc29ja2V0Lm9uKFwiZW5kXCIsICgpID0+IHRoaXMuY2xvc2VXaXRoRXJyb3IobmV3IEVycm9yKFwiU2VydmVyIHNlbnQgRklOIHBhY2tldCB1bmV4cGVjdGVkbHksIGNsb3NpbmcgY29ubmVjdGlvbi5cIikpKTtcbiAgICAgICAgICAgIC8vIENvbnRyb2wgYmVpbmcgY2xvc2VkIHdpdGhvdXQgZXJyb3IgYnkgc2VydmVyIGlzIHRyZWF0ZWQgYXMgYW4gZXJyb3IuXG4gICAgICAgICAgICBzb2NrZXQub24oXCJjbG9zZVwiLCBoYWRFcnJvciA9PiB7IGlmICghaGFkRXJyb3IpXG4gICAgICAgICAgICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihuZXcgRXJyb3IoXCJTZXJ2ZXIgY2xvc2VkIGNvbm5lY3Rpb24gdW5leHBlY3RlZGx5LlwiKSk7IH0pO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBEZWZhdWx0RXJyb3JIYW5kbGVycyhzb2NrZXQsIFwiY29udHJvbCBzb2NrZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgRlRQIGRhdGEgY29ubmVjdGlvbiBpZiBwcmVzZW50LlxuICAgICAqL1xuICAgIGdldCBkYXRhU29ja2V0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YVNvY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBzb2NrZXQgZm9yIHRoZSBkYXRhIGNvbm5lY3Rpb24uIFRoaXMgd2lsbCBhdXRvbWF0aWNhbGx5IGNsb3NlIHRoZSBmb3JtZXIgZGF0YSBzb2NrZXQuXG4gICAgICovXG4gICAgc2V0IGRhdGFTb2NrZXQoc29ja2V0KSB7XG4gICAgICAgIHRoaXMuX2Nsb3NlU29ja2V0KHRoaXMuX2RhdGFTb2NrZXQpO1xuICAgICAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgICAgICAvLyBEb24ndCBzZXQgYSB0aW1lb3V0IHlldC4gVGltZW91dCBkYXRhIHNvY2tldCBzaG91bGQgYmUgYWN0aXZhdGVkIHdoZW4gZGF0YSB0cmFuc21pc3Npb24gc3RhcnRzXG4gICAgICAgICAgICAvLyBhbmQgdGltZW91dCBvbiBjb250cm9sIHNvY2tldCBpcyBkZWFjdGl2YXRlZC5cbiAgICAgICAgICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBEZWZhdWx0RXJyb3JIYW5kbGVycyhzb2NrZXQsIFwiZGF0YSBzb2NrZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YVNvY2tldCA9IHNvY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50bHkgdXNlZCBlbmNvZGluZy5cbiAgICAgKi9cbiAgICBnZXQgZW5jb2RpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lbmNvZGluZztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSBlbmNvZGluZyB1c2VkIGZvciB0aGUgY29udHJvbCBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBTZWUgaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9idWZmZXIuaHRtbCNidWZmZXJfYnVmZmVyc19hbmRfY2hhcmFjdGVyX2VuY29kaW5ncyBmb3Igd2hhdCBlbmNvZGluZ3NcbiAgICAgKiBhcmUgc3VwcG9ydGVkIGJ5IE5vZGUuXG4gICAgICovXG4gICAgc2V0IGVuY29kaW5nKGVuY29kaW5nKSB7XG4gICAgICAgIHRoaXMuX2VuY29kaW5nID0gZW5jb2Rpbmc7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2V0RW5jb2RpbmcoZW5jb2RpbmcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYW4gRlRQIGNvbW1hbmQgd2l0aG91dCB3YWl0aW5nIGZvciBvciBoYW5kbGluZyB0aGUgcmVzdWx0LlxuICAgICAqL1xuICAgIHNlbmQoY29tbWFuZCkge1xuICAgICAgICBjb25zdCBjb250YWluc1Bhc3N3b3JkID0gY29tbWFuZC5zdGFydHNXaXRoKFwiUEFTU1wiKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGNvbnRhaW5zUGFzc3dvcmQgPyBcIj4gUEFTUyAjIyNcIiA6IGA+ICR7Y29tbWFuZH1gO1xuICAgICAgICB0aGlzLmxvZyhtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5fc29ja2V0LndyaXRlKGNvbW1hbmQgKyBcIlxcclxcblwiLCB0aGlzLmVuY29kaW5nKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhbiBGVFAgY29tbWFuZCBhbmQgaGFuZGxlIHRoZSBmaXJzdCByZXNwb25zZS4gVXNlIHRoaXMgaWYgeW91IGhhdmUgYSBzaW1wbGVcbiAgICAgKiByZXF1ZXN0LXJlc3BvbnNlIHNpdHVhdGlvbi5cbiAgICAgKi9cbiAgICByZXF1ZXN0KGNvbW1hbmQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFuZGxlKGNvbW1hbmQsIChyZXMsIHRhc2spID0+IHtcbiAgICAgICAgICAgIGlmIChyZXMgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgIHRhc2sucmVqZWN0KHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0YXNrLnJlc29sdmUocmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYW4gRlRQIGNvbW1hbmQgYW5kIGhhbmRsZSBhbnkgcmVzcG9uc2UgdW50aWwgeW91IHJlc29sdmUvcmVqZWN0LiBVc2UgdGhpcyBpZiB5b3UgZXhwZWN0IG11bHRpcGxlIHJlc3BvbnNlc1xuICAgICAqIHRvIGEgcmVxdWVzdC4gVGhpcyByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHdpbGwgaG9sZCB3aGF0ZXZlciB0aGUgcmVzcG9uc2UgaGFuZGxlciBwYXNzZWQgb24gd2hlbiByZXNvbHZpbmcvcmVqZWN0aW5nIGl0cyB0YXNrLlxuICAgICAqL1xuICAgIGhhbmRsZShjb21tYW5kLCByZXNwb25zZUhhbmRsZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Rhc2spIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcIlVzZXIgbGF1bmNoZWQgYSB0YXNrIHdoaWxlIGFub3RoZXIgb25lIGlzIHN0aWxsIHJ1bm5pbmcuIEZvcmdvdCB0byB1c2UgJ2F3YWl0JyBvciAnLnRoZW4oKSc/XCIpO1xuICAgICAgICAgICAgZXJyLnN0YWNrICs9IGBcXG5SdW5uaW5nIHRhc2sgbGF1bmNoZWQgYXQ6ICR7dGhpcy5fdGFzay5zdGFja31gO1xuICAgICAgICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihlcnIpO1xuICAgICAgICAgICAgLy8gRG9uJ3QgcmV0dXJuIGhlcmUsIGNvbnRpbnVlIHdpdGggcmV0dXJuaW5nIHRoZSBQcm9taXNlIHRoYXQgd2lsbCB0aGVuIGJlIHJlamVjdGVkXG4gICAgICAgICAgICAvLyBiZWNhdXNlIHRoZSBjb250ZXh0IGNsb3NlZCBhbHJlYWR5LiBUaGF0IHdheSwgdXNlcnMgd2lsbCByZWNlaXZlIGFuIGV4Y2VwdGlvbiB3aGVyZVxuICAgICAgICAgICAgLy8gdGhleSBjYWxsZWQgdGhpcyBtZXRob2QgYnkgbWlzdGFrZS5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmVUYXNrLCByZWplY3RUYXNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl90YXNrID0ge1xuICAgICAgICAgICAgICAgIHN0YWNrOiBuZXcgRXJyb3IoKS5zdGFjayB8fCBcIlVua25vd24gY2FsbCBzdGFja1wiLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlSGFuZGxlcixcbiAgICAgICAgICAgICAgICByZXNvbHZlcjoge1xuICAgICAgICAgICAgICAgICAgICByZXNvbHZlOiBhcmcgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcFRyYWNraW5nVGFzaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZVRhc2soYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0OiBlcnIgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RvcFRyYWNraW5nVGFzaygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0VGFzayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zaW5nRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBUaGlzIGNsaWVudCBoYXMgYmVlbiBjbG9zZWQuIFByb3ZpZGUgYW4gZXJyb3IgdGhhdCBkZXNjcmliZXMgdGhpcyBvbmUgYXMgYmVpbmcgY2F1c2VkXG4gICAgICAgICAgICAgICAgLy8gYnkgYF9jbG9zaW5nRXJyb3JgLCBpbmNsdWRlIHN0YWNrIHRyYWNlcyBmb3IgYm90aC5cbiAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYENsaWVudCBpcyBjbG9zZWQgYmVjYXVzZSAke3RoaXMuX2Nsb3NpbmdFcnJvci5tZXNzYWdlfWApOyAvLyBUeXBlICdFcnJvcicgaXMgbm90IGNvcnJlY3RseSBkZWZpbmVkLCBkb2Vzbid0IGhhdmUgJ2NvZGUnLlxuICAgICAgICAgICAgICAgIGVyci5zdGFjayArPSBgXFxuQ2xvc2luZyByZWFzb246ICR7dGhpcy5fY2xvc2luZ0Vycm9yLnN0YWNrfWA7XG4gICAgICAgICAgICAgICAgZXJyLmNvZGUgPSB0aGlzLl9jbG9zaW5nRXJyb3IuY29kZSAhPT0gdW5kZWZpbmVkID8gdGhpcy5fY2xvc2luZ0Vycm9yLmNvZGUgOiBcIjBcIjtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYXNzVG9IYW5kbGVyKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gT25seSB0cmFjayBjb250cm9sIHNvY2tldCB0aW1lb3V0IGR1cmluZyB0aGUgbGlmZWN5Y2xlIG9mIGEgdGFzay4gVGhpcyBhdm9pZHMgdGltZW91dHMgb24gaWRsZSBzb2NrZXRzLFxuICAgICAgICAgICAgLy8gdGhlIGRlZmF1bHQgc29ja2V0IGJlaGF2aW91ciB3aGljaCBpcyBub3QgZXhwZWN0ZWQgYnkgbW9zdCB1c2Vycy5cbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNldFRpbWVvdXQodGhpcy50aW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChjb21tYW5kKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kKGNvbW1hbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9nIG1lc3NhZ2UgaWYgc2V0IHRvIGJlIHZlcmJvc2UuXG4gICAgICovXG4gICAgbG9nKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMudmVyYm9zZSkge1xuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiB0cnVlIGlmIHRoZSBjb250cm9sIHNvY2tldCBpcyB1c2luZyBUTFMuIFRoaXMgZG9lcyBub3QgbWVhbiB0aGF0IGEgc2Vzc2lvblxuICAgICAqIGhhcyBhbHJlYWR5IGJlZW4gbmVnb3RpYXRlZC5cbiAgICAgKi9cbiAgICBnZXQgaGFzVExTKCkge1xuICAgICAgICByZXR1cm4gXCJlbmNyeXB0ZWRcIiBpbiB0aGlzLl9zb2NrZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgcmVmZXJlbmNlIHRvIGN1cnJlbnQgdGFzayBhbmQgaGFuZGxlci4gVGhpcyB3b24ndCByZXNvbHZlIG9yIHJlamVjdCB0aGUgdGFzay5cbiAgICAgKiBAcHJvdGVjdGVkXG4gICAgICovXG4gICAgX3N0b3BUcmFja2luZ1Rhc2soKSB7XG4gICAgICAgIC8vIERpc2FibGUgdGltZW91dCBvbiBjb250cm9sIHNvY2tldCBpZiB0aGVyZSBpcyBubyB0YXNrIGFjdGl2ZS5cbiAgICAgICAgdGhpcy5zb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICAgICAgdGhpcy5fdGFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlIGluY29taW5nIGRhdGEgb24gdGhlIGNvbnRyb2wgc29ja2V0LiBUaGUgY2h1bmsgaXMgZ29pbmcgdG8gYmUgb2YgdHlwZSBgc3RyaW5nYFxuICAgICAqIGJlY2F1c2Ugd2UgbGV0IGBzb2NrZXRgIGhhbmRsZSBlbmNvZGluZyB3aXRoIGBzZXRFbmNvZGluZ2AuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9vbkNvbnRyb2xTb2NrZXREYXRhKGNodW5rKSB7XG4gICAgICAgIHRoaXMubG9nKGA8ICR7Y2h1bmt9YCk7XG4gICAgICAgIC8vIFRoaXMgY2h1bmsgbWlnaHQgY29tcGxldGUgYW4gZWFybGllciBwYXJ0aWFsIHJlc3BvbnNlLlxuICAgICAgICBjb25zdCBjb21wbGV0ZVJlc3BvbnNlID0gdGhpcy5fcGFydGlhbFJlc3BvbnNlICsgY2h1bms7XG4gICAgICAgIGNvbnN0IHBhcnNlZCA9ICgwLCBwYXJzZUNvbnRyb2xSZXNwb25zZV8xLnBhcnNlQ29udHJvbFJlc3BvbnNlKShjb21wbGV0ZVJlc3BvbnNlKTtcbiAgICAgICAgLy8gUmVtZW1iZXIgYW55IGluY29tcGxldGUgcmVtYWluZGVyLlxuICAgICAgICB0aGlzLl9wYXJ0aWFsUmVzcG9uc2UgPSBwYXJzZWQucmVzdDtcbiAgICAgICAgLy8gRWFjaCByZXNwb25zZSBncm91cCBpcyBwYXNzZWQgYWxvbmcgaW5kaXZpZHVhbGx5LlxuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcGFyc2VkLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCBjb2RlID0gcGFyc2VJbnQobWVzc2FnZS5zdWJzdHIoMCwgMyksIDEwKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0geyBjb2RlLCBtZXNzYWdlIH07XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBjb2RlID49IDQwMCA/IG5ldyBGVFBFcnJvcihyZXNwb25zZSkgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLl9wYXNzVG9IYW5kbGVyKGVyciA/IGVyciA6IHJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIHRoZSBjdXJyZW50IGhhbmRsZXIgYSByZXNwb25zZS4gVGhpcyBpcyB1c3VhbGx5IGEgY29udHJvbCBzb2NrZXQgcmVzcG9uc2VcbiAgICAgKiBvciBhIHNvY2tldCBldmVudCwgbGlrZSBhbiBlcnJvciBvciB0aW1lb3V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfcGFzc1RvSGFuZGxlcihyZXNwb25zZSkge1xuICAgICAgICBpZiAodGhpcy5fdGFzaykge1xuICAgICAgICAgICAgdGhpcy5fdGFzay5yZXNwb25zZUhhbmRsZXIocmVzcG9uc2UsIHRoaXMuX3Rhc2sucmVzb2x2ZXIpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVycm9ycyBvdGhlciB0aGFuIEZUUEVycm9yIGFsd2F5cyBjbG9zZSB0aGUgY2xpZW50LiBJZiB0aGVyZSBpc24ndCBhbiBhY3RpdmUgdGFzayB0byBoYW5kbGUgdGhlIGVycm9yLFxuICAgICAgICAvLyB0aGUgbmV4dCBvbmUgc3VibWl0dGVkIHdpbGwgcmVjZWl2ZSBpdCB1c2luZyBgX2Nsb3NpbmdFcnJvcmAuXG4gICAgICAgIC8vIFRoZXJlIGlzIG9ubHkgb25lIGVkZ2UtY2FzZTogSWYgdGhlcmUgaXMgYW4gRlRQRXJyb3Igd2hpbGUgbm8gdGFzayBpcyBhY3RpdmUsIHRoZSBlcnJvciB3aWxsIGJlIGRyb3BwZWQuXG4gICAgICAgIC8vIEJ1dCB0aGF0IG1lYW5zIHRoYXQgdGhlIHVzZXIgc2VudCBhbiBGVFAgY29tbWFuZCB3aXRoIG5vIGludGVudGlvbiBvZiBoYW5kbGluZyB0aGUgcmVzdWx0LiBTbyB3aHkgc2hvdWxkIHRoZVxuICAgICAgICAvLyBlcnJvciBiZSBoYW5kbGVkPyBNYXliZSBsb2cgaXQgYXQgbGVhc3Q/IERlYnVnIGxvZ2dpbmcgd2lsbCBhbHJlYWR5IGRvIHRoYXQgYW5kIHRoZSBjbGllbnQgc3RheXMgdXNlYWJsZSBhZnRlclxuICAgICAgICAvLyBGVFBFcnJvci4gU28gbWF5YmUgbm8gbmVlZCB0byBkbyBhbnl0aGluZyBoZXJlLlxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCBhbGwgZXJyb3IgaGFuZGxlcnMgZm9yIGEgc29ja2V0LlxuICAgICAqIEBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBfc2V0dXBEZWZhdWx0RXJyb3JIYW5kbGVycyhzb2NrZXQsIGlkZW50aWZpZXIpIHtcbiAgICAgICAgc29ja2V0Lm9uY2UoXCJlcnJvclwiLCBlcnJvciA9PiB7XG4gICAgICAgICAgICBlcnJvci5tZXNzYWdlICs9IGAgKCR7aWRlbnRpZmllcn0pYDtcbiAgICAgICAgICAgIHRoaXMuY2xvc2VXaXRoRXJyb3IoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICAgICAgc29ja2V0Lm9uY2UoXCJjbG9zZVwiLCBoYWRFcnJvciA9PiB7XG4gICAgICAgICAgICBpZiAoaGFkRXJyb3IpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKG5ldyBFcnJvcihgU29ja2V0IGNsb3NlZCBkdWUgdG8gdHJhbnNtaXNzaW9uIGVycm9yICgke2lkZW50aWZpZXJ9KWApKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHNvY2tldC5vbmNlKFwidGltZW91dFwiLCAoKSA9PiB7XG4gICAgICAgICAgICBzb2NrZXQuZGVzdHJveSgpO1xuICAgICAgICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihuZXcgRXJyb3IoYFRpbWVvdXQgKCR7aWRlbnRpZmllcn0pYCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2UgdGhlIGNvbnRyb2wgc29ja2V0LiBTZW5kcyBRVUlULCB0aGVuIEZJTiwgYW5kIGlnbm9yZXMgYW55IHJlc3BvbnNlIG9yIGVycm9yLlxuICAgICAqL1xuICAgIF9jbG9zZUNvbnRyb2xTb2NrZXQoKSB7XG4gICAgICAgIHRoaXMuX3JlbW92ZVNvY2tldExpc3RlbmVycyh0aGlzLl9zb2NrZXQpO1xuICAgICAgICB0aGlzLl9zb2NrZXQub24oXCJlcnJvclwiLCBkb05vdGhpbmcpO1xuICAgICAgICB0aGlzLnNlbmQoXCJRVUlUXCIpO1xuICAgICAgICB0aGlzLl9jbG9zZVNvY2tldCh0aGlzLl9zb2NrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSBhIHNvY2tldCwgaWdub3JlcyBhbnkgZXJyb3IuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9jbG9zZVNvY2tldChzb2NrZXQpIHtcbiAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3ZlU29ja2V0TGlzdGVuZXJzKHNvY2tldCk7XG4gICAgICAgICAgICBzb2NrZXQub24oXCJlcnJvclwiLCBkb05vdGhpbmcpO1xuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYWxsIGRlZmF1bHQgbGlzdGVuZXJzIGZvciBzb2NrZXQuXG4gICAgICogQHByb3RlY3RlZFxuICAgICAqL1xuICAgIF9yZW1vdmVTb2NrZXRMaXN0ZW5lcnMoc29ja2V0KSB7XG4gICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoKTtcbiAgICAgICAgLy8gQmVmb3JlIE5vZGUuanMgMTAuMy4wLCB1c2luZyBgc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycygpYCB3aXRob3V0IGFueSBuYW1lIGRpZCBub3Qgd29yazogaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy8yMDkyMy5cbiAgICAgICAgc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycyhcInRpbWVvdXRcIik7XG4gICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJkYXRhXCIpO1xuICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKFwiZW5kXCIpO1xuICAgICAgICBzb2NrZXQucmVtb3ZlQWxsTGlzdGVuZXJzKFwiZXJyb3JcIik7XG4gICAgICAgIHNvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJjbG9zZVwiKTtcbiAgICAgICAgc29ja2V0LnJlbW92ZUFsbExpc3RlbmVycyhcImNvbm5lY3RcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb3ZpZGUgYSBuZXcgc29ja2V0IGluc3RhbmNlLlxuICAgICAqXG4gICAgICogSW50ZXJuYWwgdXNlIG9ubHksIHJlcGxhY2VkIGZvciB1bml0IHRlc3RzLlxuICAgICAqL1xuICAgIF9uZXdTb2NrZXQoKSB7XG4gICAgICAgIHJldHVybiBuZXcgbmV0XzEuU29ja2V0KCk7XG4gICAgfVxufVxuZXhwb3J0cy5GVFBDb250ZXh0ID0gRlRQQ29udGV4dDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/FtpContext.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/ProgressTracker.js":
/*!********************************************************!*\
  !*** ./node_modules/basic-ftp/dist/ProgressTracker.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ProgressTracker = void 0;\n/**\n * Tracks progress of one socket data transfer at a time.\n */\nclass ProgressTracker {\n    constructor() {\n        this.bytesOverall = 0;\n        this.intervalMs = 500;\n        this.onStop = noop;\n        this.onHandle = noop;\n    }\n    /**\n     * Register a new handler for progress info. Use `undefined` to disable reporting.\n     */\n    reportTo(onHandle = noop) {\n        this.onHandle = onHandle;\n    }\n    /**\n     * Start tracking transfer progress of a socket.\n     *\n     * @param socket  The socket to observe.\n     * @param name  A name associated with this progress tracking, e.g. a filename.\n     * @param type  The type of the transfer, typically \"upload\" or \"download\".\n     */\n    start(socket, name, type) {\n        let lastBytes = 0;\n        this.onStop = poll(this.intervalMs, () => {\n            const bytes = socket.bytesRead + socket.bytesWritten;\n            this.bytesOverall += bytes - lastBytes;\n            lastBytes = bytes;\n            this.onHandle({\n                name,\n                type,\n                bytes,\n                bytesOverall: this.bytesOverall\n            });\n        });\n    }\n    /**\n     * Stop tracking transfer progress.\n     */\n    stop() {\n        this.onStop(false);\n    }\n    /**\n     * Call the progress handler one more time, then stop tracking.\n     */\n    updateAndStop() {\n        this.onStop(true);\n    }\n}\nexports.ProgressTracker = ProgressTracker;\n/**\n * Starts calling a callback function at a regular interval. The first call will go out\n * immediately. The function returns a function to stop the polling.\n */\nfunction poll(intervalMs, updateFunc) {\n    const id = setInterval(updateFunc, intervalMs);\n    const stopFunc = (stopWithUpdate) => {\n        clearInterval(id);\n        if (stopWithUpdate) {\n            updateFunc();\n        }\n        // Prevent repeated calls to stop calling handler.\n        updateFunc = noop;\n    };\n    updateFunc();\n    return stopFunc;\n}\nfunction noop() { }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvUHJvZ3Jlc3NUcmFja2VyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIkQ6XFxXZWJzdGVwMlxcc2hpcG93bC1tZXJnZVxcbm9kZV9tb2R1bGVzXFxiYXNpYy1mdHBcXGRpc3RcXFByb2dyZXNzVHJhY2tlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUHJvZ3Jlc3NUcmFja2VyID0gdm9pZCAwO1xuLyoqXG4gKiBUcmFja3MgcHJvZ3Jlc3Mgb2Ygb25lIHNvY2tldCBkYXRhIHRyYW5zZmVyIGF0IGEgdGltZS5cbiAqL1xuY2xhc3MgUHJvZ3Jlc3NUcmFja2VyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5ieXRlc092ZXJhbGwgPSAwO1xuICAgICAgICB0aGlzLmludGVydmFsTXMgPSA1MDA7XG4gICAgICAgIHRoaXMub25TdG9wID0gbm9vcDtcbiAgICAgICAgdGhpcy5vbkhhbmRsZSA9IG5vb3A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgbmV3IGhhbmRsZXIgZm9yIHByb2dyZXNzIGluZm8uIFVzZSBgdW5kZWZpbmVkYCB0byBkaXNhYmxlIHJlcG9ydGluZy5cbiAgICAgKi9cbiAgICByZXBvcnRUbyhvbkhhbmRsZSA9IG5vb3ApIHtcbiAgICAgICAgdGhpcy5vbkhhbmRsZSA9IG9uSGFuZGxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdGFydCB0cmFja2luZyB0cmFuc2ZlciBwcm9ncmVzcyBvZiBhIHNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb2NrZXQgIFRoZSBzb2NrZXQgdG8gb2JzZXJ2ZS5cbiAgICAgKiBAcGFyYW0gbmFtZSAgQSBuYW1lIGFzc29jaWF0ZWQgd2l0aCB0aGlzIHByb2dyZXNzIHRyYWNraW5nLCBlLmcuIGEgZmlsZW5hbWUuXG4gICAgICogQHBhcmFtIHR5cGUgIFRoZSB0eXBlIG9mIHRoZSB0cmFuc2ZlciwgdHlwaWNhbGx5IFwidXBsb2FkXCIgb3IgXCJkb3dubG9hZFwiLlxuICAgICAqL1xuICAgIHN0YXJ0KHNvY2tldCwgbmFtZSwgdHlwZSkge1xuICAgICAgICBsZXQgbGFzdEJ5dGVzID0gMDtcbiAgICAgICAgdGhpcy5vblN0b3AgPSBwb2xsKHRoaXMuaW50ZXJ2YWxNcywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBzb2NrZXQuYnl0ZXNSZWFkICsgc29ja2V0LmJ5dGVzV3JpdHRlbjtcbiAgICAgICAgICAgIHRoaXMuYnl0ZXNPdmVyYWxsICs9IGJ5dGVzIC0gbGFzdEJ5dGVzO1xuICAgICAgICAgICAgbGFzdEJ5dGVzID0gYnl0ZXM7XG4gICAgICAgICAgICB0aGlzLm9uSGFuZGxlKHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgYnl0ZXMsXG4gICAgICAgICAgICAgICAgYnl0ZXNPdmVyYWxsOiB0aGlzLmJ5dGVzT3ZlcmFsbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTdG9wIHRyYWNraW5nIHRyYW5zZmVyIHByb2dyZXNzLlxuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMub25TdG9wKGZhbHNlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbCB0aGUgcHJvZ3Jlc3MgaGFuZGxlciBvbmUgbW9yZSB0aW1lLCB0aGVuIHN0b3AgdHJhY2tpbmcuXG4gICAgICovXG4gICAgdXBkYXRlQW5kU3RvcCgpIHtcbiAgICAgICAgdGhpcy5vblN0b3AodHJ1ZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Qcm9ncmVzc1RyYWNrZXIgPSBQcm9ncmVzc1RyYWNrZXI7XG4vKipcbiAqIFN0YXJ0cyBjYWxsaW5nIGEgY2FsbGJhY2sgZnVuY3Rpb24gYXQgYSByZWd1bGFyIGludGVydmFsLiBUaGUgZmlyc3QgY2FsbCB3aWxsIGdvIG91dFxuICogaW1tZWRpYXRlbHkuIFRoZSBmdW5jdGlvbiByZXR1cm5zIGEgZnVuY3Rpb24gdG8gc3RvcCB0aGUgcG9sbGluZy5cbiAqL1xuZnVuY3Rpb24gcG9sbChpbnRlcnZhbE1zLCB1cGRhdGVGdW5jKSB7XG4gICAgY29uc3QgaWQgPSBzZXRJbnRlcnZhbCh1cGRhdGVGdW5jLCBpbnRlcnZhbE1zKTtcbiAgICBjb25zdCBzdG9wRnVuYyA9IChzdG9wV2l0aFVwZGF0ZSkgPT4ge1xuICAgICAgICBjbGVhckludGVydmFsKGlkKTtcbiAgICAgICAgaWYgKHN0b3BXaXRoVXBkYXRlKSB7XG4gICAgICAgICAgICB1cGRhdGVGdW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUHJldmVudCByZXBlYXRlZCBjYWxscyB0byBzdG9wIGNhbGxpbmcgaGFuZGxlci5cbiAgICAgICAgdXBkYXRlRnVuYyA9IG5vb3A7XG4gICAgfTtcbiAgICB1cGRhdGVGdW5jKCk7XG4gICAgcmV0dXJuIHN0b3BGdW5jO1xufVxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/ProgressTracker.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/StringEncoding.js":
/*!*******************************************************!*\
  !*** ./node_modules/basic-ftp/dist/StringEncoding.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvU3RyaW5nRW5jb2RpbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUMiLCJzb3VyY2VzIjpbIkQ6XFxXZWJzdGVwMlxcc2hpcG93bC1tZXJnZVxcbm9kZV9tb2R1bGVzXFxiYXNpYy1mdHBcXGRpc3RcXFN0cmluZ0VuY29kaW5nLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/StringEncoding.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/StringWriter.js":
/*!*****************************************************!*\
  !*** ./node_modules/basic-ftp/dist/StringWriter.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StringWriter = void 0;\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nclass StringWriter extends stream_1.Writable {\n    constructor() {\n        super(...arguments);\n        this.buf = Buffer.alloc(0);\n    }\n    _write(chunk, _, callback) {\n        if (chunk instanceof Buffer) {\n            this.buf = Buffer.concat([this.buf, chunk]);\n            callback(null);\n        }\n        else {\n            callback(new Error(\"StringWriter expects chunks of type 'Buffer'.\"));\n        }\n    }\n    getText(encoding) {\n        return this.buf.toString(encoding);\n    }\n}\nexports.StringWriter = StringWriter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvU3RyaW5nV3JpdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG9CQUFvQjtBQUNwQixpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IiLCJzb3VyY2VzIjpbIkQ6XFxXZWJzdGVwMlxcc2hpcG93bC1tZXJnZVxcbm9kZV9tb2R1bGVzXFxiYXNpYy1mdHBcXGRpc3RcXFN0cmluZ1dyaXRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyaW5nV3JpdGVyID0gdm9pZCAwO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY2xhc3MgU3RyaW5nV3JpdGVyIGV4dGVuZHMgc3RyZWFtXzEuV3JpdGFibGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlciguLi5hcmd1bWVudHMpO1xuICAgICAgICB0aGlzLmJ1ZiA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICB9XG4gICAgX3dyaXRlKGNodW5rLCBfLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoY2h1bmsgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgIHRoaXMuYnVmID0gQnVmZmVyLmNvbmNhdChbdGhpcy5idWYsIGNodW5rXSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBFcnJvcihcIlN0cmluZ1dyaXRlciBleHBlY3RzIGNodW5rcyBvZiB0eXBlICdCdWZmZXInLlwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0VGV4dChlbmNvZGluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5idWYudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaW5nV3JpdGVyID0gU3RyaW5nV3JpdGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/StringWriter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/basic-ftp/dist/index.js ***!
  \**********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.enterPassiveModeIPv6 = exports.enterPassiveModeIPv4 = void 0;\n/**\n * Public API\n */\n__exportStar(__webpack_require__(/*! ./Client */ \"(rsc)/./node_modules/basic-ftp/dist/Client.js\"), exports);\n__exportStar(__webpack_require__(/*! ./FtpContext */ \"(rsc)/./node_modules/basic-ftp/dist/FtpContext.js\"), exports);\n__exportStar(__webpack_require__(/*! ./FileInfo */ \"(rsc)/./node_modules/basic-ftp/dist/FileInfo.js\"), exports);\n__exportStar(__webpack_require__(/*! ./parseList */ \"(rsc)/./node_modules/basic-ftp/dist/parseList.js\"), exports);\n__exportStar(__webpack_require__(/*! ./StringEncoding */ \"(rsc)/./node_modules/basic-ftp/dist/StringEncoding.js\"), exports);\nvar transfer_1 = __webpack_require__(/*! ./transfer */ \"(rsc)/./node_modules/basic-ftp/dist/transfer.js\");\nObject.defineProperty(exports, \"enterPassiveModeIPv4\", ({ enumerable: true, get: function () { return transfer_1.enterPassiveModeIPv4; } }));\nObject.defineProperty(exports, \"enterPassiveModeIPv6\", ({ enumerable: true, get: function () { return transfer_1.enterPassiveModeIPv6; } }));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsb0NBQW9DO0FBQ25EO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsNEJBQTRCO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUJBQU8sQ0FBQywrREFBVTtBQUMvQixhQUFhLG1CQUFPLENBQUMsdUVBQWM7QUFDbkMsYUFBYSxtQkFBTyxDQUFDLG1FQUFZO0FBQ2pDLGFBQWEsbUJBQU8sQ0FBQyxxRUFBYTtBQUNsQyxhQUFhLG1CQUFPLENBQUMsK0VBQWtCO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLG1FQUFZO0FBQ3JDLHdEQUF1RCxFQUFFLHFDQUFxQywyQ0FBMkMsRUFBQztBQUMxSSx3REFBdUQsRUFBRSxxQ0FBcUMsMkNBQTJDLEVBQUMiLCJzb3VyY2VzIjpbIkQ6XFxXZWJzdGVwMlxcc2hpcG93bC1tZXJnZVxcbm9kZV9tb2R1bGVzXFxiYXNpYy1mdHBcXGRpc3RcXGluZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgdmFyIGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG0sIGspO1xuICAgIGlmICghZGVzYyB8fCAoXCJnZXRcIiBpbiBkZXNjID8gIW0uX19lc01vZHVsZSA6IGRlc2Mud3JpdGFibGUgfHwgZGVzYy5jb25maWd1cmFibGUpKSB7XG4gICAgICBkZXNjID0geyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9O1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIGRlc2MpO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZXhwb3J0cywgcCkpIF9fY3JlYXRlQmluZGluZyhleHBvcnRzLCBtLCBwKTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmVudGVyUGFzc2l2ZU1vZGVJUHY2ID0gZXhwb3J0cy5lbnRlclBhc3NpdmVNb2RlSVB2NCA9IHZvaWQgMDtcbi8qKlxuICogUHVibGljIEFQSVxuICovXG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ2xpZW50XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9GdHBDb250ZXh0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9GaWxlSW5mb1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcGFyc2VMaXN0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TdHJpbmdFbmNvZGluZ1wiKSwgZXhwb3J0cyk7XG52YXIgdHJhbnNmZXJfMSA9IHJlcXVpcmUoXCIuL3RyYW5zZmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZW50ZXJQYXNzaXZlTW9kZUlQdjRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zZmVyXzEuZW50ZXJQYXNzaXZlTW9kZUlQdjQ7IH0gfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJlbnRlclBhc3NpdmVNb2RlSVB2NlwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdHJhbnNmZXJfMS5lbnRlclBhc3NpdmVNb2RlSVB2NjsgfSB9KTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/netUtils.js":
/*!*************************************************!*\
  !*** ./node_modules/basic-ftp/dist/netUtils.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ipIsPrivateV4Address = exports.upgradeSocket = exports.describeAddress = exports.describeTLS = void 0;\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\n/**\n * Returns a string describing the encryption on a given socket instance.\n */\nfunction describeTLS(socket) {\n    if (socket instanceof tls_1.TLSSocket) {\n        const protocol = socket.getProtocol();\n        return protocol ? protocol : \"Server socket or disconnected client socket\";\n    }\n    return \"No encryption\";\n}\nexports.describeTLS = describeTLS;\n/**\n * Returns a string describing the remote address of a socket.\n */\nfunction describeAddress(socket) {\n    if (socket.remoteFamily === \"IPv6\") {\n        return `[${socket.remoteAddress}]:${socket.remotePort}`;\n    }\n    return `${socket.remoteAddress}:${socket.remotePort}`;\n}\nexports.describeAddress = describeAddress;\n/**\n * Upgrade a socket connection with TLS.\n */\nfunction upgradeSocket(socket, options) {\n    return new Promise((resolve, reject) => {\n        const tlsOptions = Object.assign({}, options, {\n            socket\n        });\n        const tlsSocket = (0, tls_1.connect)(tlsOptions, () => {\n            const expectCertificate = tlsOptions.rejectUnauthorized !== false;\n            if (expectCertificate && !tlsSocket.authorized) {\n                reject(tlsSocket.authorizationError);\n            }\n            else {\n                // Remove error listener added below.\n                tlsSocket.removeAllListeners(\"error\");\n                resolve(tlsSocket);\n            }\n        }).once(\"error\", error => {\n            reject(error);\n        });\n    });\n}\nexports.upgradeSocket = upgradeSocket;\n/**\n * Returns true if an IP is a private address according to https://tools.ietf.org/html/rfc1918#section-3.\n * This will handle IPv4-mapped IPv6 addresses correctly but return false for all other IPv6 addresses.\n *\n * @param ip  The IP as a string, e.g. \"192.168.0.1\"\n */\nfunction ipIsPrivateV4Address(ip = \"\") {\n    // Handle IPv4-mapped IPv6 addresses like ::ffff:192.168.0.1\n    if (ip.startsWith(\"::ffff:\")) {\n        ip = ip.substr(7); // Strip ::ffff: prefix\n    }\n    const octets = ip.split(\".\").map(o => parseInt(o, 10));\n    return octets[0] === 10 // 10.0.0.0 - 10.255.255.255\n        || (octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31) // 172.16.0.0 - 172.31.255.255\n        || (octets[0] === 192 && octets[1] === 168) // 192.168.0.0 - 192.168.255.255\n        || ip === \"127.0.0.1\";\n}\nexports.ipIsPrivateV4Address = ipIsPrivateV4Address;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvbmV0VXRpbHMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcscUJBQXFCLEdBQUcsdUJBQXVCLEdBQUcsbUJBQW1CO0FBQ3BHLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLHFCQUFxQixJQUFJLGtCQUFrQjtBQUM5RDtBQUNBLGNBQWMscUJBQXFCLEdBQUcsa0JBQWtCO0FBQ3hEO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiIsInNvdXJjZXMiOlsiRDpcXFdlYnN0ZXAyXFxzaGlwb3dsLW1lcmdlXFxub2RlX21vZHVsZXNcXGJhc2ljLWZ0cFxcZGlzdFxcbmV0VXRpbHMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlwSXNQcml2YXRlVjRBZGRyZXNzID0gZXhwb3J0cy51cGdyYWRlU29ja2V0ID0gZXhwb3J0cy5kZXNjcmliZUFkZHJlc3MgPSBleHBvcnRzLmRlc2NyaWJlVExTID0gdm9pZCAwO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIGVuY3J5cHRpb24gb24gYSBnaXZlbiBzb2NrZXQgaW5zdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIGRlc2NyaWJlVExTKHNvY2tldCkge1xuICAgIGlmIChzb2NrZXQgaW5zdGFuY2VvZiB0bHNfMS5UTFNTb2NrZXQpIHtcbiAgICAgICAgY29uc3QgcHJvdG9jb2wgPSBzb2NrZXQuZ2V0UHJvdG9jb2woKTtcbiAgICAgICAgcmV0dXJuIHByb3RvY29sID8gcHJvdG9jb2wgOiBcIlNlcnZlciBzb2NrZXQgb3IgZGlzY29ubmVjdGVkIGNsaWVudCBzb2NrZXRcIjtcbiAgICB9XG4gICAgcmV0dXJuIFwiTm8gZW5jcnlwdGlvblwiO1xufVxuZXhwb3J0cy5kZXNjcmliZVRMUyA9IGRlc2NyaWJlVExTO1xuLyoqXG4gKiBSZXR1cm5zIGEgc3RyaW5nIGRlc2NyaWJpbmcgdGhlIHJlbW90ZSBhZGRyZXNzIG9mIGEgc29ja2V0LlxuICovXG5mdW5jdGlvbiBkZXNjcmliZUFkZHJlc3Moc29ja2V0KSB7XG4gICAgaWYgKHNvY2tldC5yZW1vdGVGYW1pbHkgPT09IFwiSVB2NlwiKSB7XG4gICAgICAgIHJldHVybiBgWyR7c29ja2V0LnJlbW90ZUFkZHJlc3N9XToke3NvY2tldC5yZW1vdGVQb3J0fWA7XG4gICAgfVxuICAgIHJldHVybiBgJHtzb2NrZXQucmVtb3RlQWRkcmVzc306JHtzb2NrZXQucmVtb3RlUG9ydH1gO1xufVxuZXhwb3J0cy5kZXNjcmliZUFkZHJlc3MgPSBkZXNjcmliZUFkZHJlc3M7XG4vKipcbiAqIFVwZ3JhZGUgYSBzb2NrZXQgY29ubmVjdGlvbiB3aXRoIFRMUy5cbiAqL1xuZnVuY3Rpb24gdXBncmFkZVNvY2tldChzb2NrZXQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICBjb25zdCB0bHNPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgICAgICAgc29ja2V0XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0bHNTb2NrZXQgPSAoMCwgdGxzXzEuY29ubmVjdCkodGxzT3B0aW9ucywgKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZXhwZWN0Q2VydGlmaWNhdGUgPSB0bHNPcHRpb25zLnJlamVjdFVuYXV0aG9yaXplZCAhPT0gZmFsc2U7XG4gICAgICAgICAgICBpZiAoZXhwZWN0Q2VydGlmaWNhdGUgJiYgIXRsc1NvY2tldC5hdXRob3JpemVkKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KHRsc1NvY2tldC5hdXRob3JpemF0aW9uRXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gUmVtb3ZlIGVycm9yIGxpc3RlbmVyIGFkZGVkIGJlbG93LlxuICAgICAgICAgICAgICAgIHRsc1NvY2tldC5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJlcnJvclwiKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlKHRsc1NvY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pLm9uY2UoXCJlcnJvclwiLCBlcnJvciA9PiB7XG4gICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydHMudXBncmFkZVNvY2tldCA9IHVwZ3JhZGVTb2NrZXQ7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhbiBJUCBpcyBhIHByaXZhdGUgYWRkcmVzcyBhY2NvcmRpbmcgdG8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzE5MTgjc2VjdGlvbi0zLlxuICogVGhpcyB3aWxsIGhhbmRsZSBJUHY0LW1hcHBlZCBJUHY2IGFkZHJlc3NlcyBjb3JyZWN0bHkgYnV0IHJldHVybiBmYWxzZSBmb3IgYWxsIG90aGVyIElQdjYgYWRkcmVzc2VzLlxuICpcbiAqIEBwYXJhbSBpcCAgVGhlIElQIGFzIGEgc3RyaW5nLCBlLmcuIFwiMTkyLjE2OC4wLjFcIlxuICovXG5mdW5jdGlvbiBpcElzUHJpdmF0ZVY0QWRkcmVzcyhpcCA9IFwiXCIpIHtcbiAgICAvLyBIYW5kbGUgSVB2NC1tYXBwZWQgSVB2NiBhZGRyZXNzZXMgbGlrZSA6OmZmZmY6MTkyLjE2OC4wLjFcbiAgICBpZiAoaXAuc3RhcnRzV2l0aChcIjo6ZmZmZjpcIikpIHtcbiAgICAgICAgaXAgPSBpcC5zdWJzdHIoNyk7IC8vIFN0cmlwIDo6ZmZmZjogcHJlZml4XG4gICAgfVxuICAgIGNvbnN0IG9jdGV0cyA9IGlwLnNwbGl0KFwiLlwiKS5tYXAobyA9PiBwYXJzZUludChvLCAxMCkpO1xuICAgIHJldHVybiBvY3RldHNbMF0gPT09IDEwIC8vIDEwLjAuMC4wIC0gMTAuMjU1LjI1NS4yNTVcbiAgICAgICAgfHwgKG9jdGV0c1swXSA9PT0gMTcyICYmIG9jdGV0c1sxXSA+PSAxNiAmJiBvY3RldHNbMV0gPD0gMzEpIC8vIDE3Mi4xNi4wLjAgLSAxNzIuMzEuMjU1LjI1NVxuICAgICAgICB8fCAob2N0ZXRzWzBdID09PSAxOTIgJiYgb2N0ZXRzWzFdID09PSAxNjgpIC8vIDE5Mi4xNjguMC4wIC0gMTkyLjE2OC4yNTUuMjU1XG4gICAgICAgIHx8IGlwID09PSBcIjEyNy4wLjAuMVwiO1xufVxuZXhwb3J0cy5pcElzUHJpdmF0ZVY0QWRkcmVzcyA9IGlwSXNQcml2YXRlVjRBZGRyZXNzO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/netUtils.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/parseControlResponse.js":
/*!*************************************************************!*\
  !*** ./node_modules/basic-ftp/dist/parseControlResponse.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.positiveIntermediate = exports.positiveCompletion = exports.isMultiline = exports.isSingleLine = exports.parseControlResponse = void 0;\nconst LF = \"\\n\";\n/**\n * Parse an FTP control response as a collection of messages. A message is a complete\n * single- or multiline response. A response can also contain multiple multiline responses\n * that will each be represented by a message. A response can also be incomplete\n * and be completed on the next incoming data chunk for which case this function also\n * describes a `rest`. This function converts all CRLF to LF.\n */\nfunction parseControlResponse(text) {\n    const lines = text.split(/\\r?\\n/).filter(isNotBlank);\n    const messages = [];\n    let startAt = 0;\n    let tokenRegex;\n    for (let i = 0; i < lines.length; i++) {\n        const line = lines[i];\n        // No group has been opened.\n        if (!tokenRegex) {\n            if (isMultiline(line)) {\n                // Open a group by setting an expected token.\n                const token = line.substr(0, 3);\n                tokenRegex = new RegExp(`^${token}(?:$| )`);\n                startAt = i;\n            }\n            else if (isSingleLine(line)) {\n                // Single lines can be grouped immediately.\n                messages.push(line);\n            }\n        }\n        // Group has been opened, expect closing token.\n        else if (tokenRegex.test(line)) {\n            tokenRegex = undefined;\n            messages.push(lines.slice(startAt, i + 1).join(LF));\n        }\n    }\n    // The last group might not have been closed, report it as a rest.\n    const rest = tokenRegex ? lines.slice(startAt).join(LF) + LF : \"\";\n    return { messages, rest };\n}\nexports.parseControlResponse = parseControlResponse;\nfunction isSingleLine(line) {\n    return /^\\d\\d\\d(?:$| )/.test(line);\n}\nexports.isSingleLine = isSingleLine;\nfunction isMultiline(line) {\n    return /^\\d\\d\\d-/.test(line);\n}\nexports.isMultiline = isMultiline;\n/**\n * Return true if an FTP return code describes a positive completion.\n */\nfunction positiveCompletion(code) {\n    return code >= 200 && code < 300;\n}\nexports.positiveCompletion = positiveCompletion;\n/**\n * Return true if an FTP return code describes a positive intermediate response.\n */\nfunction positiveIntermediate(code) {\n    return code >= 300 && code < 400;\n}\nexports.positiveIntermediate = positiveIntermediate;\nfunction isNotBlank(str) {\n    return str.trim() !== \"\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvcGFyc2VDb250cm9sUmVzcG9uc2UuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNEJBQTRCLEdBQUcsMEJBQTBCLEdBQUcsbUJBQW1CLEdBQUcsb0JBQW9CLEdBQUcsNEJBQTRCO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsTUFBTTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXFdlYnN0ZXAyXFxzaGlwb3dsLW1lcmdlXFxub2RlX21vZHVsZXNcXGJhc2ljLWZ0cFxcZGlzdFxccGFyc2VDb250cm9sUmVzcG9uc2UuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBvc2l0aXZlSW50ZXJtZWRpYXRlID0gZXhwb3J0cy5wb3NpdGl2ZUNvbXBsZXRpb24gPSBleHBvcnRzLmlzTXVsdGlsaW5lID0gZXhwb3J0cy5pc1NpbmdsZUxpbmUgPSBleHBvcnRzLnBhcnNlQ29udHJvbFJlc3BvbnNlID0gdm9pZCAwO1xuY29uc3QgTEYgPSBcIlxcblwiO1xuLyoqXG4gKiBQYXJzZSBhbiBGVFAgY29udHJvbCByZXNwb25zZSBhcyBhIGNvbGxlY3Rpb24gb2YgbWVzc2FnZXMuIEEgbWVzc2FnZSBpcyBhIGNvbXBsZXRlXG4gKiBzaW5nbGUtIG9yIG11bHRpbGluZSByZXNwb25zZS4gQSByZXNwb25zZSBjYW4gYWxzbyBjb250YWluIG11bHRpcGxlIG11bHRpbGluZSByZXNwb25zZXNcbiAqIHRoYXQgd2lsbCBlYWNoIGJlIHJlcHJlc2VudGVkIGJ5IGEgbWVzc2FnZS4gQSByZXNwb25zZSBjYW4gYWxzbyBiZSBpbmNvbXBsZXRlXG4gKiBhbmQgYmUgY29tcGxldGVkIG9uIHRoZSBuZXh0IGluY29taW5nIGRhdGEgY2h1bmsgZm9yIHdoaWNoIGNhc2UgdGhpcyBmdW5jdGlvbiBhbHNvXG4gKiBkZXNjcmliZXMgYSBgcmVzdGAuIFRoaXMgZnVuY3Rpb24gY29udmVydHMgYWxsIENSTEYgdG8gTEYuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlQ29udHJvbFJlc3BvbnNlKHRleHQpIHtcbiAgICBjb25zdCBsaW5lcyA9IHRleHQuc3BsaXQoL1xccj9cXG4vKS5maWx0ZXIoaXNOb3RCbGFuayk7XG4gICAgY29uc3QgbWVzc2FnZXMgPSBbXTtcbiAgICBsZXQgc3RhcnRBdCA9IDA7XG4gICAgbGV0IHRva2VuUmVnZXg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICAgIC8vIE5vIGdyb3VwIGhhcyBiZWVuIG9wZW5lZC5cbiAgICAgICAgaWYgKCF0b2tlblJlZ2V4KSB7XG4gICAgICAgICAgICBpZiAoaXNNdWx0aWxpbmUobGluZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBPcGVuIGEgZ3JvdXAgYnkgc2V0dGluZyBhbiBleHBlY3RlZCB0b2tlbi5cbiAgICAgICAgICAgICAgICBjb25zdCB0b2tlbiA9IGxpbmUuc3Vic3RyKDAsIDMpO1xuICAgICAgICAgICAgICAgIHRva2VuUmVnZXggPSBuZXcgUmVnRXhwKGBeJHt0b2tlbn0oPzokfCApYCk7XG4gICAgICAgICAgICAgICAgc3RhcnRBdCA9IGk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc1NpbmdsZUxpbmUobGluZSkpIHtcbiAgICAgICAgICAgICAgICAvLyBTaW5nbGUgbGluZXMgY2FuIGJlIGdyb3VwZWQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgICAgbWVzc2FnZXMucHVzaChsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBHcm91cCBoYXMgYmVlbiBvcGVuZWQsIGV4cGVjdCBjbG9zaW5nIHRva2VuLlxuICAgICAgICBlbHNlIGlmICh0b2tlblJlZ2V4LnRlc3QobGluZSkpIHtcbiAgICAgICAgICAgIHRva2VuUmVnZXggPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGxpbmVzLnNsaWNlKHN0YXJ0QXQsIGkgKyAxKS5qb2luKExGKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gVGhlIGxhc3QgZ3JvdXAgbWlnaHQgbm90IGhhdmUgYmVlbiBjbG9zZWQsIHJlcG9ydCBpdCBhcyBhIHJlc3QuXG4gICAgY29uc3QgcmVzdCA9IHRva2VuUmVnZXggPyBsaW5lcy5zbGljZShzdGFydEF0KS5qb2luKExGKSArIExGIDogXCJcIjtcbiAgICByZXR1cm4geyBtZXNzYWdlcywgcmVzdCB9O1xufVxuZXhwb3J0cy5wYXJzZUNvbnRyb2xSZXNwb25zZSA9IHBhcnNlQ29udHJvbFJlc3BvbnNlO1xuZnVuY3Rpb24gaXNTaW5nbGVMaW5lKGxpbmUpIHtcbiAgICByZXR1cm4gL15cXGRcXGRcXGQoPzokfCApLy50ZXN0KGxpbmUpO1xufVxuZXhwb3J0cy5pc1NpbmdsZUxpbmUgPSBpc1NpbmdsZUxpbmU7XG5mdW5jdGlvbiBpc011bHRpbGluZShsaW5lKSB7XG4gICAgcmV0dXJuIC9eXFxkXFxkXFxkLS8udGVzdChsaW5lKTtcbn1cbmV4cG9ydHMuaXNNdWx0aWxpbmUgPSBpc011bHRpbGluZTtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYW4gRlRQIHJldHVybiBjb2RlIGRlc2NyaWJlcyBhIHBvc2l0aXZlIGNvbXBsZXRpb24uXG4gKi9cbmZ1bmN0aW9uIHBvc2l0aXZlQ29tcGxldGlvbihjb2RlKSB7XG4gICAgcmV0dXJuIGNvZGUgPj0gMjAwICYmIGNvZGUgPCAzMDA7XG59XG5leHBvcnRzLnBvc2l0aXZlQ29tcGxldGlvbiA9IHBvc2l0aXZlQ29tcGxldGlvbjtcbi8qKlxuICogUmV0dXJuIHRydWUgaWYgYW4gRlRQIHJldHVybiBjb2RlIGRlc2NyaWJlcyBhIHBvc2l0aXZlIGludGVybWVkaWF0ZSByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gcG9zaXRpdmVJbnRlcm1lZGlhdGUoY29kZSkge1xuICAgIHJldHVybiBjb2RlID49IDMwMCAmJiBjb2RlIDwgNDAwO1xufVxuZXhwb3J0cy5wb3NpdGl2ZUludGVybWVkaWF0ZSA9IHBvc2l0aXZlSW50ZXJtZWRpYXRlO1xuZnVuY3Rpb24gaXNOb3RCbGFuayhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKSAhPT0gXCJcIjtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/parseControlResponse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/parseList.js":
/*!**************************************************!*\
  !*** ./node_modules/basic-ftp/dist/parseList.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseList = void 0;\nconst dosParser = __importStar(__webpack_require__(/*! ./parseListDOS */ \"(rsc)/./node_modules/basic-ftp/dist/parseListDOS.js\"));\nconst unixParser = __importStar(__webpack_require__(/*! ./parseListUnix */ \"(rsc)/./node_modules/basic-ftp/dist/parseListUnix.js\"));\nconst mlsdParser = __importStar(__webpack_require__(/*! ./parseListMLSD */ \"(rsc)/./node_modules/basic-ftp/dist/parseListMLSD.js\"));\n/**\n * Available directory listing parsers. These are candidates that will be tested\n * in the order presented. The first candidate will be used to parse the whole list.\n */\nconst availableParsers = [\n    dosParser,\n    unixParser,\n    mlsdParser // Keep MLSD last, may accept filename only\n];\nfunction firstCompatibleParser(line, parsers) {\n    return parsers.find(parser => parser.testLine(line) === true);\n}\nfunction isNotBlank(str) {\n    return str.trim() !== \"\";\n}\nfunction isNotMeta(str) {\n    return !str.startsWith(\"total\");\n}\nconst REGEX_NEWLINE = /\\r?\\n/;\n/**\n * Parse raw directory listing.\n */\nfunction parseList(rawList) {\n    const lines = rawList\n        .split(REGEX_NEWLINE)\n        .filter(isNotBlank)\n        .filter(isNotMeta);\n    if (lines.length === 0) {\n        return [];\n    }\n    const testLine = lines[lines.length - 1];\n    const parser = firstCompatibleParser(testLine, availableParsers);\n    if (!parser) {\n        throw new Error(\"This library only supports MLSD, Unix- or DOS-style directory listing. Your FTP server seems to be using another format. You can see the transmitted listing when setting `client.ftp.verbose = true`. You can then provide a custom parser to `client.parseList`, see the documentation for details.\");\n    }\n    const files = lines\n        .map(parser.parseLine)\n        .filter((info) => info !== undefined);\n    return parser.transformList(files);\n}\nexports.parseList = parseList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvcGFyc2VMaXN0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSwwQ0FBMEMsNEJBQTRCO0FBQ3RFLENBQUM7QUFDRDtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUI7QUFDakIsK0JBQStCLG1CQUFPLENBQUMsMkVBQWdCO0FBQ3ZELGdDQUFnQyxtQkFBTyxDQUFDLDZFQUFpQjtBQUN6RCxnQ0FBZ0MsbUJBQU8sQ0FBQyw2RUFBaUI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIiLCJzb3VyY2VzIjpbIkQ6XFxXZWJzdGVwMlxcc2hpcG93bC1tZXJnZVxcbm9kZV9tb2R1bGVzXFxiYXNpYy1mdHBcXGRpc3RcXHBhcnNlTGlzdC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIHZhciBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtLCBrKTtcbiAgICBpZiAoIWRlc2MgfHwgKFwiZ2V0XCIgaW4gZGVzYyA/ICFtLl9fZXNNb2R1bGUgOiBkZXNjLndyaXRhYmxlIHx8IGRlc2MuY29uZmlndXJhYmxlKSkge1xuICAgICAgZGVzYyA9IHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfTtcbiAgICB9XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCBkZXNjKTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wYXJzZUxpc3QgPSB2b2lkIDA7XG5jb25zdCBkb3NQYXJzZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcGFyc2VMaXN0RE9TXCIpKTtcbmNvbnN0IHVuaXhQYXJzZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vcGFyc2VMaXN0VW5peFwiKSk7XG5jb25zdCBtbHNkUGFyc2VyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3BhcnNlTGlzdE1MU0RcIikpO1xuLyoqXG4gKiBBdmFpbGFibGUgZGlyZWN0b3J5IGxpc3RpbmcgcGFyc2Vycy4gVGhlc2UgYXJlIGNhbmRpZGF0ZXMgdGhhdCB3aWxsIGJlIHRlc3RlZFxuICogaW4gdGhlIG9yZGVyIHByZXNlbnRlZC4gVGhlIGZpcnN0IGNhbmRpZGF0ZSB3aWxsIGJlIHVzZWQgdG8gcGFyc2UgdGhlIHdob2xlIGxpc3QuXG4gKi9cbmNvbnN0IGF2YWlsYWJsZVBhcnNlcnMgPSBbXG4gICAgZG9zUGFyc2VyLFxuICAgIHVuaXhQYXJzZXIsXG4gICAgbWxzZFBhcnNlciAvLyBLZWVwIE1MU0QgbGFzdCwgbWF5IGFjY2VwdCBmaWxlbmFtZSBvbmx5XG5dO1xuZnVuY3Rpb24gZmlyc3RDb21wYXRpYmxlUGFyc2VyKGxpbmUsIHBhcnNlcnMpIHtcbiAgICByZXR1cm4gcGFyc2Vycy5maW5kKHBhcnNlciA9PiBwYXJzZXIudGVzdExpbmUobGluZSkgPT09IHRydWUpO1xufVxuZnVuY3Rpb24gaXNOb3RCbGFuayhzdHIpIHtcbiAgICByZXR1cm4gc3RyLnRyaW0oKSAhPT0gXCJcIjtcbn1cbmZ1bmN0aW9uIGlzTm90TWV0YShzdHIpIHtcbiAgICByZXR1cm4gIXN0ci5zdGFydHNXaXRoKFwidG90YWxcIik7XG59XG5jb25zdCBSRUdFWF9ORVdMSU5FID0gL1xccj9cXG4vO1xuLyoqXG4gKiBQYXJzZSByYXcgZGlyZWN0b3J5IGxpc3RpbmcuXG4gKi9cbmZ1bmN0aW9uIHBhcnNlTGlzdChyYXdMaXN0KSB7XG4gICAgY29uc3QgbGluZXMgPSByYXdMaXN0XG4gICAgICAgIC5zcGxpdChSRUdFWF9ORVdMSU5FKVxuICAgICAgICAuZmlsdGVyKGlzTm90QmxhbmspXG4gICAgICAgIC5maWx0ZXIoaXNOb3RNZXRhKTtcbiAgICBpZiAobGluZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3QgdGVzdExpbmUgPSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXTtcbiAgICBjb25zdCBwYXJzZXIgPSBmaXJzdENvbXBhdGlibGVQYXJzZXIodGVzdExpbmUsIGF2YWlsYWJsZVBhcnNlcnMpO1xuICAgIGlmICghcGFyc2VyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRoaXMgbGlicmFyeSBvbmx5IHN1cHBvcnRzIE1MU0QsIFVuaXgtIG9yIERPUy1zdHlsZSBkaXJlY3RvcnkgbGlzdGluZy4gWW91ciBGVFAgc2VydmVyIHNlZW1zIHRvIGJlIHVzaW5nIGFub3RoZXIgZm9ybWF0LiBZb3UgY2FuIHNlZSB0aGUgdHJhbnNtaXR0ZWQgbGlzdGluZyB3aGVuIHNldHRpbmcgYGNsaWVudC5mdHAudmVyYm9zZSA9IHRydWVgLiBZb3UgY2FuIHRoZW4gcHJvdmlkZSBhIGN1c3RvbSBwYXJzZXIgdG8gYGNsaWVudC5wYXJzZUxpc3RgLCBzZWUgdGhlIGRvY3VtZW50YXRpb24gZm9yIGRldGFpbHMuXCIpO1xuICAgIH1cbiAgICBjb25zdCBmaWxlcyA9IGxpbmVzXG4gICAgICAgIC5tYXAocGFyc2VyLnBhcnNlTGluZSlcbiAgICAgICAgLmZpbHRlcigoaW5mbykgPT4gaW5mbyAhPT0gdW5kZWZpbmVkKTtcbiAgICByZXR1cm4gcGFyc2VyLnRyYW5zZm9ybUxpc3QoZmlsZXMpO1xufVxuZXhwb3J0cy5wYXJzZUxpc3QgPSBwYXJzZUxpc3Q7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/parseList.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/parseListDOS.js":
/*!*****************************************************!*\
  !*** ./node_modules/basic-ftp/dist/parseListDOS.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.transformList = exports.parseLine = exports.testLine = void 0;\nconst FileInfo_1 = __webpack_require__(/*! ./FileInfo */ \"(rsc)/./node_modules/basic-ftp/dist/FileInfo.js\");\n/**\n * This parser is based on the FTP client library source code in Apache Commons Net provided\n * under the Apache 2.0 license. It has been simplified and rewritten to better fit the Javascript language.\n *\n * https://github.com/apache/commons-net/blob/master/src/main/java/org/apache/commons/net/ftp/parser/NTFTPEntryParser.java\n */\nconst RE_LINE = new RegExp(\"(\\\\S+)\\\\s+(\\\\S+)\\\\s+\" // MM-dd-yy whitespace hh:mma|kk:mm swallow trailing spaces\n    + \"(?:(<DIR>)|([0-9]+))\\\\s+\" // <DIR> or ddddd swallow trailing spaces\n    + \"(\\\\S.*)\" // First non-space followed by rest of line (name)\n);\n/**\n * Returns true if a given line might be a DOS-style listing.\n *\n * - Example: `12-05-96  05:03PM       <DIR>          myDir`\n */\nfunction testLine(line) {\n    return /^\\d{2}/.test(line) && RE_LINE.test(line);\n}\nexports.testLine = testLine;\n/**\n * Parse a single line of a DOS-style directory listing.\n */\nfunction parseLine(line) {\n    const groups = line.match(RE_LINE);\n    if (groups === null) {\n        return undefined;\n    }\n    const name = groups[5];\n    if (name === \".\" || name === \"..\") { // Ignore parent directory links\n        return undefined;\n    }\n    const file = new FileInfo_1.FileInfo(name);\n    const fileType = groups[3];\n    if (fileType === \"<DIR>\") {\n        file.type = FileInfo_1.FileType.Directory;\n        file.size = 0;\n    }\n    else {\n        file.type = FileInfo_1.FileType.File;\n        file.size = parseInt(groups[4], 10);\n    }\n    file.rawModifiedAt = groups[1] + \" \" + groups[2];\n    return file;\n}\nexports.parseLine = parseLine;\nfunction transformList(files) {\n    return files;\n}\nexports.transformList = transformList;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvcGFyc2VMaXN0RE9TLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHFCQUFxQixHQUFHLGlCQUFpQixHQUFHLGdCQUFnQjtBQUM1RCxtQkFBbUIsbUJBQU8sQ0FBQyxtRUFBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixFQUFFO0FBQ2xCO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCIiwic291cmNlcyI6WyJEOlxcV2Vic3RlcDJcXHNoaXBvd2wtbWVyZ2VcXG5vZGVfbW9kdWxlc1xcYmFzaWMtZnRwXFxkaXN0XFxwYXJzZUxpc3RET1MuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnRyYW5zZm9ybUxpc3QgPSBleHBvcnRzLnBhcnNlTGluZSA9IGV4cG9ydHMudGVzdExpbmUgPSB2b2lkIDA7XG5jb25zdCBGaWxlSW5mb18xID0gcmVxdWlyZShcIi4vRmlsZUluZm9cIik7XG4vKipcbiAqIFRoaXMgcGFyc2VyIGlzIGJhc2VkIG9uIHRoZSBGVFAgY2xpZW50IGxpYnJhcnkgc291cmNlIGNvZGUgaW4gQXBhY2hlIENvbW1vbnMgTmV0IHByb3ZpZGVkXG4gKiB1bmRlciB0aGUgQXBhY2hlIDIuMCBsaWNlbnNlLiBJdCBoYXMgYmVlbiBzaW1wbGlmaWVkIGFuZCByZXdyaXR0ZW4gdG8gYmV0dGVyIGZpdCB0aGUgSmF2YXNjcmlwdCBsYW5ndWFnZS5cbiAqXG4gKiBodHRwczovL2dpdGh1Yi5jb20vYXBhY2hlL2NvbW1vbnMtbmV0L2Jsb2IvbWFzdGVyL3NyYy9tYWluL2phdmEvb3JnL2FwYWNoZS9jb21tb25zL25ldC9mdHAvcGFyc2VyL05URlRQRW50cnlQYXJzZXIuamF2YVxuICovXG5jb25zdCBSRV9MSU5FID0gbmV3IFJlZ0V4cChcIihcXFxcUyspXFxcXHMrKFxcXFxTKylcXFxccytcIiAvLyBNTS1kZC15eSB3aGl0ZXNwYWNlIGhoOm1tYXxrazptbSBzd2FsbG93IHRyYWlsaW5nIHNwYWNlc1xuICAgICsgXCIoPzooPERJUj4pfChbMC05XSspKVxcXFxzK1wiIC8vIDxESVI+IG9yIGRkZGRkIHN3YWxsb3cgdHJhaWxpbmcgc3BhY2VzXG4gICAgKyBcIihcXFxcUy4qKVwiIC8vIEZpcnN0IG5vbi1zcGFjZSBmb2xsb3dlZCBieSByZXN0IG9mIGxpbmUgKG5hbWUpXG4pO1xuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBsaW5lIG1pZ2h0IGJlIGEgRE9TLXN0eWxlIGxpc3RpbmcuXG4gKlxuICogLSBFeGFtcGxlOiBgMTItMDUtOTYgIDA1OjAzUE0gICAgICAgPERJUj4gICAgICAgICAgbXlEaXJgXG4gKi9cbmZ1bmN0aW9uIHRlc3RMaW5lKGxpbmUpIHtcbiAgICByZXR1cm4gL15cXGR7Mn0vLnRlc3QobGluZSkgJiYgUkVfTElORS50ZXN0KGxpbmUpO1xufVxuZXhwb3J0cy50ZXN0TGluZSA9IHRlc3RMaW5lO1xuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBsaW5lIG9mIGEgRE9TLXN0eWxlIGRpcmVjdG9yeSBsaXN0aW5nLlxuICovXG5mdW5jdGlvbiBwYXJzZUxpbmUobGluZSkge1xuICAgIGNvbnN0IGdyb3VwcyA9IGxpbmUubWF0Y2goUkVfTElORSk7XG4gICAgaWYgKGdyb3VwcyA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBuYW1lID0gZ3JvdXBzWzVdO1xuICAgIGlmIChuYW1lID09PSBcIi5cIiB8fCBuYW1lID09PSBcIi4uXCIpIHsgLy8gSWdub3JlIHBhcmVudCBkaXJlY3RvcnkgbGlua3NcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgZmlsZSA9IG5ldyBGaWxlSW5mb18xLkZpbGVJbmZvKG5hbWUpO1xuICAgIGNvbnN0IGZpbGVUeXBlID0gZ3JvdXBzWzNdO1xuICAgIGlmIChmaWxlVHlwZSA9PT0gXCI8RElSPlwiKSB7XG4gICAgICAgIGZpbGUudHlwZSA9IEZpbGVJbmZvXzEuRmlsZVR5cGUuRGlyZWN0b3J5O1xuICAgICAgICBmaWxlLnNpemUgPSAwO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZmlsZS50eXBlID0gRmlsZUluZm9fMS5GaWxlVHlwZS5GaWxlO1xuICAgICAgICBmaWxlLnNpemUgPSBwYXJzZUludChncm91cHNbNF0sIDEwKTtcbiAgICB9XG4gICAgZmlsZS5yYXdNb2RpZmllZEF0ID0gZ3JvdXBzWzFdICsgXCIgXCIgKyBncm91cHNbMl07XG4gICAgcmV0dXJuIGZpbGU7XG59XG5leHBvcnRzLnBhcnNlTGluZSA9IHBhcnNlTGluZTtcbmZ1bmN0aW9uIHRyYW5zZm9ybUxpc3QoZmlsZXMpIHtcbiAgICByZXR1cm4gZmlsZXM7XG59XG5leHBvcnRzLnRyYW5zZm9ybUxpc3QgPSB0cmFuc2Zvcm1MaXN0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/parseListDOS.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/parseListMLSD.js":
/*!******************************************************!*\
  !*** ./node_modules/basic-ftp/dist/parseListMLSD.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.parseMLSxDate = exports.transformList = exports.parseLine = exports.testLine = void 0;\nconst FileInfo_1 = __webpack_require__(/*! ./FileInfo */ \"(rsc)/./node_modules/basic-ftp/dist/FileInfo.js\");\nfunction parseSize(value, info) {\n    info.size = parseInt(value, 10);\n}\n/**\n * Parsers for MLSD facts.\n */\nconst factHandlersByName = {\n    \"size\": parseSize, // File size\n    \"sizd\": parseSize, // Directory size\n    \"unique\": (value, info) => {\n        info.uniqueID = value;\n    },\n    \"modify\": (value, info) => {\n        info.modifiedAt = parseMLSxDate(value);\n        info.rawModifiedAt = info.modifiedAt.toISOString();\n    },\n    \"type\": (value, info) => {\n        // There seems to be confusion on how to handle symbolic links for Unix. RFC 3659 doesn't describe\n        // this but mentions some examples using the syntax `type=OS.unix=slink:<target>`. But according to\n        // an entry in the Errata (https://www.rfc-editor.org/errata/eid1500) this syntax can't be valid.\n        // Instead it proposes to use `type=OS.unix=symlink` and to then list the actual target of the\n        // symbolic link as another entry in the directory listing. The unique identifiers can then be used\n        // to derive the connection between link(s) and target. We'll have to handle both cases as there\n        // are differing opinions on how to deal with this. Here are some links on this topic:\n        // - ProFTPD source: https://github.com/proftpd/proftpd/blob/56e6dfa598cbd4ef5c6cba439bcbcd53a63e3b21/modules/mod_facts.c#L531\n        // - ProFTPD bug: http://bugs.proftpd.org/show_bug.cgi?id=3318\n        // - ProFTPD statement: http://www.proftpd.org/docs/modules/mod_facts.html\n        // â€“ FileZilla bug: https://trac.filezilla-project.org/ticket/9310\n        if (value.startsWith(\"OS.unix=slink\")) {\n            info.type = FileInfo_1.FileType.SymbolicLink;\n            info.link = value.substr(value.indexOf(\":\") + 1);\n            return 1 /* FactHandlerResult.Continue */;\n        }\n        switch (value) {\n            case \"file\":\n                info.type = FileInfo_1.FileType.File;\n                break;\n            case \"dir\":\n                info.type = FileInfo_1.FileType.Directory;\n                break;\n            case \"OS.unix=symlink\":\n                info.type = FileInfo_1.FileType.SymbolicLink;\n                // The target of the symbolic link might be defined in another line in the directory listing.\n                // We'll handle this in `transformList()` below.\n                break;\n            case \"cdir\": // Current directory being listed\n            case \"pdir\": // Parent directory\n                return 2 /* FactHandlerResult.IgnoreFile */; // Don't include these entries in the listing\n            default:\n                info.type = FileInfo_1.FileType.Unknown;\n        }\n        return 1 /* FactHandlerResult.Continue */;\n    },\n    \"unix.mode\": (value, info) => {\n        const digits = value.substr(-3);\n        info.permissions = {\n            user: parseInt(digits[0], 10),\n            group: parseInt(digits[1], 10),\n            world: parseInt(digits[2], 10)\n        };\n    },\n    \"unix.ownername\": (value, info) => {\n        info.user = value;\n    },\n    \"unix.owner\": (value, info) => {\n        if (info.user === undefined)\n            info.user = value;\n    },\n    get \"unix.uid\"() {\n        return this[\"unix.owner\"];\n    },\n    \"unix.groupname\": (value, info) => {\n        info.group = value;\n    },\n    \"unix.group\": (value, info) => {\n        if (info.group === undefined)\n            info.group = value;\n    },\n    get \"unix.gid\"() {\n        return this[\"unix.group\"];\n    }\n    // Regarding the fact \"perm\":\n    // We don't handle permission information stored in \"perm\" because its information is conceptually\n    // different from what users of FTP clients usually associate with \"permissions\". Those that have\n    // some expectations (and probably want to edit them with a SITE command) often unknowingly expect\n    // the Unix permission system. The information passed by \"perm\" describes what FTP commands can be\n    // executed with a file/directory. But even this can be either incomplete or just meant as a \"guide\"\n    // as the spec mentions. From https://tools.ietf.org/html/rfc3659#section-7.5.5: \"The permissions are\n    // described here as they apply to FTP commands. They may not map easily into particular permissions\n    // available on the server's operating system.\" The parser by Apache Commons tries to translate these\n    // to Unix permissions â€“ this is misleading users and might not even be correct.\n};\n/**\n * Split a string once at the first position of a delimiter. For example\n * `splitStringOnce(\"a b c d\", \" \")` returns `[\"a\", \"b c d\"]`.\n */\nfunction splitStringOnce(str, delimiter) {\n    const pos = str.indexOf(delimiter);\n    const a = str.substr(0, pos);\n    const b = str.substr(pos + delimiter.length);\n    return [a, b];\n}\n/**\n * Returns true if a given line might be part of an MLSD listing.\n *\n * - Example 1: `size=15227;type=dir;perm=el;modify=20190419065730; test one`\n * - Example 2: ` file name` (leading space)\n */\nfunction testLine(line) {\n    return /^\\S+=\\S+;/.test(line) || line.startsWith(\" \");\n}\nexports.testLine = testLine;\n/**\n * Parse single line as MLSD listing, see specification at https://tools.ietf.org/html/rfc3659#section-7.\n */\nfunction parseLine(line) {\n    const [packedFacts, name] = splitStringOnce(line, \" \");\n    if (name === \"\" || name === \".\" || name === \"..\") {\n        return undefined;\n    }\n    const info = new FileInfo_1.FileInfo(name);\n    const facts = packedFacts.split(\";\");\n    for (const fact of facts) {\n        const [factName, factValue] = splitStringOnce(fact, \"=\");\n        if (!factValue) {\n            continue;\n        }\n        const factHandler = factHandlersByName[factName.toLowerCase()];\n        if (!factHandler) {\n            continue;\n        }\n        const result = factHandler(factValue, info);\n        if (result === 2 /* FactHandlerResult.IgnoreFile */) {\n            return undefined;\n        }\n    }\n    return info;\n}\nexports.parseLine = parseLine;\nfunction transformList(files) {\n    // Create a map of all files that are not symbolic links by their unique ID\n    const nonLinksByID = new Map();\n    for (const file of files) {\n        if (!file.isSymbolicLink && file.uniqueID !== undefined) {\n            nonLinksByID.set(file.uniqueID, file);\n        }\n    }\n    const resolvedFiles = [];\n    for (const file of files) {\n        // Try to associate unresolved symbolic links with a target file/directory.\n        if (file.isSymbolicLink && file.uniqueID !== undefined && file.link === undefined) {\n            const target = nonLinksByID.get(file.uniqueID);\n            if (target !== undefined) {\n                file.link = target.name;\n            }\n        }\n        // The target of a symbolic link is listed as an entry in the directory listing but might\n        // have a path pointing outside of this directory. In that case we don't want this entry\n        // to be part of the listing. We generally don't want these kind of entries at all.\n        const isPartOfDirectory = !file.name.includes(\"/\");\n        if (isPartOfDirectory) {\n            resolvedFiles.push(file);\n        }\n    }\n    return resolvedFiles;\n}\nexports.transformList = transformList;\n/**\n * Parse date as specified in https://tools.ietf.org/html/rfc3659#section-2.3.\n *\n * Message contains response code and modified time in the format: YYYYMMDDHHMMSS[.sss]\n * For example `19991005213102` or `19980615100045.014`.\n */\nfunction parseMLSxDate(fact) {\n    return new Date(Date.UTC(+fact.slice(0, 4), // Year\n    +fact.slice(4, 6) - 1, // Month\n    +fact.slice(6, 8), // Date\n    +fact.slice(8, 10), // Hours\n    +fact.slice(10, 12), // Minutes\n    +fact.slice(12, 14), // Seconds\n    +fact.slice(15, 18) // Milliseconds\n    ));\n}\nexports.parseMLSxDate = parseMLSxDate;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvcGFyc2VMaXN0TUxTRC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0I7QUFDcEYsbUJBQW1CLG1CQUFPLENBQUMsbUVBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsU0FBUyxRQUFRLHVCQUF1QjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQiIsInNvdXJjZXMiOlsiRDpcXFdlYnN0ZXAyXFxzaGlwb3dsLW1lcmdlXFxub2RlX21vZHVsZXNcXGJhc2ljLWZ0cFxcZGlzdFxccGFyc2VMaXN0TUxTRC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucGFyc2VNTFN4RGF0ZSA9IGV4cG9ydHMudHJhbnNmb3JtTGlzdCA9IGV4cG9ydHMucGFyc2VMaW5lID0gZXhwb3J0cy50ZXN0TGluZSA9IHZvaWQgMDtcbmNvbnN0IEZpbGVJbmZvXzEgPSByZXF1aXJlKFwiLi9GaWxlSW5mb1wiKTtcbmZ1bmN0aW9uIHBhcnNlU2l6ZSh2YWx1ZSwgaW5mbykge1xuICAgIGluZm8uc2l6ZSA9IHBhcnNlSW50KHZhbHVlLCAxMCk7XG59XG4vKipcbiAqIFBhcnNlcnMgZm9yIE1MU0QgZmFjdHMuXG4gKi9cbmNvbnN0IGZhY3RIYW5kbGVyc0J5TmFtZSA9IHtcbiAgICBcInNpemVcIjogcGFyc2VTaXplLCAvLyBGaWxlIHNpemVcbiAgICBcInNpemRcIjogcGFyc2VTaXplLCAvLyBEaXJlY3Rvcnkgc2l6ZVxuICAgIFwidW5pcXVlXCI6ICh2YWx1ZSwgaW5mbykgPT4ge1xuICAgICAgICBpbmZvLnVuaXF1ZUlEID0gdmFsdWU7XG4gICAgfSxcbiAgICBcIm1vZGlmeVwiOiAodmFsdWUsIGluZm8pID0+IHtcbiAgICAgICAgaW5mby5tb2RpZmllZEF0ID0gcGFyc2VNTFN4RGF0ZSh2YWx1ZSk7XG4gICAgICAgIGluZm8ucmF3TW9kaWZpZWRBdCA9IGluZm8ubW9kaWZpZWRBdC50b0lTT1N0cmluZygpO1xuICAgIH0sXG4gICAgXCJ0eXBlXCI6ICh2YWx1ZSwgaW5mbykgPT4ge1xuICAgICAgICAvLyBUaGVyZSBzZWVtcyB0byBiZSBjb25mdXNpb24gb24gaG93IHRvIGhhbmRsZSBzeW1ib2xpYyBsaW5rcyBmb3IgVW5peC4gUkZDIDM2NTkgZG9lc24ndCBkZXNjcmliZVxuICAgICAgICAvLyB0aGlzIGJ1dCBtZW50aW9ucyBzb21lIGV4YW1wbGVzIHVzaW5nIHRoZSBzeW50YXggYHR5cGU9T1MudW5peD1zbGluazo8dGFyZ2V0PmAuIEJ1dCBhY2NvcmRpbmcgdG9cbiAgICAgICAgLy8gYW4gZW50cnkgaW4gdGhlIEVycmF0YSAoaHR0cHM6Ly93d3cucmZjLWVkaXRvci5vcmcvZXJyYXRhL2VpZDE1MDApIHRoaXMgc3ludGF4IGNhbid0IGJlIHZhbGlkLlxuICAgICAgICAvLyBJbnN0ZWFkIGl0IHByb3Bvc2VzIHRvIHVzZSBgdHlwZT1PUy51bml4PXN5bWxpbmtgIGFuZCB0byB0aGVuIGxpc3QgdGhlIGFjdHVhbCB0YXJnZXQgb2YgdGhlXG4gICAgICAgIC8vIHN5bWJvbGljIGxpbmsgYXMgYW5vdGhlciBlbnRyeSBpbiB0aGUgZGlyZWN0b3J5IGxpc3RpbmcuIFRoZSB1bmlxdWUgaWRlbnRpZmllcnMgY2FuIHRoZW4gYmUgdXNlZFxuICAgICAgICAvLyB0byBkZXJpdmUgdGhlIGNvbm5lY3Rpb24gYmV0d2VlbiBsaW5rKHMpIGFuZCB0YXJnZXQuIFdlJ2xsIGhhdmUgdG8gaGFuZGxlIGJvdGggY2FzZXMgYXMgdGhlcmVcbiAgICAgICAgLy8gYXJlIGRpZmZlcmluZyBvcGluaW9ucyBvbiBob3cgdG8gZGVhbCB3aXRoIHRoaXMuIEhlcmUgYXJlIHNvbWUgbGlua3Mgb24gdGhpcyB0b3BpYzpcbiAgICAgICAgLy8gLSBQcm9GVFBEIHNvdXJjZTogaHR0cHM6Ly9naXRodWIuY29tL3Byb2Z0cGQvcHJvZnRwZC9ibG9iLzU2ZTZkZmE1OThjYmQ0ZWY1YzZjYmE0MzliY2JjZDUzYTYzZTNiMjEvbW9kdWxlcy9tb2RfZmFjdHMuYyNMNTMxXG4gICAgICAgIC8vIC0gUHJvRlRQRCBidWc6IGh0dHA6Ly9idWdzLnByb2Z0cGQub3JnL3Nob3dfYnVnLmNnaT9pZD0zMzE4XG4gICAgICAgIC8vIC0gUHJvRlRQRCBzdGF0ZW1lbnQ6IGh0dHA6Ly93d3cucHJvZnRwZC5vcmcvZG9jcy9tb2R1bGVzL21vZF9mYWN0cy5odG1sXG4gICAgICAgIC8vIOKAkyBGaWxlWmlsbGEgYnVnOiBodHRwczovL3RyYWMuZmlsZXppbGxhLXByb2plY3Qub3JnL3RpY2tldC85MzEwXG4gICAgICAgIGlmICh2YWx1ZS5zdGFydHNXaXRoKFwiT1MudW5peD1zbGlua1wiKSkge1xuICAgICAgICAgICAgaW5mby50eXBlID0gRmlsZUluZm9fMS5GaWxlVHlwZS5TeW1ib2xpY0xpbms7XG4gICAgICAgICAgICBpbmZvLmxpbmsgPSB2YWx1ZS5zdWJzdHIodmFsdWUuaW5kZXhPZihcIjpcIikgKyAxKTtcbiAgICAgICAgICAgIHJldHVybiAxIC8qIEZhY3RIYW5kbGVyUmVzdWx0LkNvbnRpbnVlICovO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodmFsdWUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICAgICAgICAgICAgaW5mby50eXBlID0gRmlsZUluZm9fMS5GaWxlVHlwZS5GaWxlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRpclwiOlxuICAgICAgICAgICAgICAgIGluZm8udHlwZSA9IEZpbGVJbmZvXzEuRmlsZVR5cGUuRGlyZWN0b3J5O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIk9TLnVuaXg9c3ltbGlua1wiOlxuICAgICAgICAgICAgICAgIGluZm8udHlwZSA9IEZpbGVJbmZvXzEuRmlsZVR5cGUuU3ltYm9saWNMaW5rO1xuICAgICAgICAgICAgICAgIC8vIFRoZSB0YXJnZXQgb2YgdGhlIHN5bWJvbGljIGxpbmsgbWlnaHQgYmUgZGVmaW5lZCBpbiBhbm90aGVyIGxpbmUgaW4gdGhlIGRpcmVjdG9yeSBsaXN0aW5nLlxuICAgICAgICAgICAgICAgIC8vIFdlJ2xsIGhhbmRsZSB0aGlzIGluIGB0cmFuc2Zvcm1MaXN0KClgIGJlbG93LlxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImNkaXJcIjogLy8gQ3VycmVudCBkaXJlY3RvcnkgYmVpbmcgbGlzdGVkXG4gICAgICAgICAgICBjYXNlIFwicGRpclwiOiAvLyBQYXJlbnQgZGlyZWN0b3J5XG4gICAgICAgICAgICAgICAgcmV0dXJuIDIgLyogRmFjdEhhbmRsZXJSZXN1bHQuSWdub3JlRmlsZSAqLzsgLy8gRG9uJ3QgaW5jbHVkZSB0aGVzZSBlbnRyaWVzIGluIHRoZSBsaXN0aW5nXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGluZm8udHlwZSA9IEZpbGVJbmZvXzEuRmlsZVR5cGUuVW5rbm93bjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMSAvKiBGYWN0SGFuZGxlclJlc3VsdC5Db250aW51ZSAqLztcbiAgICB9LFxuICAgIFwidW5peC5tb2RlXCI6ICh2YWx1ZSwgaW5mbykgPT4ge1xuICAgICAgICBjb25zdCBkaWdpdHMgPSB2YWx1ZS5zdWJzdHIoLTMpO1xuICAgICAgICBpbmZvLnBlcm1pc3Npb25zID0ge1xuICAgICAgICAgICAgdXNlcjogcGFyc2VJbnQoZGlnaXRzWzBdLCAxMCksXG4gICAgICAgICAgICBncm91cDogcGFyc2VJbnQoZGlnaXRzWzFdLCAxMCksXG4gICAgICAgICAgICB3b3JsZDogcGFyc2VJbnQoZGlnaXRzWzJdLCAxMClcbiAgICAgICAgfTtcbiAgICB9LFxuICAgIFwidW5peC5vd25lcm5hbWVcIjogKHZhbHVlLCBpbmZvKSA9PiB7XG4gICAgICAgIGluZm8udXNlciA9IHZhbHVlO1xuICAgIH0sXG4gICAgXCJ1bml4Lm93bmVyXCI6ICh2YWx1ZSwgaW5mbykgPT4ge1xuICAgICAgICBpZiAoaW5mby51c2VyID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBpbmZvLnVzZXIgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldCBcInVuaXgudWlkXCIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1widW5peC5vd25lclwiXTtcbiAgICB9LFxuICAgIFwidW5peC5ncm91cG5hbWVcIjogKHZhbHVlLCBpbmZvKSA9PiB7XG4gICAgICAgIGluZm8uZ3JvdXAgPSB2YWx1ZTtcbiAgICB9LFxuICAgIFwidW5peC5ncm91cFwiOiAodmFsdWUsIGluZm8pID0+IHtcbiAgICAgICAgaWYgKGluZm8uZ3JvdXAgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIGluZm8uZ3JvdXAgPSB2YWx1ZTtcbiAgICB9LFxuICAgIGdldCBcInVuaXguZ2lkXCIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzW1widW5peC5ncm91cFwiXTtcbiAgICB9XG4gICAgLy8gUmVnYXJkaW5nIHRoZSBmYWN0IFwicGVybVwiOlxuICAgIC8vIFdlIGRvbid0IGhhbmRsZSBwZXJtaXNzaW9uIGluZm9ybWF0aW9uIHN0b3JlZCBpbiBcInBlcm1cIiBiZWNhdXNlIGl0cyBpbmZvcm1hdGlvbiBpcyBjb25jZXB0dWFsbHlcbiAgICAvLyBkaWZmZXJlbnQgZnJvbSB3aGF0IHVzZXJzIG9mIEZUUCBjbGllbnRzIHVzdWFsbHkgYXNzb2NpYXRlIHdpdGggXCJwZXJtaXNzaW9uc1wiLiBUaG9zZSB0aGF0IGhhdmVcbiAgICAvLyBzb21lIGV4cGVjdGF0aW9ucyAoYW5kIHByb2JhYmx5IHdhbnQgdG8gZWRpdCB0aGVtIHdpdGggYSBTSVRFIGNvbW1hbmQpIG9mdGVuIHVua25vd2luZ2x5IGV4cGVjdFxuICAgIC8vIHRoZSBVbml4IHBlcm1pc3Npb24gc3lzdGVtLiBUaGUgaW5mb3JtYXRpb24gcGFzc2VkIGJ5IFwicGVybVwiIGRlc2NyaWJlcyB3aGF0IEZUUCBjb21tYW5kcyBjYW4gYmVcbiAgICAvLyBleGVjdXRlZCB3aXRoIGEgZmlsZS9kaXJlY3RvcnkuIEJ1dCBldmVuIHRoaXMgY2FuIGJlIGVpdGhlciBpbmNvbXBsZXRlIG9yIGp1c3QgbWVhbnQgYXMgYSBcImd1aWRlXCJcbiAgICAvLyBhcyB0aGUgc3BlYyBtZW50aW9ucy4gRnJvbSBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzY1OSNzZWN0aW9uLTcuNS41OiBcIlRoZSBwZXJtaXNzaW9ucyBhcmVcbiAgICAvLyBkZXNjcmliZWQgaGVyZSBhcyB0aGV5IGFwcGx5IHRvIEZUUCBjb21tYW5kcy4gVGhleSBtYXkgbm90IG1hcCBlYXNpbHkgaW50byBwYXJ0aWN1bGFyIHBlcm1pc3Npb25zXG4gICAgLy8gYXZhaWxhYmxlIG9uIHRoZSBzZXJ2ZXIncyBvcGVyYXRpbmcgc3lzdGVtLlwiIFRoZSBwYXJzZXIgYnkgQXBhY2hlIENvbW1vbnMgdHJpZXMgdG8gdHJhbnNsYXRlIHRoZXNlXG4gICAgLy8gdG8gVW5peCBwZXJtaXNzaW9ucyDigJMgdGhpcyBpcyBtaXNsZWFkaW5nIHVzZXJzIGFuZCBtaWdodCBub3QgZXZlbiBiZSBjb3JyZWN0LlxufTtcbi8qKlxuICogU3BsaXQgYSBzdHJpbmcgb25jZSBhdCB0aGUgZmlyc3QgcG9zaXRpb24gb2YgYSBkZWxpbWl0ZXIuIEZvciBleGFtcGxlXG4gKiBgc3BsaXRTdHJpbmdPbmNlKFwiYSBiIGMgZFwiLCBcIiBcIilgIHJldHVybnMgYFtcImFcIiwgXCJiIGMgZFwiXWAuXG4gKi9cbmZ1bmN0aW9uIHNwbGl0U3RyaW5nT25jZShzdHIsIGRlbGltaXRlcikge1xuICAgIGNvbnN0IHBvcyA9IHN0ci5pbmRleE9mKGRlbGltaXRlcik7XG4gICAgY29uc3QgYSA9IHN0ci5zdWJzdHIoMCwgcG9zKTtcbiAgICBjb25zdCBiID0gc3RyLnN1YnN0cihwb3MgKyBkZWxpbWl0ZXIubGVuZ3RoKTtcbiAgICByZXR1cm4gW2EsIGJdO1xufVxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgYSBnaXZlbiBsaW5lIG1pZ2h0IGJlIHBhcnQgb2YgYW4gTUxTRCBsaXN0aW5nLlxuICpcbiAqIC0gRXhhbXBsZSAxOiBgc2l6ZT0xNTIyNzt0eXBlPWRpcjtwZXJtPWVsO21vZGlmeT0yMDE5MDQxOTA2NTczMDsgdGVzdCBvbmVgXG4gKiAtIEV4YW1wbGUgMjogYCBmaWxlIG5hbWVgIChsZWFkaW5nIHNwYWNlKVxuICovXG5mdW5jdGlvbiB0ZXN0TGluZShsaW5lKSB7XG4gICAgcmV0dXJuIC9eXFxTKz1cXFMrOy8udGVzdChsaW5lKSB8fCBsaW5lLnN0YXJ0c1dpdGgoXCIgXCIpO1xufVxuZXhwb3J0cy50ZXN0TGluZSA9IHRlc3RMaW5lO1xuLyoqXG4gKiBQYXJzZSBzaW5nbGUgbGluZSBhcyBNTFNEIGxpc3RpbmcsIHNlZSBzcGVjaWZpY2F0aW9uIGF0IGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNjU5I3NlY3Rpb24tNy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VMaW5lKGxpbmUpIHtcbiAgICBjb25zdCBbcGFja2VkRmFjdHMsIG5hbWVdID0gc3BsaXRTdHJpbmdPbmNlKGxpbmUsIFwiIFwiKTtcbiAgICBpZiAobmFtZSA9PT0gXCJcIiB8fCBuYW1lID09PSBcIi5cIiB8fCBuYW1lID09PSBcIi4uXCIpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgaW5mbyA9IG5ldyBGaWxlSW5mb18xLkZpbGVJbmZvKG5hbWUpO1xuICAgIGNvbnN0IGZhY3RzID0gcGFja2VkRmFjdHMuc3BsaXQoXCI7XCIpO1xuICAgIGZvciAoY29uc3QgZmFjdCBvZiBmYWN0cykge1xuICAgICAgICBjb25zdCBbZmFjdE5hbWUsIGZhY3RWYWx1ZV0gPSBzcGxpdFN0cmluZ09uY2UoZmFjdCwgXCI9XCIpO1xuICAgICAgICBpZiAoIWZhY3RWYWx1ZSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFjdEhhbmRsZXIgPSBmYWN0SGFuZGxlcnNCeU5hbWVbZmFjdE5hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICAgIGlmICghZmFjdEhhbmRsZXIpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGZhY3RIYW5kbGVyKGZhY3RWYWx1ZSwgaW5mbyk7XG4gICAgICAgIGlmIChyZXN1bHQgPT09IDIgLyogRmFjdEhhbmRsZXJSZXN1bHQuSWdub3JlRmlsZSAqLykge1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5mbztcbn1cbmV4cG9ydHMucGFyc2VMaW5lID0gcGFyc2VMaW5lO1xuZnVuY3Rpb24gdHJhbnNmb3JtTGlzdChmaWxlcykge1xuICAgIC8vIENyZWF0ZSBhIG1hcCBvZiBhbGwgZmlsZXMgdGhhdCBhcmUgbm90IHN5bWJvbGljIGxpbmtzIGJ5IHRoZWlyIHVuaXF1ZSBJRFxuICAgIGNvbnN0IG5vbkxpbmtzQnlJRCA9IG5ldyBNYXAoKTtcbiAgICBmb3IgKGNvbnN0IGZpbGUgb2YgZmlsZXMpIHtcbiAgICAgICAgaWYgKCFmaWxlLmlzU3ltYm9saWNMaW5rICYmIGZpbGUudW5pcXVlSUQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbm9uTGlua3NCeUlELnNldChmaWxlLnVuaXF1ZUlELCBmaWxlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCByZXNvbHZlZEZpbGVzID0gW107XG4gICAgZm9yIChjb25zdCBmaWxlIG9mIGZpbGVzKSB7XG4gICAgICAgIC8vIFRyeSB0byBhc3NvY2lhdGUgdW5yZXNvbHZlZCBzeW1ib2xpYyBsaW5rcyB3aXRoIGEgdGFyZ2V0IGZpbGUvZGlyZWN0b3J5LlxuICAgICAgICBpZiAoZmlsZS5pc1N5bWJvbGljTGluayAmJiBmaWxlLnVuaXF1ZUlEICE9PSB1bmRlZmluZWQgJiYgZmlsZS5saW5rID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IG5vbkxpbmtzQnlJRC5nZXQoZmlsZS51bmlxdWVJRCk7XG4gICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBmaWxlLmxpbmsgPSB0YXJnZXQubmFtZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgdGFyZ2V0IG9mIGEgc3ltYm9saWMgbGluayBpcyBsaXN0ZWQgYXMgYW4gZW50cnkgaW4gdGhlIGRpcmVjdG9yeSBsaXN0aW5nIGJ1dCBtaWdodFxuICAgICAgICAvLyBoYXZlIGEgcGF0aCBwb2ludGluZyBvdXRzaWRlIG9mIHRoaXMgZGlyZWN0b3J5LiBJbiB0aGF0IGNhc2Ugd2UgZG9uJ3Qgd2FudCB0aGlzIGVudHJ5XG4gICAgICAgIC8vIHRvIGJlIHBhcnQgb2YgdGhlIGxpc3RpbmcuIFdlIGdlbmVyYWxseSBkb24ndCB3YW50IHRoZXNlIGtpbmQgb2YgZW50cmllcyBhdCBhbGwuXG4gICAgICAgIGNvbnN0IGlzUGFydE9mRGlyZWN0b3J5ID0gIWZpbGUubmFtZS5pbmNsdWRlcyhcIi9cIik7XG4gICAgICAgIGlmIChpc1BhcnRPZkRpcmVjdG9yeSkge1xuICAgICAgICAgICAgcmVzb2x2ZWRGaWxlcy5wdXNoKGZpbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNvbHZlZEZpbGVzO1xufVxuZXhwb3J0cy50cmFuc2Zvcm1MaXN0ID0gdHJhbnNmb3JtTGlzdDtcbi8qKlxuICogUGFyc2UgZGF0ZSBhcyBzcGVjaWZpZWQgaW4gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM2NTkjc2VjdGlvbi0yLjMuXG4gKlxuICogTWVzc2FnZSBjb250YWlucyByZXNwb25zZSBjb2RlIGFuZCBtb2RpZmllZCB0aW1lIGluIHRoZSBmb3JtYXQ6IFlZWVlNTURESEhNTVNTWy5zc3NdXG4gKiBGb3IgZXhhbXBsZSBgMTk5OTEwMDUyMTMxMDJgIG9yIGAxOTk4MDYxNTEwMDA0NS4wMTRgLlxuICovXG5mdW5jdGlvbiBwYXJzZU1MU3hEYXRlKGZhY3QpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoK2ZhY3Quc2xpY2UoMCwgNCksIC8vIFllYXJcbiAgICArZmFjdC5zbGljZSg0LCA2KSAtIDEsIC8vIE1vbnRoXG4gICAgK2ZhY3Quc2xpY2UoNiwgOCksIC8vIERhdGVcbiAgICArZmFjdC5zbGljZSg4LCAxMCksIC8vIEhvdXJzXG4gICAgK2ZhY3Quc2xpY2UoMTAsIDEyKSwgLy8gTWludXRlc1xuICAgICtmYWN0LnNsaWNlKDEyLCAxNCksIC8vIFNlY29uZHNcbiAgICArZmFjdC5zbGljZSgxNSwgMTgpIC8vIE1pbGxpc2Vjb25kc1xuICAgICkpO1xufVxuZXhwb3J0cy5wYXJzZU1MU3hEYXRlID0gcGFyc2VNTFN4RGF0ZTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/parseListMLSD.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/parseListUnix.js":
/*!******************************************************!*\
  !*** ./node_modules/basic-ftp/dist/parseListUnix.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.transformList = exports.parseLine = exports.testLine = void 0;\nconst FileInfo_1 = __webpack_require__(/*! ./FileInfo */ \"(rsc)/./node_modules/basic-ftp/dist/FileInfo.js\");\nconst JA_MONTH = \"\\u6708\";\nconst JA_DAY = \"\\u65e5\";\nconst JA_YEAR = \"\\u5e74\";\n/**\n * This parser is based on the FTP client library source code in Apache Commons Net provided\n * under the Apache 2.0 license. It has been simplified and rewritten to better fit the Javascript language.\n *\n * https://github.com/apache/commons-net/blob/master/src/main/java/org/apache/commons/net/ftp/parser/UnixFTPEntryParser.java\n *\n * Below is the regular expression used by this parser.\n *\n * Permissions:\n *    r   the file is readable\n *    w   the file is writable\n *    x   the file is executable\n *    -   the indicated permission is not granted\n *    L   mandatory locking occurs during access (the set-group-ID bit is\n *        on and the group execution bit is off)\n *    s   the set-user-ID or set-group-ID bit is on, and the corresponding\n *        user or group execution bit is also on\n *    S   undefined bit-state (the set-user-ID bit is on and the user\n *        execution bit is off)\n *    t   the 1000 (octal) bit, or sticky bit, is on [see chmod(1)], and\n *        execution is on\n *    T   the 1000 bit is turned on, and execution is off (undefined bit-\n *        state)\n *    e   z/OS external link bit\n *    Final letter may be appended:\n *    +   file has extended security attributes (e.g. ACL)\n *    Note: local listings on MacOSX also use '@'\n *    this is not allowed for here as does not appear to be shown by FTP servers\n *    {@code @}   file has extended attributes\n */\nconst RE_LINE = new RegExp(\"([bcdelfmpSs-])\" // file type\n    + \"(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]?)))\\\\+?\" // permissions\n    + \"\\\\s*\" // separator TODO why allow it to be omitted??\n    + \"(\\\\d+)\" // link count\n    + \"\\\\s+\" // separator\n    + \"(?:(\\\\S+(?:\\\\s\\\\S+)*?)\\\\s+)?\" // owner name (optional spaces)\n    + \"(?:(\\\\S+(?:\\\\s\\\\S+)*)\\\\s+)?\" // group name (optional spaces)\n    + \"(\\\\d+(?:,\\\\s*\\\\d+)?)\" // size or n,m\n    + \"\\\\s+\" // separator\n    /**\n     * numeric or standard format date:\n     *   yyyy-mm-dd (expecting hh:mm to follow)\n     *   MMM [d]d\n     *   [d]d MMM\n     *   N.B. use non-space for MMM to allow for languages such as German which use\n     *   diacritics (e.g. umlaut) in some abbreviations.\n     *   Japanese uses numeric day and month with suffixes to distinguish them\n     *   [d]dXX [d]dZZ\n     */\n    + \"(\" +\n    \"(?:\\\\d+[-/]\\\\d+[-/]\\\\d+)\" + // yyyy-mm-dd\n    \"|(?:\\\\S{3}\\\\s+\\\\d{1,2})\" + // MMM [d]d\n    \"|(?:\\\\d{1,2}\\\\s+\\\\S{3})\" + // [d]d MMM\n    \"|(?:\\\\d{1,2}\" + JA_MONTH + \"\\\\s+\\\\d{1,2}\" + JA_DAY + \")\" +\n    \")\"\n    + \"\\\\s+\" // separator\n    /**\n     * year (for non-recent standard format) - yyyy\n     * or time (for numeric or recent standard format) [h]h:mm\n     * or Japanese year - yyyyXX\n     */\n    + \"((?:\\\\d+(?::\\\\d+)?)|(?:\\\\d{4}\" + JA_YEAR + \"))\" // (20)\n    + \"\\\\s\" // separator\n    + \"(.*)\"); // the rest (21)\n/**\n * Returns true if a given line might be a Unix-style listing.\n *\n * - Example: `-rw-r--r--+   1 patrick  staff   1057 Dec 11 14:35 test.txt`\n */\nfunction testLine(line) {\n    return RE_LINE.test(line);\n}\nexports.testLine = testLine;\n/**\n * Parse a single line of a Unix-style directory listing.\n */\nfunction parseLine(line) {\n    const groups = line.match(RE_LINE);\n    if (groups === null) {\n        return undefined;\n    }\n    const name = groups[21];\n    if (name === \".\" || name === \"..\") { // Ignore parent directory links\n        return undefined;\n    }\n    const file = new FileInfo_1.FileInfo(name);\n    file.size = parseInt(groups[18], 10);\n    file.user = groups[16];\n    file.group = groups[17];\n    file.hardLinkCount = parseInt(groups[15], 10);\n    file.rawModifiedAt = groups[19] + \" \" + groups[20];\n    file.permissions = {\n        user: parseMode(groups[4], groups[5], groups[6]),\n        group: parseMode(groups[8], groups[9], groups[10]),\n        world: parseMode(groups[12], groups[13], groups[14]),\n    };\n    // Set file type\n    switch (groups[1].charAt(0)) {\n        case \"d\":\n            file.type = FileInfo_1.FileType.Directory;\n            break;\n        case \"e\": // NET-39 => z/OS external link\n            file.type = FileInfo_1.FileType.SymbolicLink;\n            break;\n        case \"l\":\n            file.type = FileInfo_1.FileType.SymbolicLink;\n            break;\n        case \"b\":\n        case \"c\":\n            file.type = FileInfo_1.FileType.File; // TODO change this if DEVICE_TYPE implemented\n            break;\n        case \"f\":\n        case \"-\":\n            file.type = FileInfo_1.FileType.File;\n            break;\n        default:\n            // A 'whiteout' file is an ARTIFICIAL entry in any of several types of\n            // 'translucent' filesystems, of which a 'union' filesystem is one.\n            file.type = FileInfo_1.FileType.Unknown;\n    }\n    // Separate out the link name for symbolic links\n    if (file.isSymbolicLink) {\n        const end = name.indexOf(\" -> \");\n        if (end !== -1) {\n            file.name = name.substring(0, end);\n            file.link = name.substring(end + 4);\n        }\n    }\n    return file;\n}\nexports.parseLine = parseLine;\nfunction transformList(files) {\n    return files;\n}\nexports.transformList = transformList;\nfunction parseMode(r, w, x) {\n    let value = 0;\n    if (r !== \"-\") {\n        value += FileInfo_1.FileInfo.UnixPermission.Read;\n    }\n    if (w !== \"-\") {\n        value += FileInfo_1.FileInfo.UnixPermission.Write;\n    }\n    const execToken = x.charAt(0);\n    if (execToken !== \"-\" && execToken.toUpperCase() !== execToken) {\n        value += FileInfo_1.FileInfo.UnixPermission.Execute;\n    }\n    return value;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvcGFyc2VMaXN0VW5peC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxxQkFBcUIsR0FBRyxpQkFBaUIsR0FBRyxnQkFBZ0I7QUFDNUQsbUJBQW1CLG1CQUFPLENBQUMsbUVBQVk7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLFdBQVc7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLEVBQUUsUUFBUSxJQUFJO0FBQzNCLGFBQWEsSUFBSSxRQUFRLEVBQUU7QUFDM0IsYUFBYSxJQUFJLHdCQUF3QixJQUFJO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLEVBQUU7QUFDcEM7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyJEOlxcV2Vic3RlcDJcXHNoaXBvd2wtbWVyZ2VcXG5vZGVfbW9kdWxlc1xcYmFzaWMtZnRwXFxkaXN0XFxwYXJzZUxpc3RVbml4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy50cmFuc2Zvcm1MaXN0ID0gZXhwb3J0cy5wYXJzZUxpbmUgPSBleHBvcnRzLnRlc3RMaW5lID0gdm9pZCAwO1xuY29uc3QgRmlsZUluZm9fMSA9IHJlcXVpcmUoXCIuL0ZpbGVJbmZvXCIpO1xuY29uc3QgSkFfTU9OVEggPSBcIlxcdTY3MDhcIjtcbmNvbnN0IEpBX0RBWSA9IFwiXFx1NjVlNVwiO1xuY29uc3QgSkFfWUVBUiA9IFwiXFx1NWU3NFwiO1xuLyoqXG4gKiBUaGlzIHBhcnNlciBpcyBiYXNlZCBvbiB0aGUgRlRQIGNsaWVudCBsaWJyYXJ5IHNvdXJjZSBjb2RlIGluIEFwYWNoZSBDb21tb25zIE5ldCBwcm92aWRlZFxuICogdW5kZXIgdGhlIEFwYWNoZSAyLjAgbGljZW5zZS4gSXQgaGFzIGJlZW4gc2ltcGxpZmllZCBhbmQgcmV3cml0dGVuIHRvIGJldHRlciBmaXQgdGhlIEphdmFzY3JpcHQgbGFuZ3VhZ2UuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9jb21tb25zLW5ldC9ibG9iL21hc3Rlci9zcmMvbWFpbi9qYXZhL29yZy9hcGFjaGUvY29tbW9ucy9uZXQvZnRwL3BhcnNlci9Vbml4RlRQRW50cnlQYXJzZXIuamF2YVxuICpcbiAqIEJlbG93IGlzIHRoZSByZWd1bGFyIGV4cHJlc3Npb24gdXNlZCBieSB0aGlzIHBhcnNlci5cbiAqXG4gKiBQZXJtaXNzaW9uczpcbiAqICAgIHIgICB0aGUgZmlsZSBpcyByZWFkYWJsZVxuICogICAgdyAgIHRoZSBmaWxlIGlzIHdyaXRhYmxlXG4gKiAgICB4ICAgdGhlIGZpbGUgaXMgZXhlY3V0YWJsZVxuICogICAgLSAgIHRoZSBpbmRpY2F0ZWQgcGVybWlzc2lvbiBpcyBub3QgZ3JhbnRlZFxuICogICAgTCAgIG1hbmRhdG9yeSBsb2NraW5nIG9jY3VycyBkdXJpbmcgYWNjZXNzICh0aGUgc2V0LWdyb3VwLUlEIGJpdCBpc1xuICogICAgICAgIG9uIGFuZCB0aGUgZ3JvdXAgZXhlY3V0aW9uIGJpdCBpcyBvZmYpXG4gKiAgICBzICAgdGhlIHNldC11c2VyLUlEIG9yIHNldC1ncm91cC1JRCBiaXQgaXMgb24sIGFuZCB0aGUgY29ycmVzcG9uZGluZ1xuICogICAgICAgIHVzZXIgb3IgZ3JvdXAgZXhlY3V0aW9uIGJpdCBpcyBhbHNvIG9uXG4gKiAgICBTICAgdW5kZWZpbmVkIGJpdC1zdGF0ZSAodGhlIHNldC11c2VyLUlEIGJpdCBpcyBvbiBhbmQgdGhlIHVzZXJcbiAqICAgICAgICBleGVjdXRpb24gYml0IGlzIG9mZilcbiAqICAgIHQgICB0aGUgMTAwMCAob2N0YWwpIGJpdCwgb3Igc3RpY2t5IGJpdCwgaXMgb24gW3NlZSBjaG1vZCgxKV0sIGFuZFxuICogICAgICAgIGV4ZWN1dGlvbiBpcyBvblxuICogICAgVCAgIHRoZSAxMDAwIGJpdCBpcyB0dXJuZWQgb24sIGFuZCBleGVjdXRpb24gaXMgb2ZmICh1bmRlZmluZWQgYml0LVxuICogICAgICAgIHN0YXRlKVxuICogICAgZSAgIHovT1MgZXh0ZXJuYWwgbGluayBiaXRcbiAqICAgIEZpbmFsIGxldHRlciBtYXkgYmUgYXBwZW5kZWQ6XG4gKiAgICArICAgZmlsZSBoYXMgZXh0ZW5kZWQgc2VjdXJpdHkgYXR0cmlidXRlcyAoZS5nLiBBQ0wpXG4gKiAgICBOb3RlOiBsb2NhbCBsaXN0aW5ncyBvbiBNYWNPU1ggYWxzbyB1c2UgJ0AnXG4gKiAgICB0aGlzIGlzIG5vdCBhbGxvd2VkIGZvciBoZXJlIGFzIGRvZXMgbm90IGFwcGVhciB0byBiZSBzaG93biBieSBGVFAgc2VydmVyc1xuICogICAge0Bjb2RlIEB9ICAgZmlsZSBoYXMgZXh0ZW5kZWQgYXR0cmlidXRlc1xuICovXG5jb25zdCBSRV9MSU5FID0gbmV3IFJlZ0V4cChcIihbYmNkZWxmbXBTcy1dKVwiIC8vIGZpbGUgdHlwZVxuICAgICsgXCIoKChyfC0pKHd8LSkoW3hzU3RUTC1dKSkoKHJ8LSkod3wtKShbeHNTdFRMLV0pKSgocnwtKSh3fC0pKFt4c1N0VEwtXT8pKSlcXFxcKz9cIiAvLyBwZXJtaXNzaW9uc1xuICAgICsgXCJcXFxccypcIiAvLyBzZXBhcmF0b3IgVE9ETyB3aHkgYWxsb3cgaXQgdG8gYmUgb21pdHRlZD8/XG4gICAgKyBcIihcXFxcZCspXCIgLy8gbGluayBjb3VudFxuICAgICsgXCJcXFxccytcIiAvLyBzZXBhcmF0b3JcbiAgICArIFwiKD86KFxcXFxTKyg/OlxcXFxzXFxcXFMrKSo/KVxcXFxzKyk/XCIgLy8gb3duZXIgbmFtZSAob3B0aW9uYWwgc3BhY2VzKVxuICAgICsgXCIoPzooXFxcXFMrKD86XFxcXHNcXFxcUyspKilcXFxccyspP1wiIC8vIGdyb3VwIG5hbWUgKG9wdGlvbmFsIHNwYWNlcylcbiAgICArIFwiKFxcXFxkKyg/OixcXFxccypcXFxcZCspPylcIiAvLyBzaXplIG9yIG4sbVxuICAgICsgXCJcXFxccytcIiAvLyBzZXBhcmF0b3JcbiAgICAvKipcbiAgICAgKiBudW1lcmljIG9yIHN0YW5kYXJkIGZvcm1hdCBkYXRlOlxuICAgICAqICAgeXl5eS1tbS1kZCAoZXhwZWN0aW5nIGhoOm1tIHRvIGZvbGxvdylcbiAgICAgKiAgIE1NTSBbZF1kXG4gICAgICogICBbZF1kIE1NTVxuICAgICAqICAgTi5CLiB1c2Ugbm9uLXNwYWNlIGZvciBNTU0gdG8gYWxsb3cgZm9yIGxhbmd1YWdlcyBzdWNoIGFzIEdlcm1hbiB3aGljaCB1c2VcbiAgICAgKiAgIGRpYWNyaXRpY3MgKGUuZy4gdW1sYXV0KSBpbiBzb21lIGFiYnJldmlhdGlvbnMuXG4gICAgICogICBKYXBhbmVzZSB1c2VzIG51bWVyaWMgZGF5IGFuZCBtb250aCB3aXRoIHN1ZmZpeGVzIHRvIGRpc3Rpbmd1aXNoIHRoZW1cbiAgICAgKiAgIFtkXWRYWCBbZF1kWlpcbiAgICAgKi9cbiAgICArIFwiKFwiICtcbiAgICBcIig/OlxcXFxkK1stL11cXFxcZCtbLS9dXFxcXGQrKVwiICsgLy8geXl5eS1tbS1kZFxuICAgIFwifCg/OlxcXFxTezN9XFxcXHMrXFxcXGR7MSwyfSlcIiArIC8vIE1NTSBbZF1kXG4gICAgXCJ8KD86XFxcXGR7MSwyfVxcXFxzK1xcXFxTezN9KVwiICsgLy8gW2RdZCBNTU1cbiAgICBcInwoPzpcXFxcZHsxLDJ9XCIgKyBKQV9NT05USCArIFwiXFxcXHMrXFxcXGR7MSwyfVwiICsgSkFfREFZICsgXCIpXCIgK1xuICAgIFwiKVwiXG4gICAgKyBcIlxcXFxzK1wiIC8vIHNlcGFyYXRvclxuICAgIC8qKlxuICAgICAqIHllYXIgKGZvciBub24tcmVjZW50IHN0YW5kYXJkIGZvcm1hdCkgLSB5eXl5XG4gICAgICogb3IgdGltZSAoZm9yIG51bWVyaWMgb3IgcmVjZW50IHN0YW5kYXJkIGZvcm1hdCkgW2hdaDptbVxuICAgICAqIG9yIEphcGFuZXNlIHllYXIgLSB5eXl5WFhcbiAgICAgKi9cbiAgICArIFwiKCg/OlxcXFxkKyg/OjpcXFxcZCspPyl8KD86XFxcXGR7NH1cIiArIEpBX1lFQVIgKyBcIikpXCIgLy8gKDIwKVxuICAgICsgXCJcXFxcc1wiIC8vIHNlcGFyYXRvclxuICAgICsgXCIoLiopXCIpOyAvLyB0aGUgcmVzdCAoMjEpXG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBhIGdpdmVuIGxpbmUgbWlnaHQgYmUgYSBVbml4LXN0eWxlIGxpc3RpbmcuXG4gKlxuICogLSBFeGFtcGxlOiBgLXJ3LXItLXItLSsgICAxIHBhdHJpY2sgIHN0YWZmICAgMTA1NyBEZWMgMTEgMTQ6MzUgdGVzdC50eHRgXG4gKi9cbmZ1bmN0aW9uIHRlc3RMaW5lKGxpbmUpIHtcbiAgICByZXR1cm4gUkVfTElORS50ZXN0KGxpbmUpO1xufVxuZXhwb3J0cy50ZXN0TGluZSA9IHRlc3RMaW5lO1xuLyoqXG4gKiBQYXJzZSBhIHNpbmdsZSBsaW5lIG9mIGEgVW5peC1zdHlsZSBkaXJlY3RvcnkgbGlzdGluZy5cbiAqL1xuZnVuY3Rpb24gcGFyc2VMaW5lKGxpbmUpIHtcbiAgICBjb25zdCBncm91cHMgPSBsaW5lLm1hdGNoKFJFX0xJTkUpO1xuICAgIGlmIChncm91cHMgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IGdyb3Vwc1syMV07XG4gICAgaWYgKG5hbWUgPT09IFwiLlwiIHx8IG5hbWUgPT09IFwiLi5cIikgeyAvLyBJZ25vcmUgcGFyZW50IGRpcmVjdG9yeSBsaW5rc1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBjb25zdCBmaWxlID0gbmV3IEZpbGVJbmZvXzEuRmlsZUluZm8obmFtZSk7XG4gICAgZmlsZS5zaXplID0gcGFyc2VJbnQoZ3JvdXBzWzE4XSwgMTApO1xuICAgIGZpbGUudXNlciA9IGdyb3Vwc1sxNl07XG4gICAgZmlsZS5ncm91cCA9IGdyb3Vwc1sxN107XG4gICAgZmlsZS5oYXJkTGlua0NvdW50ID0gcGFyc2VJbnQoZ3JvdXBzWzE1XSwgMTApO1xuICAgIGZpbGUucmF3TW9kaWZpZWRBdCA9IGdyb3Vwc1sxOV0gKyBcIiBcIiArIGdyb3Vwc1syMF07XG4gICAgZmlsZS5wZXJtaXNzaW9ucyA9IHtcbiAgICAgICAgdXNlcjogcGFyc2VNb2RlKGdyb3Vwc1s0XSwgZ3JvdXBzWzVdLCBncm91cHNbNl0pLFxuICAgICAgICBncm91cDogcGFyc2VNb2RlKGdyb3Vwc1s4XSwgZ3JvdXBzWzldLCBncm91cHNbMTBdKSxcbiAgICAgICAgd29ybGQ6IHBhcnNlTW9kZShncm91cHNbMTJdLCBncm91cHNbMTNdLCBncm91cHNbMTRdKSxcbiAgICB9O1xuICAgIC8vIFNldCBmaWxlIHR5cGVcbiAgICBzd2l0Y2ggKGdyb3Vwc1sxXS5jaGFyQXQoMCkpIHtcbiAgICAgICAgY2FzZSBcImRcIjpcbiAgICAgICAgICAgIGZpbGUudHlwZSA9IEZpbGVJbmZvXzEuRmlsZVR5cGUuRGlyZWN0b3J5O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJlXCI6IC8vIE5FVC0zOSA9PiB6L09TIGV4dGVybmFsIGxpbmtcbiAgICAgICAgICAgIGZpbGUudHlwZSA9IEZpbGVJbmZvXzEuRmlsZVR5cGUuU3ltYm9saWNMaW5rO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJsXCI6XG4gICAgICAgICAgICBmaWxlLnR5cGUgPSBGaWxlSW5mb18xLkZpbGVUeXBlLlN5bWJvbGljTGluaztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYlwiOlxuICAgICAgICBjYXNlIFwiY1wiOlxuICAgICAgICAgICAgZmlsZS50eXBlID0gRmlsZUluZm9fMS5GaWxlVHlwZS5GaWxlOyAvLyBUT0RPIGNoYW5nZSB0aGlzIGlmIERFVklDRV9UWVBFIGltcGxlbWVudGVkXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImZcIjpcbiAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICAgIGZpbGUudHlwZSA9IEZpbGVJbmZvXzEuRmlsZVR5cGUuRmlsZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgLy8gQSAnd2hpdGVvdXQnIGZpbGUgaXMgYW4gQVJUSUZJQ0lBTCBlbnRyeSBpbiBhbnkgb2Ygc2V2ZXJhbCB0eXBlcyBvZlxuICAgICAgICAgICAgLy8gJ3RyYW5zbHVjZW50JyBmaWxlc3lzdGVtcywgb2Ygd2hpY2ggYSAndW5pb24nIGZpbGVzeXN0ZW0gaXMgb25lLlxuICAgICAgICAgICAgZmlsZS50eXBlID0gRmlsZUluZm9fMS5GaWxlVHlwZS5Vbmtub3duO1xuICAgIH1cbiAgICAvLyBTZXBhcmF0ZSBvdXQgdGhlIGxpbmsgbmFtZSBmb3Igc3ltYm9saWMgbGlua3NcbiAgICBpZiAoZmlsZS5pc1N5bWJvbGljTGluaykge1xuICAgICAgICBjb25zdCBlbmQgPSBuYW1lLmluZGV4T2YoXCIgLT4gXCIpO1xuICAgICAgICBpZiAoZW5kICE9PSAtMSkge1xuICAgICAgICAgICAgZmlsZS5uYW1lID0gbmFtZS5zdWJzdHJpbmcoMCwgZW5kKTtcbiAgICAgICAgICAgIGZpbGUubGluayA9IG5hbWUuc3Vic3RyaW5nKGVuZCArIDQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmaWxlO1xufVxuZXhwb3J0cy5wYXJzZUxpbmUgPSBwYXJzZUxpbmU7XG5mdW5jdGlvbiB0cmFuc2Zvcm1MaXN0KGZpbGVzKSB7XG4gICAgcmV0dXJuIGZpbGVzO1xufVxuZXhwb3J0cy50cmFuc2Zvcm1MaXN0ID0gdHJhbnNmb3JtTGlzdDtcbmZ1bmN0aW9uIHBhcnNlTW9kZShyLCB3LCB4KSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBpZiAociAhPT0gXCItXCIpIHtcbiAgICAgICAgdmFsdWUgKz0gRmlsZUluZm9fMS5GaWxlSW5mby5Vbml4UGVybWlzc2lvbi5SZWFkO1xuICAgIH1cbiAgICBpZiAodyAhPT0gXCItXCIpIHtcbiAgICAgICAgdmFsdWUgKz0gRmlsZUluZm9fMS5GaWxlSW5mby5Vbml4UGVybWlzc2lvbi5Xcml0ZTtcbiAgICB9XG4gICAgY29uc3QgZXhlY1Rva2VuID0geC5jaGFyQXQoMCk7XG4gICAgaWYgKGV4ZWNUb2tlbiAhPT0gXCItXCIgJiYgZXhlY1Rva2VuLnRvVXBwZXJDYXNlKCkgIT09IGV4ZWNUb2tlbikge1xuICAgICAgICB2YWx1ZSArPSBGaWxlSW5mb18xLkZpbGVJbmZvLlVuaXhQZXJtaXNzaW9uLkV4ZWN1dGU7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/parseListUnix.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/basic-ftp/dist/transfer.js":
/*!*************************************************!*\
  !*** ./node_modules/basic-ftp/dist/transfer.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.downloadTo = exports.uploadFrom = exports.connectForPassiveTransfer = exports.parsePasvResponse = exports.enterPassiveModeIPv4 = exports.parseEpsvResponse = exports.enterPassiveModeIPv6 = void 0;\nconst netUtils_1 = __webpack_require__(/*! ./netUtils */ \"(rsc)/./node_modules/basic-ftp/dist/netUtils.js\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst parseControlResponse_1 = __webpack_require__(/*! ./parseControlResponse */ \"(rsc)/./node_modules/basic-ftp/dist/parseControlResponse.js\");\n/**\n * Prepare a data socket using passive mode over IPv6.\n */\nasync function enterPassiveModeIPv6(ftp) {\n    const res = await ftp.request(\"EPSV\");\n    const port = parseEpsvResponse(res.message);\n    if (!port) {\n        throw new Error(\"Can't parse EPSV response: \" + res.message);\n    }\n    const controlHost = ftp.socket.remoteAddress;\n    if (controlHost === undefined) {\n        throw new Error(\"Control socket is disconnected, can't get remote address.\");\n    }\n    await connectForPassiveTransfer(controlHost, port, ftp);\n    return res;\n}\nexports.enterPassiveModeIPv6 = enterPassiveModeIPv6;\n/**\n * Parse an EPSV response. Returns only the port as in EPSV the host of the control connection is used.\n */\nfunction parseEpsvResponse(message) {\n    // Get port from EPSV response, e.g. \"229 Entering Extended Passive Mode (|||6446|)\"\n    // Some FTP Servers such as the one on IBM i (OS/400) use ! instead of | in their EPSV response.\n    const groups = message.match(/[|!]{3}(.+)[|!]/);\n    if (groups === null || groups[1] === undefined) {\n        throw new Error(`Can't parse response to 'EPSV': ${message}`);\n    }\n    const port = parseInt(groups[1], 10);\n    if (Number.isNaN(port)) {\n        throw new Error(`Can't parse response to 'EPSV', port is not a number: ${message}`);\n    }\n    return port;\n}\nexports.parseEpsvResponse = parseEpsvResponse;\n/**\n * Prepare a data socket using passive mode over IPv4.\n */\nasync function enterPassiveModeIPv4(ftp) {\n    const res = await ftp.request(\"PASV\");\n    const target = parsePasvResponse(res.message);\n    if (!target) {\n        throw new Error(\"Can't parse PASV response: \" + res.message);\n    }\n    // If the host in the PASV response has a local address while the control connection hasn't,\n    // we assume a NAT issue and use the IP of the control connection as the target for the data connection.\n    // We can't always perform this replacement because it's possible (although unlikely) that the FTP server\n    // indeed uses a different host for data connections.\n    const controlHost = ftp.socket.remoteAddress;\n    if ((0, netUtils_1.ipIsPrivateV4Address)(target.host) && controlHost && !(0, netUtils_1.ipIsPrivateV4Address)(controlHost)) {\n        target.host = controlHost;\n    }\n    await connectForPassiveTransfer(target.host, target.port, ftp);\n    return res;\n}\nexports.enterPassiveModeIPv4 = enterPassiveModeIPv4;\n/**\n * Parse a PASV response.\n */\nfunction parsePasvResponse(message) {\n    // Get host and port from PASV response, e.g. \"227 Entering Passive Mode (192,168,1,100,10,229)\"\n    const groups = message.match(/([-\\d]+,[-\\d]+,[-\\d]+,[-\\d]+),([-\\d]+),([-\\d]+)/);\n    if (groups === null || groups.length !== 4) {\n        throw new Error(`Can't parse response to 'PASV': ${message}`);\n    }\n    return {\n        host: groups[1].replace(/,/g, \".\"),\n        port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)\n    };\n}\nexports.parsePasvResponse = parsePasvResponse;\nfunction connectForPassiveTransfer(host, port, ftp) {\n    return new Promise((resolve, reject) => {\n        let socket = ftp._newSocket();\n        const handleConnErr = function (err) {\n            err.message = \"Can't open data connection in passive mode: \" + err.message;\n            reject(err);\n        };\n        const handleTimeout = function () {\n            socket.destroy();\n            reject(new Error(`Timeout when trying to open data connection to ${host}:${port}`));\n        };\n        socket.setTimeout(ftp.timeout);\n        socket.on(\"error\", handleConnErr);\n        socket.on(\"timeout\", handleTimeout);\n        socket.connect({ port, host, family: ftp.ipFamily }, () => {\n            if (ftp.socket instanceof tls_1.TLSSocket) {\n                socket = (0, tls_1.connect)(Object.assign({}, ftp.tlsOptions, {\n                    socket,\n                    // Reuse the TLS session negotiated earlier when the control connection\n                    // was upgraded. Servers expect this because it provides additional\n                    // security: If a completely new session would be negotiated, a hacker\n                    // could guess the port and connect to the new data connection before we do\n                    // by just starting his/her own TLS session.\n                    session: ftp.socket.getSession()\n                }));\n                // It's the responsibility of the transfer task to wait until the\n                // TLS socket issued the event 'secureConnect'. We can't do this\n                // here because some servers will start upgrading after the\n                // specific transfer request has been made. List and download don't\n                // have to wait for this event because the server sends whenever it\n                // is ready. But for upload this has to be taken into account,\n                // see the details in the upload() function below.\n            }\n            // Let the FTPContext listen to errors from now on, remove local handler.\n            socket.removeListener(\"error\", handleConnErr);\n            socket.removeListener(\"timeout\", handleTimeout);\n            ftp.dataSocket = socket;\n            resolve();\n        });\n    });\n}\nexports.connectForPassiveTransfer = connectForPassiveTransfer;\n/**\n * Helps resolving/rejecting transfers.\n *\n * This is used internally for all FTP transfers. For example when downloading, the server might confirm\n * with \"226 Transfer complete\" when in fact the download on the data connection has not finished\n * yet. With all transfers we make sure that a) the result arrived and b) has been confirmed by\n * e.g. the control connection. We just don't know in which order this will happen.\n */\nclass TransferResolver {\n    /**\n     * Instantiate a TransferResolver\n     */\n    constructor(ftp, progress) {\n        this.ftp = ftp;\n        this.progress = progress;\n        this.response = undefined;\n        this.dataTransferDone = false;\n    }\n    /**\n     * Mark the beginning of a transfer.\n     *\n     * @param name - Name of the transfer, usually the filename.\n     * @param type - Type of transfer, usually \"upload\" or \"download\".\n     */\n    onDataStart(name, type) {\n        // Let the data socket be in charge of tracking timeouts during transfer.\n        // The control socket sits idle during this time anyway and might provoke\n        // a timeout unnecessarily. The control connection will take care\n        // of timeouts again once data transfer is complete or failed.\n        if (this.ftp.dataSocket === undefined) {\n            throw new Error(\"Data transfer should start but there is no data connection.\");\n        }\n        this.ftp.socket.setTimeout(0);\n        this.ftp.dataSocket.setTimeout(this.ftp.timeout);\n        this.progress.start(this.ftp.dataSocket, name, type);\n    }\n    /**\n     * The data connection has finished the transfer.\n     */\n    onDataDone(task) {\n        this.progress.updateAndStop();\n        // Hand-over timeout tracking back to the control connection. It's possible that\n        // we don't receive the response over the control connection that the transfer is\n        // done. In this case, we want to correctly associate the resulting timeout with\n        // the control connection.\n        this.ftp.socket.setTimeout(this.ftp.timeout);\n        if (this.ftp.dataSocket) {\n            this.ftp.dataSocket.setTimeout(0);\n        }\n        this.dataTransferDone = true;\n        this.tryResolve(task);\n    }\n    /**\n     * The control connection reports the transfer as finished.\n     */\n    onControlDone(task, response) {\n        this.response = response;\n        this.tryResolve(task);\n    }\n    /**\n     * An error has been reported and the task should be rejected.\n     */\n    onError(task, err) {\n        this.progress.updateAndStop();\n        this.ftp.socket.setTimeout(this.ftp.timeout);\n        this.ftp.dataSocket = undefined;\n        task.reject(err);\n    }\n    /**\n     * Control connection sent an unexpected request requiring a response from our part. We\n     * can't provide that (because unknown) and have to close the contrext with an error because\n     * the FTP server is now caught up in a state we can't resolve.\n     */\n    onUnexpectedRequest(response) {\n        const err = new Error(`Unexpected FTP response is requesting an answer: ${response.message}`);\n        this.ftp.closeWithError(err);\n    }\n    tryResolve(task) {\n        // To resolve, we need both control and data connection to report that the transfer is done.\n        const canResolve = this.dataTransferDone && this.response !== undefined;\n        if (canResolve) {\n            this.ftp.dataSocket = undefined;\n            task.resolve(this.response);\n        }\n    }\n}\nfunction uploadFrom(source, config) {\n    const resolver = new TransferResolver(config.ftp, config.tracker);\n    const fullCommand = `${config.command} ${config.remotePath}`;\n    return config.ftp.handle(fullCommand, (res, task) => {\n        if (res instanceof Error) {\n            resolver.onError(task, res);\n        }\n        else if (res.code === 150 || res.code === 125) { // Ready to upload\n            const dataSocket = config.ftp.dataSocket;\n            if (!dataSocket) {\n                resolver.onError(task, new Error(\"Upload should begin but no data connection is available.\"));\n                return;\n            }\n            // If we are using TLS, we have to wait until the dataSocket issued\n            // 'secureConnect'. If this hasn't happened yet, getCipher() returns undefined.\n            const canUpload = \"getCipher\" in dataSocket ? dataSocket.getCipher() !== undefined : true;\n            onConditionOrEvent(canUpload, dataSocket, \"secureConnect\", () => {\n                config.ftp.log(`Uploading to ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);\n                resolver.onDataStart(config.remotePath, config.type);\n                (0, stream_1.pipeline)(source, dataSocket, err => {\n                    if (err) {\n                        resolver.onError(task, err);\n                    }\n                    else {\n                        resolver.onDataDone(task);\n                    }\n                });\n            });\n        }\n        else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) { // Transfer complete\n            resolver.onControlDone(task, res);\n        }\n        else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {\n            resolver.onUnexpectedRequest(res);\n        }\n        // Ignore all other positive preliminary response codes (< 200)\n    });\n}\nexports.uploadFrom = uploadFrom;\nfunction downloadTo(destination, config) {\n    if (!config.ftp.dataSocket) {\n        throw new Error(\"Download will be initiated but no data connection is available.\");\n    }\n    const resolver = new TransferResolver(config.ftp, config.tracker);\n    return config.ftp.handle(config.command, (res, task) => {\n        if (res instanceof Error) {\n            resolver.onError(task, res);\n        }\n        else if (res.code === 150 || res.code === 125) { // Ready to download\n            const dataSocket = config.ftp.dataSocket;\n            if (!dataSocket) {\n                resolver.onError(task, new Error(\"Download should begin but no data connection is available.\"));\n                return;\n            }\n            config.ftp.log(`Downloading from ${(0, netUtils_1.describeAddress)(dataSocket)} (${(0, netUtils_1.describeTLS)(dataSocket)})`);\n            resolver.onDataStart(config.remotePath, config.type);\n            (0, stream_1.pipeline)(dataSocket, destination, err => {\n                if (err) {\n                    resolver.onError(task, err);\n                }\n                else {\n                    resolver.onDataDone(task);\n                }\n            });\n        }\n        else if (res.code === 350) { // Restarting at startAt.\n            config.ftp.send(\"RETR \" + config.remotePath);\n        }\n        else if ((0, parseControlResponse_1.positiveCompletion)(res.code)) { // Transfer complete\n            resolver.onControlDone(task, res);\n        }\n        else if ((0, parseControlResponse_1.positiveIntermediate)(res.code)) {\n            resolver.onUnexpectedRequest(res);\n        }\n        // Ignore all other positive preliminary response codes (< 200)\n    });\n}\nexports.downloadTo = downloadTo;\n/**\n * Calls a function immediately if a condition is met or subscribes to an event and calls\n * it once the event is emitted.\n *\n * @param condition  The condition to test.\n * @param emitter  The emitter to use if the condition is not met.\n * @param eventName  The event to subscribe to if the condition is not met.\n * @param action  The function to call.\n */\nfunction onConditionOrEvent(condition, emitter, eventName, action) {\n    if (condition === true) {\n        action();\n    }\n    else {\n        emitter.once(eventName, () => action());\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmFzaWMtZnRwL2Rpc3QvdHJhbnNmZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLEdBQUcsa0JBQWtCLEdBQUcsaUNBQWlDLEdBQUcseUJBQXlCLEdBQUcsNEJBQTRCLEdBQUcseUJBQXlCLEdBQUcsNEJBQTRCO0FBQ2pNLG1CQUFtQixtQkFBTyxDQUFDLG1FQUFZO0FBQ3ZDLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiwrQkFBK0IsbUJBQU8sQ0FBQywyRkFBd0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLEVBQUU7QUFDekM7QUFDQSwyREFBMkQsUUFBUTtBQUNuRTtBQUNBO0FBQ0E7QUFDQSxpRkFBaUYsUUFBUTtBQUN6RjtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxRQUFRO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsS0FBSyxHQUFHLEtBQUs7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsa0NBQWtDO0FBQzNEO0FBQ0EsNERBQTREO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGLGlCQUFpQjtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixnQkFBZ0IsRUFBRSxrQkFBa0I7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQ7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLDZDQUE2QyxHQUFHLHdDQUF3QztBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQTZDLEdBQUcsd0NBQXdDO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiRDpcXFdlYnN0ZXAyXFxzaGlwb3dsLW1lcmdlXFxub2RlX21vZHVsZXNcXGJhc2ljLWZ0cFxcZGlzdFxcdHJhbnNmZXIuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRvd25sb2FkVG8gPSBleHBvcnRzLnVwbG9hZEZyb20gPSBleHBvcnRzLmNvbm5lY3RGb3JQYXNzaXZlVHJhbnNmZXIgPSBleHBvcnRzLnBhcnNlUGFzdlJlc3BvbnNlID0gZXhwb3J0cy5lbnRlclBhc3NpdmVNb2RlSVB2NCA9IGV4cG9ydHMucGFyc2VFcHN2UmVzcG9uc2UgPSBleHBvcnRzLmVudGVyUGFzc2l2ZU1vZGVJUHY2ID0gdm9pZCAwO1xuY29uc3QgbmV0VXRpbHNfMSA9IHJlcXVpcmUoXCIuL25ldFV0aWxzXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgcGFyc2VDb250cm9sUmVzcG9uc2VfMSA9IHJlcXVpcmUoXCIuL3BhcnNlQ29udHJvbFJlc3BvbnNlXCIpO1xuLyoqXG4gKiBQcmVwYXJlIGEgZGF0YSBzb2NrZXQgdXNpbmcgcGFzc2l2ZSBtb2RlIG92ZXIgSVB2Ni5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZW50ZXJQYXNzaXZlTW9kZUlQdjYoZnRwKSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZnRwLnJlcXVlc3QoXCJFUFNWXCIpO1xuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUVwc3ZSZXNwb25zZShyZXMubWVzc2FnZSk7XG4gICAgaWYgKCFwb3J0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbid0IHBhcnNlIEVQU1YgcmVzcG9uc2U6IFwiICsgcmVzLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBjb25zdCBjb250cm9sSG9zdCA9IGZ0cC5zb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICBpZiAoY29udHJvbEhvc3QgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDb250cm9sIHNvY2tldCBpcyBkaXNjb25uZWN0ZWQsIGNhbid0IGdldCByZW1vdGUgYWRkcmVzcy5cIik7XG4gICAgfVxuICAgIGF3YWl0IGNvbm5lY3RGb3JQYXNzaXZlVHJhbnNmZXIoY29udHJvbEhvc3QsIHBvcnQsIGZ0cCk7XG4gICAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuZW50ZXJQYXNzaXZlTW9kZUlQdjYgPSBlbnRlclBhc3NpdmVNb2RlSVB2Njtcbi8qKlxuICogUGFyc2UgYW4gRVBTViByZXNwb25zZS4gUmV0dXJucyBvbmx5IHRoZSBwb3J0IGFzIGluIEVQU1YgdGhlIGhvc3Qgb2YgdGhlIGNvbnRyb2wgY29ubmVjdGlvbiBpcyB1c2VkLlxuICovXG5mdW5jdGlvbiBwYXJzZUVwc3ZSZXNwb25zZShtZXNzYWdlKSB7XG4gICAgLy8gR2V0IHBvcnQgZnJvbSBFUFNWIHJlc3BvbnNlLCBlLmcuIFwiMjI5IEVudGVyaW5nIEV4dGVuZGVkIFBhc3NpdmUgTW9kZSAofHx8NjQ0NnwpXCJcbiAgICAvLyBTb21lIEZUUCBTZXJ2ZXJzIHN1Y2ggYXMgdGhlIG9uZSBvbiBJQk0gaSAoT1MvNDAwKSB1c2UgISBpbnN0ZWFkIG9mIHwgaW4gdGhlaXIgRVBTViByZXNwb25zZS5cbiAgICBjb25zdCBncm91cHMgPSBtZXNzYWdlLm1hdGNoKC9bfCFdezN9KC4rKVt8IV0vKTtcbiAgICBpZiAoZ3JvdXBzID09PSBudWxsIHx8IGdyb3Vwc1sxXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcGFyc2UgcmVzcG9uc2UgdG8gJ0VQU1YnOiAke21lc3NhZ2V9YCk7XG4gICAgfVxuICAgIGNvbnN0IHBvcnQgPSBwYXJzZUludChncm91cHNbMV0sIDEwKTtcbiAgICBpZiAoTnVtYmVyLmlzTmFOKHBvcnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgcGFyc2UgcmVzcG9uc2UgdG8gJ0VQU1YnLCBwb3J0IGlzIG5vdCBhIG51bWJlcjogJHttZXNzYWdlfWApO1xuICAgIH1cbiAgICByZXR1cm4gcG9ydDtcbn1cbmV4cG9ydHMucGFyc2VFcHN2UmVzcG9uc2UgPSBwYXJzZUVwc3ZSZXNwb25zZTtcbi8qKlxuICogUHJlcGFyZSBhIGRhdGEgc29ja2V0IHVzaW5nIHBhc3NpdmUgbW9kZSBvdmVyIElQdjQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGVudGVyUGFzc2l2ZU1vZGVJUHY0KGZ0cCkge1xuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZ0cC5yZXF1ZXN0KFwiUEFTVlwiKTtcbiAgICBjb25zdCB0YXJnZXQgPSBwYXJzZVBhc3ZSZXNwb25zZShyZXMubWVzc2FnZSk7XG4gICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgcGFyc2UgUEFTViByZXNwb25zZTogXCIgKyByZXMubWVzc2FnZSk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBob3N0IGluIHRoZSBQQVNWIHJlc3BvbnNlIGhhcyBhIGxvY2FsIGFkZHJlc3Mgd2hpbGUgdGhlIGNvbnRyb2wgY29ubmVjdGlvbiBoYXNuJ3QsXG4gICAgLy8gd2UgYXNzdW1lIGEgTkFUIGlzc3VlIGFuZCB1c2UgdGhlIElQIG9mIHRoZSBjb250cm9sIGNvbm5lY3Rpb24gYXMgdGhlIHRhcmdldCBmb3IgdGhlIGRhdGEgY29ubmVjdGlvbi5cbiAgICAvLyBXZSBjYW4ndCBhbHdheXMgcGVyZm9ybSB0aGlzIHJlcGxhY2VtZW50IGJlY2F1c2UgaXQncyBwb3NzaWJsZSAoYWx0aG91Z2ggdW5saWtlbHkpIHRoYXQgdGhlIEZUUCBzZXJ2ZXJcbiAgICAvLyBpbmRlZWQgdXNlcyBhIGRpZmZlcmVudCBob3N0IGZvciBkYXRhIGNvbm5lY3Rpb25zLlxuICAgIGNvbnN0IGNvbnRyb2xIb3N0ID0gZnRwLnNvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgIGlmICgoMCwgbmV0VXRpbHNfMS5pcElzUHJpdmF0ZVY0QWRkcmVzcykodGFyZ2V0Lmhvc3QpICYmIGNvbnRyb2xIb3N0ICYmICEoMCwgbmV0VXRpbHNfMS5pcElzUHJpdmF0ZVY0QWRkcmVzcykoY29udHJvbEhvc3QpKSB7XG4gICAgICAgIHRhcmdldC5ob3N0ID0gY29udHJvbEhvc3Q7XG4gICAgfVxuICAgIGF3YWl0IGNvbm5lY3RGb3JQYXNzaXZlVHJhbnNmZXIodGFyZ2V0Lmhvc3QsIHRhcmdldC5wb3J0LCBmdHApO1xuICAgIHJldHVybiByZXM7XG59XG5leHBvcnRzLmVudGVyUGFzc2l2ZU1vZGVJUHY0ID0gZW50ZXJQYXNzaXZlTW9kZUlQdjQ7XG4vKipcbiAqIFBhcnNlIGEgUEFTViByZXNwb25zZS5cbiAqL1xuZnVuY3Rpb24gcGFyc2VQYXN2UmVzcG9uc2UobWVzc2FnZSkge1xuICAgIC8vIEdldCBob3N0IGFuZCBwb3J0IGZyb20gUEFTViByZXNwb25zZSwgZS5nLiBcIjIyNyBFbnRlcmluZyBQYXNzaXZlIE1vZGUgKDE5MiwxNjgsMSwxMDAsMTAsMjI5KVwiXG4gICAgY29uc3QgZ3JvdXBzID0gbWVzc2FnZS5tYXRjaCgvKFstXFxkXSssWy1cXGRdKyxbLVxcZF0rLFstXFxkXSspLChbLVxcZF0rKSwoWy1cXGRdKykvKTtcbiAgICBpZiAoZ3JvdXBzID09PSBudWxsIHx8IGdyb3Vwcy5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBwYXJzZSByZXNwb25zZSB0byAnUEFTVic6ICR7bWVzc2FnZX1gKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaG9zdDogZ3JvdXBzWzFdLnJlcGxhY2UoLywvZywgXCIuXCIpLFxuICAgICAgICBwb3J0OiAocGFyc2VJbnQoZ3JvdXBzWzJdLCAxMCkgJiAyNTUpICogMjU2ICsgKHBhcnNlSW50KGdyb3Vwc1szXSwgMTApICYgMjU1KVxuICAgIH07XG59XG5leHBvcnRzLnBhcnNlUGFzdlJlc3BvbnNlID0gcGFyc2VQYXN2UmVzcG9uc2U7XG5mdW5jdGlvbiBjb25uZWN0Rm9yUGFzc2l2ZVRyYW5zZmVyKGhvc3QsIHBvcnQsIGZ0cCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGxldCBzb2NrZXQgPSBmdHAuX25ld1NvY2tldCgpO1xuICAgICAgICBjb25zdCBoYW5kbGVDb25uRXJyID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgZXJyLm1lc3NhZ2UgPSBcIkNhbid0IG9wZW4gZGF0YSBjb25uZWN0aW9uIGluIHBhc3NpdmUgbW9kZTogXCIgKyBlcnIubWVzc2FnZTtcbiAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBoYW5kbGVUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgc29ja2V0LmRlc3Ryb3koKTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoYFRpbWVvdXQgd2hlbiB0cnlpbmcgdG8gb3BlbiBkYXRhIGNvbm5lY3Rpb24gdG8gJHtob3N0fToke3BvcnR9YCkpO1xuICAgICAgICB9O1xuICAgICAgICBzb2NrZXQuc2V0VGltZW91dChmdHAudGltZW91dCk7XG4gICAgICAgIHNvY2tldC5vbihcImVycm9yXCIsIGhhbmRsZUNvbm5FcnIpO1xuICAgICAgICBzb2NrZXQub24oXCJ0aW1lb3V0XCIsIGhhbmRsZVRpbWVvdXQpO1xuICAgICAgICBzb2NrZXQuY29ubmVjdCh7IHBvcnQsIGhvc3QsIGZhbWlseTogZnRwLmlwRmFtaWx5IH0sICgpID0+IHtcbiAgICAgICAgICAgIGlmIChmdHAuc29ja2V0IGluc3RhbmNlb2YgdGxzXzEuVExTU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgc29ja2V0ID0gKDAsIHRsc18xLmNvbm5lY3QpKE9iamVjdC5hc3NpZ24oe30sIGZ0cC50bHNPcHRpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldCxcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV1c2UgdGhlIFRMUyBzZXNzaW9uIG5lZ290aWF0ZWQgZWFybGllciB3aGVuIHRoZSBjb250cm9sIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgLy8gd2FzIHVwZ3JhZGVkLiBTZXJ2ZXJzIGV4cGVjdCB0aGlzIGJlY2F1c2UgaXQgcHJvdmlkZXMgYWRkaXRpb25hbFxuICAgICAgICAgICAgICAgICAgICAvLyBzZWN1cml0eTogSWYgYSBjb21wbGV0ZWx5IG5ldyBzZXNzaW9uIHdvdWxkIGJlIG5lZ290aWF0ZWQsIGEgaGFja2VyXG4gICAgICAgICAgICAgICAgICAgIC8vIGNvdWxkIGd1ZXNzIHRoZSBwb3J0IGFuZCBjb25uZWN0IHRvIHRoZSBuZXcgZGF0YSBjb25uZWN0aW9uIGJlZm9yZSB3ZSBkb1xuICAgICAgICAgICAgICAgICAgICAvLyBieSBqdXN0IHN0YXJ0aW5nIGhpcy9oZXIgb3duIFRMUyBzZXNzaW9uLlxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uOiBmdHAuc29ja2V0LmdldFNlc3Npb24oKVxuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAvLyBJdCdzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgdHJhbnNmZXIgdGFzayB0byB3YWl0IHVudGlsIHRoZVxuICAgICAgICAgICAgICAgIC8vIFRMUyBzb2NrZXQgaXNzdWVkIHRoZSBldmVudCAnc2VjdXJlQ29ubmVjdCcuIFdlIGNhbid0IGRvIHRoaXNcbiAgICAgICAgICAgICAgICAvLyBoZXJlIGJlY2F1c2Ugc29tZSBzZXJ2ZXJzIHdpbGwgc3RhcnQgdXBncmFkaW5nIGFmdGVyIHRoZVxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHRyYW5zZmVyIHJlcXVlc3QgaGFzIGJlZW4gbWFkZS4gTGlzdCBhbmQgZG93bmxvYWQgZG9uJ3RcbiAgICAgICAgICAgICAgICAvLyBoYXZlIHRvIHdhaXQgZm9yIHRoaXMgZXZlbnQgYmVjYXVzZSB0aGUgc2VydmVyIHNlbmRzIHdoZW5ldmVyIGl0XG4gICAgICAgICAgICAgICAgLy8gaXMgcmVhZHkuIEJ1dCBmb3IgdXBsb2FkIHRoaXMgaGFzIHRvIGJlIHRha2VuIGludG8gYWNjb3VudCxcbiAgICAgICAgICAgICAgICAvLyBzZWUgdGhlIGRldGFpbHMgaW4gdGhlIHVwbG9hZCgpIGZ1bmN0aW9uIGJlbG93LlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGV0IHRoZSBGVFBDb250ZXh0IGxpc3RlbiB0byBlcnJvcnMgZnJvbSBub3cgb24sIHJlbW92ZSBsb2NhbCBoYW5kbGVyLlxuICAgICAgICAgICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgaGFuZGxlQ29ubkVycik7XG4gICAgICAgICAgICBzb2NrZXQucmVtb3ZlTGlzdGVuZXIoXCJ0aW1lb3V0XCIsIGhhbmRsZVRpbWVvdXQpO1xuICAgICAgICAgICAgZnRwLmRhdGFTb2NrZXQgPSBzb2NrZXQ7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuZXhwb3J0cy5jb25uZWN0Rm9yUGFzc2l2ZVRyYW5zZmVyID0gY29ubmVjdEZvclBhc3NpdmVUcmFuc2Zlcjtcbi8qKlxuICogSGVscHMgcmVzb2x2aW5nL3JlamVjdGluZyB0cmFuc2ZlcnMuXG4gKlxuICogVGhpcyBpcyB1c2VkIGludGVybmFsbHkgZm9yIGFsbCBGVFAgdHJhbnNmZXJzLiBGb3IgZXhhbXBsZSB3aGVuIGRvd25sb2FkaW5nLCB0aGUgc2VydmVyIG1pZ2h0IGNvbmZpcm1cbiAqIHdpdGggXCIyMjYgVHJhbnNmZXIgY29tcGxldGVcIiB3aGVuIGluIGZhY3QgdGhlIGRvd25sb2FkIG9uIHRoZSBkYXRhIGNvbm5lY3Rpb24gaGFzIG5vdCBmaW5pc2hlZFxuICogeWV0LiBXaXRoIGFsbCB0cmFuc2ZlcnMgd2UgbWFrZSBzdXJlIHRoYXQgYSkgdGhlIHJlc3VsdCBhcnJpdmVkIGFuZCBiKSBoYXMgYmVlbiBjb25maXJtZWQgYnlcbiAqIGUuZy4gdGhlIGNvbnRyb2wgY29ubmVjdGlvbi4gV2UganVzdCBkb24ndCBrbm93IGluIHdoaWNoIG9yZGVyIHRoaXMgd2lsbCBoYXBwZW4uXG4gKi9cbmNsYXNzIFRyYW5zZmVyUmVzb2x2ZXIge1xuICAgIC8qKlxuICAgICAqIEluc3RhbnRpYXRlIGEgVHJhbnNmZXJSZXNvbHZlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGZ0cCwgcHJvZ3Jlc3MpIHtcbiAgICAgICAgdGhpcy5mdHAgPSBmdHA7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3MgPSBwcm9ncmVzcztcbiAgICAgICAgdGhpcy5yZXNwb25zZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5kYXRhVHJhbnNmZXJEb25lID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1hcmsgdGhlIGJlZ2lubmluZyBvZiBhIHRyYW5zZmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSBOYW1lIG9mIHRoZSB0cmFuc2ZlciwgdXN1YWxseSB0aGUgZmlsZW5hbWUuXG4gICAgICogQHBhcmFtIHR5cGUgLSBUeXBlIG9mIHRyYW5zZmVyLCB1c3VhbGx5IFwidXBsb2FkXCIgb3IgXCJkb3dubG9hZFwiLlxuICAgICAqL1xuICAgIG9uRGF0YVN0YXJ0KG5hbWUsIHR5cGUpIHtcbiAgICAgICAgLy8gTGV0IHRoZSBkYXRhIHNvY2tldCBiZSBpbiBjaGFyZ2Ugb2YgdHJhY2tpbmcgdGltZW91dHMgZHVyaW5nIHRyYW5zZmVyLlxuICAgICAgICAvLyBUaGUgY29udHJvbCBzb2NrZXQgc2l0cyBpZGxlIGR1cmluZyB0aGlzIHRpbWUgYW55d2F5IGFuZCBtaWdodCBwcm92b2tlXG4gICAgICAgIC8vIGEgdGltZW91dCB1bm5lY2Vzc2FyaWx5LiBUaGUgY29udHJvbCBjb25uZWN0aW9uIHdpbGwgdGFrZSBjYXJlXG4gICAgICAgIC8vIG9mIHRpbWVvdXRzIGFnYWluIG9uY2UgZGF0YSB0cmFuc2ZlciBpcyBjb21wbGV0ZSBvciBmYWlsZWQuXG4gICAgICAgIGlmICh0aGlzLmZ0cC5kYXRhU29ja2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgdHJhbnNmZXIgc2hvdWxkIHN0YXJ0IGJ1dCB0aGVyZSBpcyBubyBkYXRhIGNvbm5lY3Rpb24uXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZnRwLnNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgICAgICB0aGlzLmZ0cC5kYXRhU29ja2V0LnNldFRpbWVvdXQodGhpcy5mdHAudGltZW91dCk7XG4gICAgICAgIHRoaXMucHJvZ3Jlc3Muc3RhcnQodGhpcy5mdHAuZGF0YVNvY2tldCwgbmFtZSwgdHlwZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBkYXRhIGNvbm5lY3Rpb24gaGFzIGZpbmlzaGVkIHRoZSB0cmFuc2Zlci5cbiAgICAgKi9cbiAgICBvbkRhdGFEb25lKHRhc2spIHtcbiAgICAgICAgdGhpcy5wcm9ncmVzcy51cGRhdGVBbmRTdG9wKCk7XG4gICAgICAgIC8vIEhhbmQtb3ZlciB0aW1lb3V0IHRyYWNraW5nIGJhY2sgdG8gdGhlIGNvbnRyb2wgY29ubmVjdGlvbi4gSXQncyBwb3NzaWJsZSB0aGF0XG4gICAgICAgIC8vIHdlIGRvbid0IHJlY2VpdmUgdGhlIHJlc3BvbnNlIG92ZXIgdGhlIGNvbnRyb2wgY29ubmVjdGlvbiB0aGF0IHRoZSB0cmFuc2ZlciBpc1xuICAgICAgICAvLyBkb25lLiBJbiB0aGlzIGNhc2UsIHdlIHdhbnQgdG8gY29ycmVjdGx5IGFzc29jaWF0ZSB0aGUgcmVzdWx0aW5nIHRpbWVvdXQgd2l0aFxuICAgICAgICAvLyB0aGUgY29udHJvbCBjb25uZWN0aW9uLlxuICAgICAgICB0aGlzLmZ0cC5zb2NrZXQuc2V0VGltZW91dCh0aGlzLmZ0cC50aW1lb3V0KTtcbiAgICAgICAgaWYgKHRoaXMuZnRwLmRhdGFTb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZnRwLmRhdGFTb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFUcmFuc2ZlckRvbmUgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyeVJlc29sdmUodGFzayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjb250cm9sIGNvbm5lY3Rpb24gcmVwb3J0cyB0aGUgdHJhbnNmZXIgYXMgZmluaXNoZWQuXG4gICAgICovXG4gICAgb25Db250cm9sRG9uZSh0YXNrLCByZXNwb25zZSkge1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgICAgIHRoaXMudHJ5UmVzb2x2ZSh0YXNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQW4gZXJyb3IgaGFzIGJlZW4gcmVwb3J0ZWQgYW5kIHRoZSB0YXNrIHNob3VsZCBiZSByZWplY3RlZC5cbiAgICAgKi9cbiAgICBvbkVycm9yKHRhc2ssIGVycikge1xuICAgICAgICB0aGlzLnByb2dyZXNzLnVwZGF0ZUFuZFN0b3AoKTtcbiAgICAgICAgdGhpcy5mdHAuc29ja2V0LnNldFRpbWVvdXQodGhpcy5mdHAudGltZW91dCk7XG4gICAgICAgIHRoaXMuZnRwLmRhdGFTb2NrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgIHRhc2sucmVqZWN0KGVycik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbnRyb2wgY29ubmVjdGlvbiBzZW50IGFuIHVuZXhwZWN0ZWQgcmVxdWVzdCByZXF1aXJpbmcgYSByZXNwb25zZSBmcm9tIG91ciBwYXJ0LiBXZVxuICAgICAqIGNhbid0IHByb3ZpZGUgdGhhdCAoYmVjYXVzZSB1bmtub3duKSBhbmQgaGF2ZSB0byBjbG9zZSB0aGUgY29udHJleHQgd2l0aCBhbiBlcnJvciBiZWNhdXNlXG4gICAgICogdGhlIEZUUCBzZXJ2ZXIgaXMgbm93IGNhdWdodCB1cCBpbiBhIHN0YXRlIHdlIGNhbid0IHJlc29sdmUuXG4gICAgICovXG4gICAgb25VbmV4cGVjdGVkUmVxdWVzdChyZXNwb25zZSkge1xuICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgRlRQIHJlc3BvbnNlIGlzIHJlcXVlc3RpbmcgYW4gYW5zd2VyOiAke3Jlc3BvbnNlLm1lc3NhZ2V9YCk7XG4gICAgICAgIHRoaXMuZnRwLmNsb3NlV2l0aEVycm9yKGVycik7XG4gICAgfVxuICAgIHRyeVJlc29sdmUodGFzaykge1xuICAgICAgICAvLyBUbyByZXNvbHZlLCB3ZSBuZWVkIGJvdGggY29udHJvbCBhbmQgZGF0YSBjb25uZWN0aW9uIHRvIHJlcG9ydCB0aGF0IHRoZSB0cmFuc2ZlciBpcyBkb25lLlxuICAgICAgICBjb25zdCBjYW5SZXNvbHZlID0gdGhpcy5kYXRhVHJhbnNmZXJEb25lICYmIHRoaXMucmVzcG9uc2UgIT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKGNhblJlc29sdmUpIHtcbiAgICAgICAgICAgIHRoaXMuZnRwLmRhdGFTb2NrZXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0YXNrLnJlc29sdmUodGhpcy5yZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiB1cGxvYWRGcm9tKHNvdXJjZSwgY29uZmlnKSB7XG4gICAgY29uc3QgcmVzb2x2ZXIgPSBuZXcgVHJhbnNmZXJSZXNvbHZlcihjb25maWcuZnRwLCBjb25maWcudHJhY2tlcik7XG4gICAgY29uc3QgZnVsbENvbW1hbmQgPSBgJHtjb25maWcuY29tbWFuZH0gJHtjb25maWcucmVtb3RlUGF0aH1gO1xuICAgIHJldHVybiBjb25maWcuZnRwLmhhbmRsZShmdWxsQ29tbWFuZCwgKHJlcywgdGFzaykgPT4ge1xuICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHJlc29sdmVyLm9uRXJyb3IodGFzaywgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChyZXMuY29kZSA9PT0gMTUwIHx8IHJlcy5jb2RlID09PSAxMjUpIHsgLy8gUmVhZHkgdG8gdXBsb2FkXG4gICAgICAgICAgICBjb25zdCBkYXRhU29ja2V0ID0gY29uZmlnLmZ0cC5kYXRhU29ja2V0O1xuICAgICAgICAgICAgaWYgKCFkYXRhU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIub25FcnJvcih0YXNrLCBuZXcgRXJyb3IoXCJVcGxvYWQgc2hvdWxkIGJlZ2luIGJ1dCBubyBkYXRhIGNvbm5lY3Rpb24gaXMgYXZhaWxhYmxlLlwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgd2UgYXJlIHVzaW5nIFRMUywgd2UgaGF2ZSB0byB3YWl0IHVudGlsIHRoZSBkYXRhU29ja2V0IGlzc3VlZFxuICAgICAgICAgICAgLy8gJ3NlY3VyZUNvbm5lY3QnLiBJZiB0aGlzIGhhc24ndCBoYXBwZW5lZCB5ZXQsIGdldENpcGhlcigpIHJldHVybnMgdW5kZWZpbmVkLlxuICAgICAgICAgICAgY29uc3QgY2FuVXBsb2FkID0gXCJnZXRDaXBoZXJcIiBpbiBkYXRhU29ja2V0ID8gZGF0YVNvY2tldC5nZXRDaXBoZXIoKSAhPT0gdW5kZWZpbmVkIDogdHJ1ZTtcbiAgICAgICAgICAgIG9uQ29uZGl0aW9uT3JFdmVudChjYW5VcGxvYWQsIGRhdGFTb2NrZXQsIFwic2VjdXJlQ29ubmVjdFwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uZmlnLmZ0cC5sb2coYFVwbG9hZGluZyB0byAkeygwLCBuZXRVdGlsc18xLmRlc2NyaWJlQWRkcmVzcykoZGF0YVNvY2tldCl9ICgkeygwLCBuZXRVdGlsc18xLmRlc2NyaWJlVExTKShkYXRhU29ja2V0KX0pYCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIub25EYXRhU3RhcnQoY29uZmlnLnJlbW90ZVBhdGgsIGNvbmZpZy50eXBlKTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHNvdXJjZSwgZGF0YVNvY2tldCwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIub25FcnJvcih0YXNrLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZXIub25EYXRhRG9uZSh0YXNrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIHBhcnNlQ29udHJvbFJlc3BvbnNlXzEucG9zaXRpdmVDb21wbGV0aW9uKShyZXMuY29kZSkpIHsgLy8gVHJhbnNmZXIgY29tcGxldGVcbiAgICAgICAgICAgIHJlc29sdmVyLm9uQ29udHJvbERvbmUodGFzaywgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoMCwgcGFyc2VDb250cm9sUmVzcG9uc2VfMS5wb3NpdGl2ZUludGVybWVkaWF0ZSkocmVzLmNvZGUpKSB7XG4gICAgICAgICAgICByZXNvbHZlci5vblVuZXhwZWN0ZWRSZXF1ZXN0KHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWdub3JlIGFsbCBvdGhlciBwb3NpdGl2ZSBwcmVsaW1pbmFyeSByZXNwb25zZSBjb2RlcyAoPCAyMDApXG4gICAgfSk7XG59XG5leHBvcnRzLnVwbG9hZEZyb20gPSB1cGxvYWRGcm9tO1xuZnVuY3Rpb24gZG93bmxvYWRUbyhkZXN0aW5hdGlvbiwgY29uZmlnKSB7XG4gICAgaWYgKCFjb25maWcuZnRwLmRhdGFTb2NrZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRG93bmxvYWQgd2lsbCBiZSBpbml0aWF0ZWQgYnV0IG5vIGRhdGEgY29ubmVjdGlvbiBpcyBhdmFpbGFibGUuXCIpO1xuICAgIH1cbiAgICBjb25zdCByZXNvbHZlciA9IG5ldyBUcmFuc2ZlclJlc29sdmVyKGNvbmZpZy5mdHAsIGNvbmZpZy50cmFja2VyKTtcbiAgICByZXR1cm4gY29uZmlnLmZ0cC5oYW5kbGUoY29uZmlnLmNvbW1hbmQsIChyZXMsIHRhc2spID0+IHtcbiAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXNvbHZlci5vbkVycm9yKHRhc2ssIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzLmNvZGUgPT09IDE1MCB8fCByZXMuY29kZSA9PT0gMTI1KSB7IC8vIFJlYWR5IHRvIGRvd25sb2FkXG4gICAgICAgICAgICBjb25zdCBkYXRhU29ja2V0ID0gY29uZmlnLmZ0cC5kYXRhU29ja2V0O1xuICAgICAgICAgICAgaWYgKCFkYXRhU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIub25FcnJvcih0YXNrLCBuZXcgRXJyb3IoXCJEb3dubG9hZCBzaG91bGQgYmVnaW4gYnV0IG5vIGRhdGEgY29ubmVjdGlvbiBpcyBhdmFpbGFibGUuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25maWcuZnRwLmxvZyhgRG93bmxvYWRpbmcgZnJvbSAkeygwLCBuZXRVdGlsc18xLmRlc2NyaWJlQWRkcmVzcykoZGF0YVNvY2tldCl9ICgkeygwLCBuZXRVdGlsc18xLmRlc2NyaWJlVExTKShkYXRhU29ja2V0KX0pYCk7XG4gICAgICAgICAgICByZXNvbHZlci5vbkRhdGFTdGFydChjb25maWcucmVtb3RlUGF0aCwgY29uZmlnLnR5cGUpO1xuICAgICAgICAgICAgKDAsIHN0cmVhbV8xLnBpcGVsaW5lKShkYXRhU29ja2V0LCBkZXN0aW5hdGlvbiwgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyLm9uRXJyb3IodGFzaywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmVyLm9uRGF0YURvbmUodGFzayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVzLmNvZGUgPT09IDM1MCkgeyAvLyBSZXN0YXJ0aW5nIGF0IHN0YXJ0QXQuXG4gICAgICAgICAgICBjb25maWcuZnRwLnNlbmQoXCJSRVRSIFwiICsgY29uZmlnLnJlbW90ZVBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCgwLCBwYXJzZUNvbnRyb2xSZXNwb25zZV8xLnBvc2l0aXZlQ29tcGxldGlvbikocmVzLmNvZGUpKSB7IC8vIFRyYW5zZmVyIGNvbXBsZXRlXG4gICAgICAgICAgICByZXNvbHZlci5vbkNvbnRyb2xEb25lKHRhc2ssIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKDAsIHBhcnNlQ29udHJvbFJlc3BvbnNlXzEucG9zaXRpdmVJbnRlcm1lZGlhdGUpKHJlcy5jb2RlKSkge1xuICAgICAgICAgICAgcmVzb2x2ZXIub25VbmV4cGVjdGVkUmVxdWVzdChyZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElnbm9yZSBhbGwgb3RoZXIgcG9zaXRpdmUgcHJlbGltaW5hcnkgcmVzcG9uc2UgY29kZXMgKDwgMjAwKVxuICAgIH0pO1xufVxuZXhwb3J0cy5kb3dubG9hZFRvID0gZG93bmxvYWRUbztcbi8qKlxuICogQ2FsbHMgYSBmdW5jdGlvbiBpbW1lZGlhdGVseSBpZiBhIGNvbmRpdGlvbiBpcyBtZXQgb3Igc3Vic2NyaWJlcyB0byBhbiBldmVudCBhbmQgY2FsbHNcbiAqIGl0IG9uY2UgdGhlIGV2ZW50IGlzIGVtaXR0ZWQuXG4gKlxuICogQHBhcmFtIGNvbmRpdGlvbiAgVGhlIGNvbmRpdGlvbiB0byB0ZXN0LlxuICogQHBhcmFtIGVtaXR0ZXIgIFRoZSBlbWl0dGVyIHRvIHVzZSBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBAcGFyYW0gZXZlbnROYW1lICBUaGUgZXZlbnQgdG8gc3Vic2NyaWJlIHRvIGlmIHRoZSBjb25kaXRpb24gaXMgbm90IG1ldC5cbiAqIEBwYXJhbSBhY3Rpb24gIFRoZSBmdW5jdGlvbiB0byBjYWxsLlxuICovXG5mdW5jdGlvbiBvbkNvbmRpdGlvbk9yRXZlbnQoY29uZGl0aW9uLCBlbWl0dGVyLCBldmVudE5hbWUsIGFjdGlvbikge1xuICAgIGlmIChjb25kaXRpb24gPT09IHRydWUpIHtcbiAgICAgICAgYWN0aW9uKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBlbWl0dGVyLm9uY2UoZXZlbnROYW1lLCAoKSA9PiBhY3Rpb24oKSk7XG4gICAgfVxufVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/basic-ftp/dist/transfer.js\n");

/***/ })

};
;